Метод - функция, которая может быть привязана к типу данных. Метод отличается только тем, что перед определением нам нужно указать структуру. 

Он может не менять оригинальной структуры. Передача может быть по значению (в метод передаётся копия типа). Пример ниже не затронет оригинальную структуру и по сути смысла особо не имеет.
```go
// не изменит оригинальной структуры, для которой вызван  
func (p Person) UpdateName(name string) {  
    p.Name = name  
}
```

Также передача может быть по адресу. То есть передаётся адрес на тип и его оригинальная структура. Тут все изменения сохранятся.
```go
// изменит оригинальную структуру  
func (p *Person) SetName(name string) {  
    p.Name = name  
}
```

На практике выглядит так (в примере сама структура)
```go
func main() {  
    pers := Person{1, "Jack"}  
    pers.SetName("Vasya")  
    fmt.Printf("%#v\n", pers)  
}
// Вывод main.Person{Id:1, Name:"Vasya"}
```

Фактически для компилятора это выглядит так (указатель)
```go
(&pers).SetName("Vasya")
```

Если же одна структура встроена в другую, то её методы наследуются
```go
type Person struct {  
    Id int  
    Name string  
}  
  
type Account struct {  
    Id int  
    Name string  
    Person
}
```

При этом при вызове SetName изменится только структура Person
```go
var acc Account = Account{  
    Id: 1,  
    Name: "John Doe",  
    Person: Person{  
       Id: 2,  
       Name: "Vasya",  
    },  
}  
  
acc.SetName("Petya")  
fmt.Println(acc)
// вывод {1 John Doe {2 Petya}}
```

При этом если у Account тоже будет метод SetName, то поле Name изменится в нём, так как метод будет иметь более высокий приоритет.
```go
func (p *Account) SetName(name string) {  
    p.Name = name  
}  
  
func main() {  
    var acc Account = Account{  
       Id: 1,  
       Name: "John Doe",  
       Person: Person{  
          Id: 2,  
          Name: "Vasya",  
       },  
    }  
  
    acc.SetName("Petya")  
    fmt.Println(acc)  
} // вывод {1 Petya {2 Vasya}}
```

Если же имена методов одинаковые и нам требуется применить изменения только встроенной структуры, то стоить указать имя структуры, к которой применяется метод
```go
func main() {  
    var acc Account = Account{  
       Id: 1,  
       Name: "John Doe",  
       Person: Person{  
          Id: 2,  
          Name: "Vasya",  
       },  
    }  
  
    acc.SetName("Petya")  
    acc.Person.SetName("Peter")  
    fmt.Println(acc)  
} // вывод {1 Petya {2 Peter}}
```

Также методы могут быть не только у структур, но и у типов. Например, мы можем создать собственный тип слайса и задать ему определённые методы.
```go
type MySlice []int  
  
func (sl *MySlice) Add (val int) {  
    *sl = append(*sl, val)  
}  
  
func (sl *MySlice) Count()int {  
    return len(*sl)  
}  
  
func main() {  
    sl := MySlice([]int{1, 2, 3, 4, 5}) // преобразовываем тип
    sl.Add(6)  
    fmt.Println(sl.Count(), sl)  
}
```


**Примечание**
Коротко можно сказать, что структуры и методы в go служат для описания сущностей, которые мы моделируем в процессе разработки