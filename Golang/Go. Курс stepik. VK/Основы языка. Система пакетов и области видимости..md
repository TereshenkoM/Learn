
go работает с сиcтемной переменной go path, в ней должны находится некоторые спец. директории.

1) Папка bin - в ней лежат собранные бинарники
2) Папка pkg - в ней лежат временные объектные файлы
3) Папка src - в ней лежит код нашей программы и какие-то пакеты, которые мы копируем. Файл main с package main и func main - обязателен. По сути точка входа

В go есть очень простое правило
**Если переменная, константа, структура, поле структуры, функция начинается с заглавной буквы, то сущность экспортируемая, если со строчной, то она принадлежит только этому пакету**.

Импорт распространяется на файл и при этом все импорты должны использоваться. Пакет при это состоит из директорий,  а не из файлов. Следовательно в такой структуре **всё** что я объявлю в файле func.go, будет доступно и в person.go и наоборот (у обоих package person).

```
└── coursera
    ├── go.mod
    └── visibility
        ├── main.go
        └── person
            ├── func.go
            └── person.go

```

Пример. Файл person.go
```go
package person  
  
var (  
    Public = 1
    private = 1  
)  
  
type Person struct {  
    ID int  
    Name string  
    secret string  
}  
  
func (p Person) UpdateSecret (secret string) {  
    p.secret = secret  
}
```

Файл func.go
```go
package person  
  
import "fmt"  
  
func NewPerson(id int, name, secret string) *Person {  
    return &Person{  
       ID: 1,  
       Name: "Vasya",  
       secret: "secret",  
    }  
}  
  
func GetSecret(p *Person) string {  
    return p.secret  
}  
  
func printSecret(p *Person) {  
    fmt.Println(p.secret)  
}
```

**Примечание**
В файле go.mod мы ищем пакеты не по относительным путям,а по module path (определён в go.mod).

Пример файла
```go
module coursera  
  
go 1.24
```


Пример не работающего импорта 
```go
// файл main.go. Он вне пакета person
package main  
  
import (  
    "coursera/visibility/person"  
    "fmt")  
  
func main() {  
    p := person.NewPerson(1, "mark", "secret")  
    fmt.Println(p.secret)  
}

// вывод > go run visibility/main.go
// # command-line-arguments
// visibility/main.go:10:16: p.secret undefined (type *person.Person has no // field or method secret)
```

При этом установить его я могу (метод NewPerson).

В go не принято дробить программу на много маленьких пакетов. Пакеты в go обычно достаточно большие.