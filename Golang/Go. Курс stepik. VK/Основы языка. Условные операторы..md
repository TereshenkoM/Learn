Представлен конструкцией if - условное выражение. В качестве условия может быть только булево значение (ноль или пустая строка не подходит).

```go
boolVal := true  
if boolVal {  
    fmt.Println("true")  
}
```

Также мы можем строить условие с блоком инициализации
```go
// условие с блоком инициализации  
mapVal := map[string]int{"a": 1}  
if keyVal, ok := mapVal["a"]; ok {  
    fmt.Println(keyVal)  
}
```


Можно получить только признак существования
```go
// получаем признак существования  
if _, keyExist := mapVal["a"]; keyExist {  
    fmt.Println("key exist")  
}
```

Множественные if else
```go
cond := 1  
// множественный if else  
if cond == 1 {  
    fmt.Println("cond is 1")  
} else if cond == 2 {  
    fmt.Println("cond is 2")  
}
```

В go есть оператор switch case для одной переменной. Но есть ньюанс. Чтобы перейти в следующее условие нужно самому прописывать fallthrough, в противном случае в следующий блок условий мы не попадём. Блок default выполняется когда ни одно из условий не применилось.

```go
// switch по 1 переменной  
strVal := "hello"  
switch strVal {  
case "name":  
    fallthrough  
case "hello", "val":  
    // some  
default:  
    // some  
}
```

Также есть switch case для многих переменных
```go
var val1, val2 = 2, 2  
switch  {  
    case val1 > 1 || val2 < 11:  
       fmt.Println("val1 > val2")  
    case val2 > 10:  
       fmt.Println("val2 > 10")  
}
```

Также бывает полезным выйти из switch case в цикле. Для этого используется break для выхода из switch. Но иногда бывает нужно, чтобы завершился и сам цикл, тогда циклу указывается метка и пишется break <метка цикла>.
```go
Loop: // метка цикла  
    for key, val := range mapVal {  
       println("swithg in loop", key, val)  
       switch {  
          case key == "lastName":  
             break  
             println("dont print this")  
          case key == "firstName":  
             println("switch - break loop here")  
             break Loop  
       }  
    }
```


Полный листинг
```go
package main  
  
import "fmt"  
  
func main() {  
    /// простое условие  
    boolVal := true  
    if boolVal {  
       fmt.Println("true")  
    }  
    // условие с блоком инициализации  
    mapVal := map[string]int{"a": 1}  
    if keyVal, ok := mapVal["a"]; ok {  
       fmt.Println(keyVal)  
    }  
  
    // получаем признак существования  
    if _, keyExist := mapVal["a"]; keyExist {  
       fmt.Println("key exist")  
    }  
  
    cond := 1  
    // множественный if else  
    if cond == 1 {  
       fmt.Println("cond is 1")  
    } else if cond == 2 {  
       fmt.Println("cond is 2")  
    }  
  
    // switch по 1 переменной  
    strVal := "hello"  
    switch strVal {  
    case "name":  
       fallthrough  
    case "hello", "val":  
       // some  
    default:  
       // some  
    }  
  
    var val1, val2 = 2, 2  
    switch  {  
       case val1 > 1 || val2 < 11:  
          fmt.Println("val1 > val2")  
       case val2 > 10:  
          fmt.Println("val2 > 10")  
    }  
  
    Loop:  
       for key, val := range mapVal {  
          println("swithg in loop", key, val)  
          switch {  
             case key == "lastName":  
                break  
                println("dont print this")  
             case key == "firstName":  
                println("switch - break loop here")  
                break Loop  
          }  
       }  
}
```