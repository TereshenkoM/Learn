## Основы про функции
Функция в go объявляется при помощи кодового слова func. Указывается её название, параметры и тип возвращаемого значения

```go
//обычное объявление  
func singleIn(in int) int {  
    return in  
}
```

Параметров может быть много и не обязательно указывать тип для каждого, если они одного и того же типа
```go
// много параметров  
func multIn(a, b int, c int) int {  
    return a + b + c
```

Также возвращаемый результат может быть именованным, то есть мы сразу можем указать возвращаемое значение
```go
// именованный результат  
func namedReturn() (out int) {  
    out = 2  
    return  
}
```

Функция может вернуть несколько результатов. Часто вторым параметром возвращается ошибка (многие системные функции в go так делают). **Примчание**  nil в go - пустое значение.
```go
// несколько результатов  
func multipleReturn(in int) (int, error) {  
    if in > 2{  
       return 0, fmt.Errorf('error')  
    }  
    return in, nil  
}
```

Также можно вернуть несколько именованных результатов
```go
//несколько именованных результатов  
func multiplieNamedReturn(ok bool) (rez int, err error){  
    rez = 1  
    if ok {  
       err = fmt.Errorf("error")  
       return   
}  
    rez = 2  
    return }
```

Есть возможность указать не фиксированное количество параметров. go может принимать неограниченное количество параметров, но только одного типа
```go
// не фиксированное количество параметров  
func sum(in...int) (result int){  
    fmt.Printf("in := %#v\n", in)  
    for _, val := range in {  
       result += val  
    }  
    return }
```

Вызов функции в go
```go
fmt.Println(multiplieNamedReturn(true))  
```

Вызов функции в go с неограниченным количеством аргументов
```go
nums := []int{1,2,3,4,5}  
fmt.Println(nums, sum(nums...))  // распаковывает слайс в одиночные аргументы
```

Общий листинг
```go
package main  
  
import "fmt"  
  
//обычное объявление  
func singleIn(in int) int {  
    return in  
}  
  
// много параметров  
func multIn(a, b int, c int) int {  
    return a + b + c  
}  
  
// именованный результат  
func namedReturn() (out int) {  
    out = 2  
    return  
}  
  
// несколько результатов  
func multipleReturn(in int) (int, error) {  
    if in > 2{  
       return 0, fmt.Errorf("some error happend")  
    }  
    return in, nil  
}  
  
//несколько именованных результатов  
func multiplieNamedReturn(ok bool) (rez int, err error){  
    rez = 1  
    if ok {  
       err = fmt.Errorf("some error happend")  
       return  
    }  
    rez = 2  
    return  
}  
  
// не фиксированное количество параметров  
func sum(in...int) (result int){  
    fmt.Printf("in := %#v\n", in)  
    for _, val := range in {  
       result += val  
    }  
    return  
}  
  
func main() {  
    //fmt.Println(multiplieNamedReturn(true))  
    //return  
    nums := []int{1,2,3,4,5}  
    fmt.Println(nums, sum(nums...))  
    return  
}
```


## Функции как объекты первого класса
Функции как объекты первого класса - значит, что функцию можно присваивать к переменной, принимать как аргумент в другую функцию и возвращать функцию как результат работы другой функции. Также можно использовать функцию как поле какой-то другой структуры.

go поддерживает анонимные функции, которые можно класть в переменную
```go
    func (in string) {  
       fmt.Println("anon", in)  
    }("nobody")  // вызов функции
  
    // присваивание анонимной функции  
    printer := func(in string) {  
       fmt.Println(in)  
    }  
    printer("nobody")  
}
```

Мы можем определить тип функции 
```go
// определяем тип функции  
type strFuncType func(string)string // в скобках параметры и возвращаемое значние за скобками. Их может быть несколько
```

Зачем? Чтобы передавать функцию в параметр другой функции
```go
printer := func(in string) {  
    fmt.Println(in)  
}
// определяем тип функции  
type strFuncType func(string)
// функция принимает коллбек  
worker := func(callback strFuncType) {  
    callback("hello world")  
}  
worker(printer)
```

Замыкания - функция которая обращается к переменным, которые объявлены вне её блока
```go
// определяем тип функции  
type strFuncType func(string)

//функция возвращает замыкание  
prefixer := func(prefix string) strFuncType{  
    return func (in string) {  
       fmt.Printf("[%s] %s\n", prefix, in)  
    }  
}  
successLogger := prefixer("success")  
successLogger("expected behaviour")
```

## Отложенное выполнение, паника, восстановление после паники

В go есть возможность отложенного выполнения функции. То есть работа после завершении функции. Чаще всего используется тогда, когда надо закрыть какой-то ресурс или посчитать время выполнения функции. Определяется при помощи кодового слова defer.

```go
package main  
  
import "fmt"  
  
func main() {  
    defer fmt.Println("After work")  
    fmt.Println("Some useful work")  
}

// вывод
Some useful work
After work
// хоть defer и выше, но он выполнился в конце
```

Если же использовать несколько defer, то они будут вызваны в обратном порядке написания
```go
package main  
  
import "fmt"  
  
func main() {  
    defer fmt.Println("After work")  
    defer fmt.Println("After work 2")  
}
// вывод
// After work 2
// After work
```

Интересно работают параметры в таких функциях. Аргументы когда передаются в функции при передаче **вычисляются при объявлении отложенной функции**

```go
package main  
  
import "fmt"  
  
func getSomeVars() string {  
    fmt.Println("getSomeVard execution")  
    return "getSomeVars result"  
}  
  
  
func main() {  
    defer fmt.Println(getSomeVars())  
    defer fmt.Println("After work")  
}

// вывод
//getSomeVard execution
//After work
//getSomeVars result
```

Из вывода видно, что сначала напечаталась фраза из getSomeVars, далее по after work (выполнение отложенных функций идёт в обратном порядке от написанного) и вывод функции getSomeVars в конце.
На деле не всегда удобно. Лучше воспользоваться анонимной функцией
```go
package main  
  
import "fmt"  
  
func getSomeVars() string {  
    fmt.Println("getSomeVard execution")  
    return "getSomeVars result"  
}  
  
  
func main() {  
    defer fmt.Println(getSomeVars())  
    defer func() {  
       fmt.Println(getSomeVars())  
    }()  
}
```

Такие конструкции очень удобны при восстановлении после паники

Паника - служебная функция, которая останавливает выполнение работы программы. Также может возникнуть если компилятор не увидел ошибку.

Панику можно вызвать самому
```go
package main  
  
import "fmt"  
  
func deferTest() {  
    fmt.Println("Hello World")  
    panic("something bad happened")  
    return  
}  
  
func main() {  
    deferTest()  
    return  
}
//panic: something bad happened

//goroutine 1 [running]:
//main.deferTest(...)
//	/home/user/GolandProjects/test_go/main.go:4
//main.main()
//	/home/user/GolandProjects/test_go/main.go:9 +0x25

//Process finished with the exit code 2
```

Паника - абсолютно исключительная ситуация, которую нужно отлавливать и обрабатывать.
И лучше использовать defer для обработки паники. Для этого есть функция recover, которая возвращает ошибку, брошенную паникой.

```go
package main  
  
import "fmt"  
  
func deferTest() {  
    defer func () {  
       if err := recover(); err != nil {  
          fmt.Println("in happend")  
       }  
    }()  
    panic("something bad happened")  
    return  
}  
  
func main() {  
    deferTest()  
    return  
}

// in panic
```

Теперь функция обработалась и паники нет. 
**ВАЖНО**
	Не стоит использовать панику как try/except. Она для этого не предназначена. Паника - исключительная ситуация которая приведёт к краху программы. Она ловится для того, чтобы другие запросы не затронулись.

Иногда бывает и такое, что в defer мы тоже можем поймать панику. И его может поймать другой defer. Однако это плохая практика и так лучше не делать.

```go
package main  
  
import "fmt"  
  
func deferTest() {  
    defer func () {  
       if err := recover(); err != nil {  
          fmt.Println("in panic 1")  
          panic(2)  
       }  
    }()  
    defer func () {  
       if err := recover(); err != nil {  
          fmt.Println("in panic 2")  
       }  
    }()  
    panic("something bad happened")  
    return  
}  
  
func main() {  
    deferTest()  
    return  
}
```