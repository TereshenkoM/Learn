**1. int** - целые числа. Зависит от разрядности системы (32/64)
```go
//int - платформозависимый тип, 32/64 разрядная система  
var i int = 10
```

Может быть выбран автоматически
```go
// автоматически выбранный int  
var autoInt = -1
```

Для более точного контроля int8, int16, int32, int64
```go
// Для более точного контроля int8, int16, int32, int64  
var bigInt int64 = 1 << 32 - 1
```

Также есть беззнаковые int - **uint**. То есть хранит только положительные числа.
```go
// платформазависмый тип (32/64) только для чисел больше нуля  
var unsignedInt uint = 100500
```

По аналогии с int для большего контроля
```go
// uint8, uint16, uint32, uint64  
var unsignedBigInt uint64 = 1<<64 - 1
```

**Примечание**
Символ `<<`- битовый сдвиг. То есть запись `1<<n` - сдвинуть число 1 на n битов.То есть это то же самое, что 2^n.
`1 << 3` = `8` (побитово это `0001 << 3` = `1000`).  
`1 << 64` = 2^64


**2. float** - числа с плавающей точкой.

Представлены как числа одинарной точности - **float32**, для двойной - **float64**. Также есть значение по умолчанию (это 0) и также автоподстановка типа.
```go
//float32, float64  
var pi float32 = 3.141  
var e = 2.719  
goldenRatio := 1.618
```

**Примечание**
float32 (одинарная точность)
- Занимает **32 бита** (4 байта).
- Состоит из трёх частей:
    - **1 бит** — знак числа (0 = +, 1 = -).
    - **8 бит** — порядок (exponent).
    - **23 бита** — мантисса (fraction, дробная часть).
Итоговая точность — примерно **6–7 десятичных знаков**.  
Диапазон: от `≈1.18e−38` до `≈3.4e+38`.

float64 (двойная точность)
- Занимает **64 бита** (8 байт).
- Состоит из:
    - **1 бит** — знак.
    - **11 бит** — порядок.
    - **52 бита** — мантисса.
Итоговая точность — примерно **15–16 десятичных знаков**.  
Диапазон: от `≈2.23e−308` до `≈1.8e+308`.


**3. bool** - булевый тип данных. Значение по умолчанию - 0, также может подставляться автоматически.
```go
v// bool  
// false по-умолчанию  
var b bool  
var isOk bool = true  
var success = true  
cond := true  
  
fmt.Println(b, isOk, success, cond)
```

**4. complex** - комплексные переменные. Используется крайне редко, но есть целый набор методов встроенный в go для работы с ними
```go
//complex64, complex128  
var c complex128 = -1.1 + 7.12i  
c2 := -1.1 + 7.12i  
  
fmt.Println(c, c2)
```

**5. string** - строки. По умолчанию пустая строка и объявляется в пустых кавычках.
```go
// пустая строка по-умолчанию  
var str string
```

Может содержать спец. символы
```go
// со спец символами  
var hello string = "Привет\n\t"
```

Если спец. символы нужны только как элементы строки, то можно использовать обратные кавычки (как ниже)
```go  
// без спец символов  
var world string = `Мир\n\t
```

Строки в go поддерживают конкатенацию. Однако строки - неизменяемые
```go
helloWord := "Привет мир"  
// конкатенация  
andGoodMorning := helloWord + " и доброе утро"
```

**В дополнении к строкам**
Для байт используются одинарные кавычки
```go
// одинакрные кавычки для байт (uint8)  
var rawBinary byte = '\x27'
```

Получая длину строки при помощи len - мы получаем её в байтах.
```go
// 19 байт  
byteLen := len(helloWord)
```

Для получения количества символов нужно использовать функцию из пакета utf8 - RuneCountInString
```go
// 10 символов  
symbols := utf8.RuneCountInString(helloWord)
```

Также мы можем получить подстроку при помощи среза или при помощи индекса. **Подстроку мы получаем в байтах, не в символах**
```go
// получение строки в байтах, не в символах!  
hello := helloWord[:12]  
H := helloWord[0]
```

Это можно конвертировать в строку и обратно
```go
// конвертация в слайс и обратно  
byteString = []byte(helloWorld)  
helloWorld = string(byteString)
```

**Примечание**
Из коробки поддерживают UTF-8, можно писать на любых алфавитов.

Общий листинг по базовым типам
```go
package main  
  
import (  
    "fmt"  
    "unicode/utf8")  
  
func main() {  
    //int - платформозависимый тип, 32/64 разрядная система  
    var i int = 10  
  
    // автоматически выбранный int  
    var autoInt = -1  
  
    // Для более точного контроля int8, int16, int32, int64  
    var bigInt int64 = 1 << 32 - 1  
  
    // платформазависмый тип (32/64) только для чисел больше нуля  
    var unsignedInt uint = 100500  
  
    // uint8, uint16, uint32, uint64  
    var unsignedBigInt uint64 = 1<<64 - 1  
  
    fmt.Println(i, autoInt, bigInt, unsignedInt, unsignedBigInt)  
  
    //float32, float64  
    var pi float32 = 3.141  
    var e = 2.719  
    goldenRatio := 1.618  
  
    fmt.Println(pi, e, goldenRatio)  
  
    // bool  
    // false по-умолчанию    var b bool  
    var isOk bool = true  
    var success = true  
    cond := true  
  
    fmt.Println(b, isOk, success, cond)  
  
    //complex64, complex128  
    var c complex128 = -1.1 + 7.12i  
    c2 := -1.1 + 7.12i  
  
    fmt.Println(c, c2)  
  
    //пустая строка по-умолчанию  
    var str string  
  
    // со спец символами  
    var hello string = "Привет\n\t"  
  
    // без спец символов  
    var world string = `Мир\n\t`  
  
    // одинакрные кавычки для байт (uint8)  
    var rawBinary byte = '\x27'  
  
    helloWorld := "Привет мир"  
    //конкатенация  
    andGoodMorning := helloWorld + " и доброе утро"  
  
    //19 байт  
    byteLen := len(helloWorld)  
    // 10 символов  
    symbols := utf8.RuneCountInString(helloWorld)
    
    //получение строки в байтах, не в символах!  
	hello := helloWorld[:12]  
	H := helloWorld[0]  
	  
	// конвертация в слайс и обратно  
	byteString := []byte(helloWorld)  
	helloWorld = string(byteString)
    
}
```

**6. Определение типа** - в go мы можем сами создавать типы основываясь на базовых примитивах, либо используя структуры (о них позже). Удобно определять при моделировании сущностей. **При этом автоматического приведения типов в go нет**
Чтобы привести переменную базового типа к другому, то нужно делать конвертацию.

```go
package main  
  
import "fmt"  
  
type UserId int  
  
func main() {  
    idx := 1  
    var uid UserId = 42  
  
    myID := UserId(idx)  
    fmt.Println(uid, myID)  
}
```

**7. Указатели** Указатель — это такая переменная, которая **не хранит само значение**, а **хранит адрес ячейки памяти, где это значение лежит**. В go - это отдельный тип данных. Как таковой в go нет адресной арифметики, к указателю мы не можем добавить какое-то значение.

Если мы объявляем переменную как указатель на другую, то в ней будет лежать значение адреса на другую переменную (то есть это не полноценная ссылка, которая указывает ровно туда же, куда и основная переменная).

```go
package main  
  
  
  
func main() {  
    a := 2  
    b := &a // указатель на a  
    *b = 3 // внутри а изменилось значение. a = 3  
    c  := &a // новый указатель на переменную а  
  
  
    // получение указателя на переменную типа int    
    d := new(int) // указатель на тип данных. инициализировано значением по-умолчанию
    *d = 12 // присваиваем значение 
    *c = *d // c = 12 -> a = 12  
    *d = 13 // c и а не изменились. потому что с указывает на a
  
    c = d  // теперь в с такой же указатель как на d
    *c = 14 // c = 14 -> d = 14, a = 12  
}
```

**8. Массив** - набор из данных одного типа. Особенностью является то, что размерность часть типа данных. То есть массив размерностью 2 и массив размерностью 3 - разные типы данных и не совместимы. Задаётся при компиляции и не может быть изменена динамически. Довольно низкоуровневый и используется не часто
```go
//размер массива - часть его типа  
//инициализация со значениями по умолчанию  
var a1 [3]int //[0,0,0]
```

Также для определения размера можно использовать константы, но не переменные
```go
const size = 2  
var a2 [2 * size]bool //[false,false,false,false]  
fmt.Println("a2", a2)
```

Можно определить размер при инициализации
```go
a3 := [...]int{1, 2, 3}
```

**9. Слайс** - чуть более сложная структура основанная на массиве. У слайса есть длина (len) (кол-во элементов в нём) и capacity - то количество элементов, которое в него влезет без аллоцирования его памяти

Примеры создания
```go
// создание слайса  
var buf0 []int //len=0 cap=0  
buf1 := []int{} //len=0 cap=0  
buf2 := []int{42} //len=1, cap=1  
// гораздо чаще используется make которая создаёт слайс нужного len и cap  
buf3 := make([]int, 0) //len=0 cap=0  
buf4 := make([]int, 5) //len=5 cap5  
buf5 := make([]int, 5, 10) //len=5 cap=10
```

Обращаться к элементам можно также по индексу
```go
someInt := buf5[1]
```

Для добавления элементов в слайс есть функция append. 
```go
//добавление элементов  
var buf []int  
buf = append(buf,9, 10) // len=2 cap=2  
buf = append(buf, 11) // len=3 cap=4
```
**Важно** при увеличении capacity runtime делает x2 от текущего размера, поэтому capacity в последней строке - 4.

Если же нужно объединить слайсы в append используется ...
```go
otherBuf := make([]int, 3) //[0,0,0]  
buf = append(buf, otherBuf...) //len=6, cap=8
```

Для информации о слайсе используется
```go
// просмотр данных о слайсе  
var bufLen, bufCap int = len(buf), len(buf)  
fmt.Println(bufLen, bufCap)
```

Также мы можем взять кусок слайса, который будет ссылаться на ту же область памяти, что и оригинальный слайс
```go
buf := []int{1,2,3,4,5}  
fmt.Println(buf)  
  
  
// получение среза, указывающего на ту же память  
sl1 := buf[1:4] // [2,3,4]  
sl2 := buf[:2] // [1,2]  
sl3 := buf[2:] // [3,4,5]  
fmt.Println(sl1, sl2, sl3)  
  
newBuf := buf[:] // [1,2,3,4,5]  
newBuf[0] = 9  
// buf = [9, 2, 3, 4, 5], т.к. та же память
```

Однако, если добавить значение, то слайс будет указывать на другие данные. Так как он расширится у будет указывать на другую область памяти.
```go
newBuf = append(newBuf, 6)  
fmt.Println(newBuf)  
//buf = [9, 2, 3, 4, 5] - не изменился  
//newBuf = [9, 2, 3, 4, 5, 6] - изменился
```

Иногда нужно скопировать слайс (то есть не создавать область в памяти)
```go
// копирование одного слайса в другой  
var emptyBuf []int //len=0, cap=0  
//неправильно - скопирует меньшее (по len) из 2-х слайсов  
//копирует то, что указывает переменная len  
copied := copy(emptyBuf, newBuf) // copied = 0  
fmt.Println(copied, emptyBuf)  
  
// правильно  
newBuf = make([]int, len(buf), len(buf))  
copy(newBuf, buf)  
fmt.Println(newBuf)
```

Также можно копировать часть существующего слайса
```go
// можно копировать в часть существующего слайса  
ints := []int{1,2,3,4,5}  
copy(ints[1:3], []int{5,6}) // ints = [1,5,6,4]  
fmt.Println(ints)
```

**9. map** - хеш-таблица. Позволяет по ключу получить значение.

При инициализации указывается тип ключа, а за ним тип данных. В качестве ключа может использоваться любое сравниваемое значение (то есть может использоваться с оператором `==/!=`)
```go
// инициалзиация при создании  
var user map[string]string = map[string]string{  
    "name": "Vasiliy",  
    "lastName": "Romanov",  
}
```

Также можно сразу задать ёмкость чтобы не увеличивать в рантайме
```go
// сразу с нужной ёмкостью  
profile := make(map[string]string, 10)
```

Количество элементов также получается при помощи len
```go
// количество элементов  
mapLength := len(user)
```

Обращение к элементу через квадратные скобки. Если ключа нет - вернёт значение по умолчанию для типа 
```go
// если ключа нет - вернёт значение по умолчанию для типа  
mName := user["middleName"]  
fmt.Println(mName)
```

Тип можно проверить на существование ключа
```go
// проверка на существование ключа  
mName, mNameExist := user["middleName"]
```

Также можно проверить только существование без получения ключа
```go
// проверка на существование ключа без самого получения ключа  
_, mNameExist2 := user["middleName"]
```

Сам ключ можно удалить. Указывает саму мапу и ключ
```go
// удаление ключа  
delete(user, "lastName")
```