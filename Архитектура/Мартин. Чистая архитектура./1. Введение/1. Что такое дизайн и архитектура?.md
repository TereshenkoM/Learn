За долгие годы вокруг понятий "дизайн" и "архитектура" накопилось много путаницы. Что такое дизайн? Что такое архитектура? Чем они отличаются?

Прежде всего автор утверждает, что разницы между этими понятиями **нет вообще никакой**.

Низкоуровневые детали и высокоуровневая структура являются частями одного целого. Они образуют сплошное полотно, определяющее форму системы. Одно без другого невозможно; нет никакой чёткой линии, которая разделяла бы их. Есть просто совокупность решений разного уровня детализации.

**Цель?**

**В чём состоит цель таких решений? Главная цель архитектуры программного обеспечения - уменьшить человеческие трудозатраты на создание и сопровождение системы.**

Мерой качества дизайна является простая мера трудозатрат. Если трудозатраты невелики и остаются небольшими в течение эксплуатации системы, система имеет хороший дизайн. Если трудозатраты увеличиваются с выходом каждой новой версии, система имеет плохой дизайн. 

## Пример из  практики

В качестве примера рассмотрим результаты исследования из практики. Они основаны на реальных данных, предоставленных реальной компанией.

Сначала рассмотрим графики

1. График роста инженерно-технического персонала
![[Pasted image 20251015235753.png]]

2. График продуктивности компании за тот же период, измеряемой в количестве строк кода. Уже кажется, что что-то не так. Даже при том, что выпуск каждой версии поддерживается всё большим количеством разработчиков.
![[Pasted image 20251015235833.png]]

3. Самый страшный график. Рост стоимости строчки кода.
![[Pasted image 20251016000009.png]]

Подобная тенденция говорит о нежизнеспособности. Какой бы рентабельной ни была компания, в настоящее время растущие расходы поглотят прибыль и приведут к застою и краху.


## Причины неприятностей

Когда системы создаются второпях, когда увеличение штата программистов - единственный способ продолжать выпускать новые версии и когда чистоте кода или дизайну уделяется минимум внимания или не уделяется вообще, то тогда такая тенденция приведёт к краху.

Как выглядит эта тенденция применительно к продуктивности разработчиков. Сначала разработчики показывают продуктивность близкую к 100%, но с выходом каждой версии она падает. Начиная с четвёртой версии, как нетрудно заметить, их продуктивность приближается к нижнему пределу - к нулю.
![[Pasted image 20251016000522.png]]

С точки зрения разработчиков, такая ситуация выглядит очень удручающе. потому что они продолжают трудиться с полной отдачей сил. Никто не отлынивает от работы. Однако все их усилия направлены на борьбу с беспорядком, а не на реализацию новых функций.

## Точка зрения руководства

Ещё более страшный график. График изменения месячного фонда оплаты труда разработчиков за тот же период

![[Pasted image 20251016000902.png]]

Этот график пугает. Очевидно происходит что-то страшное. Одна надежда, что рост доходов опережает рост затрат, а значит оправдывает расходы..


## Что не так?

Многие современные разработчики много работают и часть их мозга, которая знает что хороший, чистый, грамотно проработанный код играет огромную роль - спит.

Разработчики верят в известную ложь **"Мы сможем навести порядок потом"**.
В результате порядок так и не наводится, потому что давление конкуренции на рынке никогда не ослабевает. Поэтому режим работы никогда не переключается. Им нужно реализовывать всё новый функционал и на наведение порядка просто не остаётся времени. Как следствие, продуктивность стремится к своему пределу около нуля.

**Дело в том, что создание беспорядка всегда оказывается медленней, чем неуклонное соблюдение чистоты, независимо от выбранного масштаба времени.**

Рассмотри график эксперимента, проводившегося в течении 6 дней. Каждый день разработчик писал простую программу по переводу целых чисел в десятичной системе в римскую. Работа считалось завершённой, когда проходил ряд тестов.
![[Pasted image 20251016002121.png]]

В 1, 2 и 3 день использовалась хорошо известная методика разработки через тестирование TDD (Test Driven Development). В остальные дни он писал код, не ограничивая себя рамками этой методики.

Каждый день на решение задачи затрачивалось меньше времени. Также при решении задачи по TDD время сокращалось примерно на 10% (относительно методики) без применения TDD.

**Единственный способ обратить снижение продуктивности - это нести ответственность за беспорядок в коде!**

Можно подумать, что проблему можно исправить, если перепроектировать систему. Однако в действительности всё не так радужно.

**Самонадеянность, управляющая перепроектированием, приведёт к тому же беспорядку, что и прежде**

## Заключение

Лучше всегда избегать самонадеянности и с самого начала серьёзно отнестись к качеству архитектуры продукта. Серьезное отношение к архитектуре программного обеспечения подразумеает знание о том, что такое хорошая архитектура. Чтобы создать систему,дизайн и архитектура которой способствуют уменьшению трудозатрат и увеличению продуктивности, нужно знать, какие элементы архитектуры ведут к этому.
