Как мы увидим далее, для создания хорошей архитектуры необходимо понимать и уметь применять принципы ООП. Но что такое ООП?

Один из возможных ответов - это комбинация данных и функций. Несмотря на частое цитирование, этот ответ нельзя признавать точным, потому что он предполагает, что o.f() - это нечто отличное от f(o). Это абсурд.

Другой популярный ответ - способ моделирования реального мира. Это слишком уклончивый ответ. Возможно эта фраза подразумевает, что ООП делает ПО проще для понимания, потому что оно становится ближе к реальному миру, но и такое объяснение слишком размыто и уклончиво. Оно не отвечает на этот вопрос.

Некоторые пытаясь объяснить природу ООП прибегают к трём волшебным словам: инкапсуляция, наследование, полиморфизм. Они подразумевают, что ООП является комплексом из 3 понятий или, по крайней мере, что ОО язык должен из поддерживать. 

Исследуем эти понятия
**Инкапсуляция**

Упоминается как часть определения ООП потому, что языки ОО поддерживают простой и эффективный способ инкапсуляции данных и функций. **Как результат, есть возможность очертить круг связанных данных и функций. За пределами круга эти данные невидимы и доступны только некоторые функции**. Воплощение этого понятия можно наблюдать в виде приватных членов данных и общедоступных членов-функций класса.

Пример на C (автор утверждает, что на С имеется превосходная поддержка инкапсуляции)
```c
// point.h
struct Point;
struct Point* makePoint (double x, double y);
double distance (struct Point *p1, struct Point *p2);
```

```c
#include "point.h"
#include <stdlib.h>
#include <math.h>
struct Point { 
	double x,y; 
};
struct Point* makepoint(double x, double y) { 
	struct Point* p = malloc(sizeof(struct Point));
	p->x = x;
	p->y = y;
	return p; 
} 
double distance(struct Point* p1, struct Point* p2) { 
	double dx = p1->x - p2->x;
	double dy = p1->y - p2->y;
	return sqrt(dx*dx+dy*dy);
}
```

**Примечание**
В языке **C** файлы с расширением **`.h`** называются **заголовочными файлами (header files)**.  
Они содержат **объявления** (но не определения) функций, структур, констант и т. д.

Пользователи point.h  не имеют доступа к членам структуры Point. Они могут вызывать функции makePoint() и distance(), но не имеют никакого представления о реализации структуры Point и функций  для работы с ней.

Мы можем объявить структуры данных и функции в заголовочных файлах и реализовать их в файлах реализации. И наши пользователи никогда не получат доступа к элементам в этих файлах реализации.

Однако с приходом c++ прекрасная инкапсуляция в c была разрушена. По техническим причинам компилятор в c++ требует определять переменные-члены класса в заголовочном файле. В результате имеем такой вид.
```c++
class Point {
public: 
	Point(double x, double y);
	double distance(const Point& p) const; 
	private: 
		double x;
		double y;
};
```

```c++
#include "point.h"
#include <math.h>

Point::Point(double x, double y) 
: x(x), y(y) 
{}

double Point::distance(const Point& p) const {
	double dx = x-p.x;
	double dy = y-p.y;
	return sqrt(dx*dx + dy*dy);
}
```

Теперь пользователи заголовочного файла point.h знают о переменных-членах x и y. Компилятор позволяет им обратиться к ним непосредственно, но клиент всё равно знает об их существовании. Инкапсуляция разрушена!

Введением в язык ключевых слов public, private и protected инкапсуляция была частично восстановлена. Однако это хак, обусловленный тех. необходимостью. По описанным причинам трудно согласиться, что ООП зависит от строгой инкапсуляции. В действительности многие ООП языки практически не имеют принудительной инкапсуляции (Python, JS, Lua, Ruby).

ООП безусловно полагается на поведение программистов - что они не станут использовать обходные приёмы для работы с инкапсулированными данными. То есть языки, заявляющие о поддержке ООП, фактически ослабили превосходную инкапсуляцию, некогда существовавшую в C.


## Наследование
Языки ООП не улучшили инкапсуляцию, зато дали нам следование. Точнее её разновидность. По сути наследование - это всего лишь повторное объявление группы переменных и функций в ограниченной области видимости. Нечто похожее программисты на C делали вручную ещё до появления языков ООП.

```c
// namedPoint.h 
struct NamedPoint;
struct NamedPoint* makeNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np); 

//namedPoint.c 
#include "namedPoint.h"
#include <stdlib.h>
struct NamedPoint {
	double x,y;
	char* name;
};
struct NamedPoint* makeNamedPoint(double x, double y, char* name) {
	struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
	p->x = x;
	p->y = y;
	p->name = name; return p;
} 

void setName(struct NamedPoint* np, char* name) { 
	np->name = name;
} 

char* getName(struct NamedPoint* np) {
	return np->name;
} 
//main.c 
#include "point.h"
#include "namedPoint.h"
#include <stdio.h>
int main(int ac, char** av) { 
	struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");
	struct NamedPoint* upperRight = makeNamedPoint (1.0, 1.0, "upperRight"); 
	printf("distance=%f\n",
	distance( 
		(struct Point*) origin,
		(struct Point*) upperRight)); 
}
```

То есть можно сказать, что некоторая разновидность наследования у нас имелась задолго до появления языков ООП. Впрочем, это утверждение не совсем истинно. У нас имелся трюк, хитрость, не настолько удобный, как настоящее наследование. Кроме того, с помощью описанного приёма очень сложно получить что-то похожее на множественное наследование.

Справедливости ради следует отметить, что языки ООП действительно сделали маскировку структур данных более удобной, хотя это и не совсем новая особенность.

Итак, мы не можем дать идее ООП ни одного очка за инкапсуляцию и можем дать лишь пол-очка за наследование. Пока что общий счёт не впечатляет.

Но у нас есть ещё одно понятие.

### Полиморфизм
**Полиморфизм** — это способность одного и того же интерфейса (метода, функции, переменной)  **работать с объектами разных типов** и **вести себя по-разному** в зависимости от контекста.

