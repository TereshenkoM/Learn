Принцип открытости/закрытости (Open-Closed Principle; OCP) гласит:
```
Программные сущности должны быть открыты для расширения и закрыты для изменения
```

Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения.

### Мысленный эксперимент
Представим, что у нас есть финансовая сводка. Содержимое страницы прокручивается и отрицательные значения выделяются красным цветом.

Теперь представим, что нас попросили представить ту же информацию в печатном виде, отчёт должен быть разбит на страницы, включать верхний и нижний колонтитул, отрицательные значения должны быть в круглых скобках. Очевидно, что для этого придётся писать новый код. Но как много старого кода придётся изменить?

В ПО с хорошо проработанной архитектурой таких изменений должно быть немного. В идеале их вообще не должно быть. Как? Правильно разделяя сущности, которые изменяются по разным причинам (принцип единой ответственности) и затем правильно организуя зависимости между этими сущностями (принцип инверсии зависимостей).

Применяя принцип единственной ответственности, можно прийти к потоку данных, изображённому на рисунке ниже.
![[Pasted image 20251111122932.png]]

**Самое важное, что нужно понять - в данном примере в создании отчёта вовлечены две отдельные ответственности: вычисление данных для отчёта и представление этих данных в форме веб-отчёта или распечатанного отчёта**

Сделав такое разделение, мы должны организовать зависимости в исходном коде так, чтобы изменения в одной из ответственности не вызывали необходимости изменений в другой. Кроме того, **новая организация должна гарантировать возможность расширения поведения без отмены изменений.**

Этого можно добиться выделив процессы в классы, а классы в компоненты, ограниченные двойными линиями (как на рисунке ниже)

![[Pasted image 20251111173456.png]]
**Примечание**
	Интерактор - компонент, содержащий бизнес-логику. 
	Стрелка направленная от класса А к классу В, означает, что в исходном классе А упоминается имя класса В но в коде класса B не упоминается имя класса А.

Классы помечены символами `<I>` - это интерфейсы. Символом `<DS>` - структуры данных. Простые стрелки соответствуют отношениями использования. Стрелки с треугольным наконечником соответствуют отношениям реализации или наследования.

Стоит заметить, что двойная линия пересекается только в одном направлении. Это означает, что все отношения компонентов однонаправлены, как показано на рисунке ниже. **Эти стрелки указывают на компоненты, которые мы хотим защитить**

![[Pasted image 20251111174128.png]]

Нам важно защитить контроллер от презентатора. Нам важно защитить презентаторы от представлений. Нам нужно защитить интерактор от изменений **во всех остальных компонетах**

Интерактор находится в позиции, лучше соответствующей принципу открытости/закрытости. Изменения в БД или в контроллере, или в презентаторах, или в представлениях не должны влиять на интерактор. **Интерактор решает самую важную задачу**.

Обратите внимание, что в результате выстраивается иерархия защиты, основанная на понятии "уровня". Интеракторы занимают самый верхний уровень, поэтому они должны быть самыми защищёнными. Представления занимают самый низкий уровень, поэтому они наименее защищены. Презентаторы находятся уровнем выше представлений, но ниже контроллера или интерактора.

**Компоненты такой иерархии защищаются от изменений в компонентах на нижних уровнях**

### Заключение
Принцип открытости/закрытости - одна из движущих сил в архитектуре систем. Его цель - сделать систему легко расширяемой и обезопасить её от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений уровнем выше.