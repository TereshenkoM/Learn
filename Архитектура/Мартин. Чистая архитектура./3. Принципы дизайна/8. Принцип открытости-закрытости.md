Принцип открытости/закрытости (Open-Closed Principle; OCP) гласит:
```
Программные сущности должны быть открыты для расширения и закрыты для изменения
```

Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения.

### Мысленный эксперимент
Представим, что у нас есть финансовая сводка. Содержимое страницы прокручивается и отрицательные значения выделяются красным цветом.

Теперь представим, что нас попросили представить ту же информацию в печатном виде, отчёт должен быть разбит на страницы, включать верхний и нижний колонтитул, отрицательные значения должны быть в круглых скобках. Очевидно, что для этого придётся писать новый код. Но как много старого кода придётся изменить?

В ПО с хорошо проработанной архитектурой таких изменений должно быть немного. В идеале их вообще не должно быть. Как? Правильно разделяя сущности, которые изменяются по разным причинам (принцип единой ответственности) и затем правильно организуя зависимости между этими сущностями (принцип инверсии зависимостей).

Применяя принцип единственной ответственности, можно прийти к потоку данных, изображённому на рисунке ниже.
![[Pasted image 20251111122932.png]]

**Самое важное, что нужно понять - в данном примере в создании отчёта вовлечены две отдельные ответственности: вычисление данных для отчёта и представление этих данных в форме веб-отчёта или распечатанного отчёта**

Сделав такое разделение, мы должны организовать зависимости в исходном коде так, чтобы изменения в одной из ответственности не вызывали необходимости изменений в другой. Кроме того, **новая организация должна гарантировать возможность расширения поведения без отмены изменений.**

Этого можно добиться выделив процессы в классы, а классы в компоненты, ограниченные двойными линиями (как на рисунке ниже)

![[Pasted image 20251111173456.png]]
**Примечание**
	Интерактор - компонент, содержащий бизнес-логику. Стрелка направленная от класса А к классу В, означает, что в исходном классе А упоминается имя класса В но в коде класса B не упоминается имя класса А.

Классы помечены символами `<I>` - это интерфейсы. Символом `<DS>` - структуры данных. Простые стрелки соответствуют отношениями использования. Стрелки с треугольным наконечником соответствуют отношениям реализации или наследования.

Стоит заметить, что двойная линия пересекается только в одном направлении. Это означает, что все отношения компонентов однонаправлены, как показано на рисунке ниже.

![[Pasted image 20251111174128.png]]



