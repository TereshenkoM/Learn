Принцип инверсии зависимостей утверждает, что наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.

В языках со статической типизацией это означает, что инструкции use, import и include должны ссылаться только на модули с исходным кодом, содержащим интерфейсы, абстрактные классы и другие абстрактные объявления. Никаких зависимостей от конкретных реализаций быть не должно.

То же правило действует для языков с динамической типизацией. Исходный код не должен зависеть от модулей с конкретной реализацией. Однако в этих языках труднее определитьm что такое конкретный модуль. В частности, это любой модуль, в котором реализованы вызываемые функции.

Мы должны избегать зависимости от неустойчивых конкретных элементов системы. То есть от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.

### Стабильные абстракции
Каждое изменение абстрактного интерфейса вызывает изменения его конкретной реализации. Изменение конкретной реализации, напротив, не всегда сопровождается изменениями и даже обычно не требует изменений в соответствующих интерфейсах. То есть интерфейсы менее изменчивы, чем реализации.

Как следствие, стабильными называются такие архитектуры, в которых вместо зависимостей от переменчивых конкретных реализаций используются зависимости от стабильных абстрактных интерфейсов. Это следствие сводится к набору очень простых правил:
* **Не ссылайтесь на изменчивые конкретные классы**
	Ссылайтесь на абстрактные интерфейсы. Это правило применимо во всех языках, независимо от устройства системы типов. Оно также накладывает важные ограничения на создание объектов и определяет преимущественное использование шаблона "Абстрактная фабрика"

* **Не наследуйте изменчивые конкретные классы**
	Это естественное следствие из предыдущего правила. Наследование в языках со статической системой типов является самым строгим и жёстким видом отношений в исходном коде; следовательно, его следует использовать с большой осторожностью. Наследование в языках с динамической системой типов влечёт меньшее количество проблем, но все ещё остаётся зависимостью, поэтому дополнительная предосторожность никогда не помешает.

* Не переопределяйте конкретные функции
	Конкретные функции часто требуют зависимостей в исходном коде. Переопределяя такие функции вы не устраняете эти зависимости - фактически вы наследуете их. Для управления подобными зависимостями нужно сделать функцию абстрактной и создавать несколько её реализаций

 * Никогда не ссылайтесь на имена конкретных и изменчивых сущностей
	 В действительности это всего лишь перефразированная форма самого принципа.


### Фабрики
Чтобы соблюдать все эти правила, необходимо предусмотреть особый способ создания изменчивых объектах. Это объясняется тем, что практически во всех языках создание объектов связано с образованием зависимостей на уровне исходного кода от конкретных определений этих объектов. Для управления подобными нежелательными зависимостями можно использовать шаблон "Абстрактная фабрика".

Рисунок ниже демонстрирует работы такой схемы. Приложение Application использует конкретную реализацию ConcreteImpl через интерфейс Service. Однако приложению требуется каким-то образом создавать экземпляры ConcreteImpl. Чтобы решить эту задачу без образования зависимости от ConcreteImpl на уровне исходного кода, приложение вызывает метод makeSvc интерфейса фабрики ServiceFactory. Этот метод реализован в классе ServiceFactoryImpl, наследующим ServiceFactory. Эта реализация создаёт экземпляр ConcreteImpl и возвращает его как экземпляр интерфейса Service.

![[Pasted image 20251111223608.png]]

Извилистая кривая обозначает архитектурную границу. Она отделяет абстракцию от конкретной реализации. Все зависимости в исходном коде пересекают эту границу в одном направлении - в сторону абстракции. Извилистая линия делит систему на два компонента: абстрактный и конкретный. Абстрактный - содержит все высокоуровневые бизнес-правила приложения. Конкретный компонент содержит детали реализации этих правил.

**ПОТОК УПРАВЛЕНИЯ ПЕРЕСЕКАЕТ ИЗВИЛИСТУЮ ЛИНИЮ В НАПРАВЛЕНИИ, ОБРАТНОМ НАПРАВЛЕНИЮ ЗАВИСИМОСТЕЙ В ИСХОДНОМ КОДЕ.  ЗАВИСИМОСТИ СЛЕДУЮТ В НАПРАВЛЕНИИ, ПРОТИВОПОЛОЖНОМ НАПРАВЛЕНИЮ ПОТОКА УПРАВЛЕНИЯ **

**Именно поэтому принцип получил название принципа инверсии зависимостей**

### Конкретные компоненты
Конкретный компонент ConcreteImpl на рисунке выше имеет единственную зависимость, то есть нарушает принцип DIP. Это нормально. Полностью устранить любые нарушения принципа инверсии зависимостей невозможно, но их можно сосредоточить в узком круге конкретных компонентов и изолировать от остальной системы.
Большинство систем будет содержать хотя бы один такой конкретный компонент - часто с именем main, потому что включает функцию main. В схеме, функция main могла бы создавать экземпляр ServiceFactoryImpl и сохранять ссылку на него в глобальной переменной типа ServiceFactory. Благодаря этому приложение Application сможет использовать данную глобальную переменную для обращения к фабрике.

### Заключение
Принцип инверсии зависимостей по мере продвижения вперёд будет самым заметным организационным принципом в наших архитектурных диаграммах. Извилистая линия (как на рисунке выше) часто будет обозначать архитектурные границы в последующих главах. Зависимости будут пересекать эту извилистую линию в одном направлении, в сторону более абстрактных сущностей, и это станет для нас новым правилом, которые мы будем называть правилом зависимостей.