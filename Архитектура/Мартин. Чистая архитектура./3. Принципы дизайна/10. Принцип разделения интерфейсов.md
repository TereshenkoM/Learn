Происхождение названия принципа разделения интерфейсов (Interface Segregation Pronciple) наглядно иллюстрирует схема ниже
![[Pasted image 20251111214446.png]]

В данной ситуации у нас есть несколько классов, пользующихся операциями в классе OPS. Допустим, что User1 использует только операцию op1, User2 - только op2, User3 - op3.

Теперь представьте, что класс OPS написан на Java. Очевидно, что в такой ситуации исходный код User1 непреднамеренно будет зависеть от op2 и op3, даже при том, что он не пользуется ими. Эта зависимость означает,, что изменения в исходном коде метода op2 в классе OPS потребуют повторной компиляции и развёртывания класса User1, несмотря на то что для него ничего не изменилось.

Решить это можно разбиением на интерфейсы (рисунок ниже)
![[Pasted image 20251111214737.png]]

То есть изменения в OPS, которые не касаются User1, не требуют повторной компиляции и развёртывания User1.


### Принцип разделения интерфейсов и язык
Очевидно, что описание выше в значительной степени зависит от типа языка. Языки со статическими типами, такие как Java, вынуждают создавать объявления, которые должны импортироваться и подключаться как-то иначе.

В языках с динамической типизацией (вроде Ruby и Python) подобные объявления отсутствуют в исходном коде - они определяются автоматически во время выполнения. То есть в исходном коде отсутствуют зависимости, вынуждающие выполнять повторную компиляцию и развёртывание. Это главная причина почему системы на языках программирования с динамической типизацией более гибкие и с меньшим количеством строгих связей.

**Этот факт ведёт к заключению, что принцип разделения интерфейсов является проблемой языка, а не архитектуры**


### Принцип разделения интерфейсов и архитектура
В общем случае опасно создавать зависимости от модулей, содержащих больше, чем требуется. Это справедливо не только в отношении зависимостей в исходном коде, которые могут вынуждать выполнять без необходимости повторную компиляцию и развёртывание, но также на более высоком уровне - уровне архитектуры.

Например:
Действия архитектора, работающего над системой S. Он пожелал включить в систему некоторый фреймворк F. Теперь представьте, что авторы F связали его поддержку с конкретной БД D. То есть S зависит от F, который зависит от D.
![[Pasted image 20251111215808.png]]

Теперь представьте, что D включает функции, которые не используются фреймвокром F и, соответственно, не используется S. Изменения в этих функциях внутри D могут вынудить повторно развернуть F и, соответственно, повторно развернуть S. Хуже того, ошибка в одной из таких функций внутри D может спровоцировать появление ошибок в F и S.

### Заключение
Из вышесказанного следует вывод: зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.
