
**Что такое TDD?**

**Test-Driven Development (TDD)** — это методология разработки, при которой код пишется **после** написания тестов. Основной принцип:**"Сначала тест, потом код"**

**Цикл TDD (Красный → Зелёный → Рефакторинг)**
1. **Красный** — Пишем **падающий тест** на новую функциональность.
2. **Зелёный** — Пишем **минимальный код**, чтобы тест прошёл.
3. **Рефакторинг** — Улучшаем код, сохраняя работоспособность.

**Почему TDD?**
**Преимущества**
* **Раннее выявление ошибок** — Тесты помогают сразу видеть проблемные места.  
*  **Уверенность при рефакторинге** — Тесты защищают от случайных изменений.  
* **Документация в тестах** — Тесты показывают, как должен работать код.

**Лучше всего подходит для:**
- **чётко определённых задач** — API, бизнес-логика;
- **исправления багов** — сначала тест, потом фикс.

**Когда TDD не всегда подходит?**
- **Прототипирование** — Когда нужно быстро проверить идею;
- **UI-разработка** — Тестирование интерфейсов сложнее;
- **сложные интеграции** — Иногда проще написать код, а потом покрыть тестами.
    

**Классический подход vs TDD**
-  **Подход без тестов:** `Получили задачу -> пишем код → ждем, когда придет злой менеджер`
- **Обычный подход:** `Получили задачу → пишем код → покрываем тестами → Успех*`
- **TDD-подход:** `Получили задачу → пишем тесты →пишем код → рефакторим → Успех*`


## Пример. Где TDD реально помогает?

**Исправление багов**
Когда получаю задачу на исправление ошибки:
1. **Сначала пишу тест**, который воспроизводит баг.
2. **Запускаю тест** — он падает (как и должно быть).
3. **Исправляю код** и проверяю, что тест теперь проходит.

**Данный подход помогает "гвоздями" приколачивать бизнес-логику и гарантирует, что данный сценарий(кэйс) задокументирован и не воспроизведется в будущем.**

Вернемся к нашей функции. К нам пришел злой менеджер с задачей исправить баг: "Починить падение при отсутствии переданного элемента в строке". Не погружаясь в проблему в коде начинаем писать тест, который воспроизведет сценарий, описанный в задаче.

**test_example.py**

```python
import pytest
from src.example import find_elem_index



class TestFindElemIndex:
    """Тесты функции find_elem_index с применением AAA подхода"""

    TEST_TEXT = "abcdef"

    def test_find_existing_element(self):
        """Нахождение существующего элемента"""
        # Arrange
        search_element = "c"
        expected_index = 2
        # Act
        result = find_elem_index(self.TEST_TEXT, search_element)
        # Assert
        assert result == expected_index


    @pytest.mark.parametrize("search_element", [456, None])
    @pytest.mark.parametrize("text", [123, True, TEST_TEXT])
    def test_non_string_arguments(self, text, search_element):
        """Передача нестроковых аргументов"""
        # Act
        with pytest.raises(TypeError) as exc_info:
            find_elem_index(text, search_element)
        # Assert
        assert "Оба аргумента должны быть строками" in str(exc_info.value)
    
    def test_find_not_existing_element(self): # <-- Добави новый тест
        """Нахождение несуществующего элемента"""
        # Arrange
        search_element = "x"
        expected_index = -1
        # Act
        result = find_elem_index(self.TEST_TEXT, search_element)
        # Assert
        assert result == expected_index
```

![[Pasted image 20251016151022.png]]
![[Pasted image 20251016151033.png]]

Первый шаг завершен, тест сам говорит нам, какая возникает ошибка и в какой строке кода, следовательно, не нужно **тратить время** на дебагинг!
Вторым шагом чиним исходный код.

```python
def find_elem_index(text: str, element: str, case_sensitive: bool = True) -> int:  
    """  
    Находит индекс первого вхождения `element` в `text`.  
    Args:        text: строка для поиска        element: подстрока для нахождения        case_sensitive: учитывать регистр (по умолчанию True)    """    if not isinstance(text, str) or not isinstance(element, str):  
        raise TypeError("Оба аргумента должны быть строками")  
  
    if not case_sensitive:  
        text = text.lower()  
        element = element.lower()  
  
    try:  # <-- добавим блок try/except для перехвата ошибки ValueError  
        return text.index(element)  
    except ValueError:  
        return -1
```

![[Pasted image 20251016151128.png]]

