Установим необходимые зависимости
```python
pip install Fastapi Sqlalchemy Pydantic
```

  
На текущем моменте структура нашего проекта выглядит следующим образом:
```
project/  
├── src/  
│   ├── __init__.py            
│   └── main.py         # Исходный код 
├── tests/              # Тесты  
│   ├── __init__.py     # Пустой файл (чтобы pytest видел tests как модуль)  
│   └── test_main.py    # Тесты для main.py
├── test_venv/
└── pytest.ini          # Конфигурационный файл pytest
```
В главном файле напишем небольшое fastapi приложения с моделями, схемами и вьюшками.

```python
from contextlib import asynccontextmanager  
  
from fastapi import Depends, FastAPI, HTTPException, Query, status  
from sqlalchemy.orm import declarative_base, mapped_column, Mapped, sessionmaker, Session  
from sqlalchemy import Integer, String, create_engine, select  
from pydantic import BaseModel  
  
# Базовый класс для моделей  
Base = declarative_base()  
  
# SQLAlchemy модель с Mapped аннотациями  
class Receipt(Base):  
    __tablename__ = "receipts"  
  
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)  
    total: Mapped[int] = mapped_column(Integer)  
    vat: Mapped[str] = mapped_column(String)  
    client_phone: Mapped[str] = mapped_column(String)  
    cashier_inn: Mapped[str] = mapped_column(String)  
  
# Pydantic схемы  
class ReceiptBase(BaseModel):  
    total: int  
    vat: int  
    client_phone: str  
    cashier_inn: str  
  
class ReceiptCreate(ReceiptBase):  
    pass  
  
class ReceiptPublic(ReceiptBase):  
    id: int  
  
# Настройка базы данных  
DATABASE_URL = "sqlite:///./receipts.db"  
engine = create_engine(  
    DATABASE_URL,  
    echo=False,  
    connect_args={"check_same_thread": False},  
)  
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  
  
# Зависимости  
def get_session():  
    with SessionLocal() as db:  
        yield db  
  
# Создание таблиц  
def create_db_and_tables():  
    Base.metadata.create_all(bind=engine)  
  
@asynccontextmanager  
async def lifespan(app: FastAPI):  
    create_db_and_tables() # в реальном приложении лучше пользоваться alembic для накатки миграций!  
    yield  
  
  
# FastAPI приложение  
app = FastAPI(lifespan=lifespan)  
  
  
# Роуты  
@app.post("/receipts/", response_model=ReceiptPublic, status_code=status.HTTP_201_CREATED,)  
def create_receipt(*, session: Session = Depends(get_session), receipt: ReceiptCreate):  
    db_receipt = Receipt(**receipt.model_dump())  
    session.add(db_receipt)  
    session.commit()  
    session.refresh(db_receipt)  
    return db_receipt  
  
  
@app.get("/receipts/", response_model=list[ReceiptPublic])  
def read_receipts(  
    *,  
    session: Session = Depends(get_session),  
    offset: int = 0,  
    limit: int = Query(default=100, le=100),  
):  
    stmt = select(Receipt).offset(offset).limit(limit)  
    receipts = session.scalars(stmt).all()  
    return receipts
```

Давайте напишем первый тест для ручки создания чека.

```python
from fastapi.testclient import  TestClient  
from fastapi import status  
  
from src.main import app  
  
  
def test_create_receipt():  
    #arrange  
    test_client = TestClient(app)  
    data = {  
        "total": 10000,  
        "vat": 2000,  
        "client_phone": "+79111111111",  
        "cashier_inn": "7357735773577357"  
    }  
  
    #act  
    response = test_client.post("/receipts/", json=data)  
  
    # assert  
    assert response.status_code == status.HTTP_201_OK
```

Если мы запустим тест, он будет использовать рабочую базу данных. В будущих тестах есть возможность добавить тестовых данных или даже удалить нужные данные. Поэтому следует использовать **отдельную тестовую базу данных**, предназначенную исключительно для тестов.
Когда выполняется код приложения, он получает сессию, которая уже подключена к движку (engine), а этот движок уже использует конкретный URL базы данных. Даже если мы импортируем переменную из основного модуля и изменим её значение специально для тестов, к этому моменту движок уже будет создан с исходным значением. **Но все ручки получают сессию через зависимость FastAPI (dependency), а зависимости можно переопределять в тестах.**

Изменим тест
```python
from fastapi.testclient import  TestClient  
from fastapi import status  
from sqlalchemy import create_engine  
from sqlalchemy.orm import Session  
  
from src.main import app, get_session, Base  
  
  
def test_create_receipt():  
    #arrange  
    engine = create_engine(  
        "sqlite:///testing.db:",  
        connect_args={  
            "check_same_thread": False,  
        })  
    Base.metadata.create_all(engine) # Создали тестовую БД  
  
    with Session(engine) as session:  
        def get_session_override():  
            return session  
  
        app.dependency_overrides[get_session] = get_session_override  # перезаписываем зависимости  
  
    test_client = TestClient(app)  
    data = {  
        "total": 10000,  
        "vat": 2000,  
        "client_phone": "+79111111111",  
        "cashier_inn": "7357735773577357"  
    }  
  
    # act  
    response = test_client.post("/receipts/", json = data)  
    app.dependency_overrides.clear()  # возвращаем зависимости к исходному состоянию  
    data = response.json()  
  
    # assert  
    assert response.status_code == status.HTTP_201_CREATED  
    assert data["id"] is not None
```

![[Pasted image 20251017164532.png]]