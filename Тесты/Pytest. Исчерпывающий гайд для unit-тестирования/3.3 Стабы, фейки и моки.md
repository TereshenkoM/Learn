
При тестировании кода, особенно того, что взаимодействует с внешними сервисами или БД, мы не хотим:

- замедлять тесты реальными запросами;
- зависеть от доступности внешних сервисов;
- создавать побочные эффекты в реальных системах.


Чтобы избежать вышеперечисленных негативных последствий, используют **тестовые двойники.**

**Виды тестовых двойников:**

1. **Стабы (Stubs)** - простые заглушки, возвращающие предопределенные данные.    
    - _Пример_: функция, которая всегда возвращает успешный ответ;

2. **Фейки (Fakes)** - упрощенные, но рабочие реализации.    
    - _Пример_: in-memory база данных вместо реальной;
    
3. **Моки (Mocks)** - объекты с предопределенными ожиданиями.    
    - Проверяют, как система взаимодействует с ними;
    - _Пример_: проверка, что был вызван метод post с определенными параметрами;


**Шпаргалка по мокам, стабам и фейкам:**

| Подход   | Когда использовать                                        | Проверяет                                   |
| -------- | --------------------------------------------------------- | ------------------------------------------- |
| **Мок**  | Когда важно проверить взаимодействие                      | Что метод post вызван с нужными параметрами |
| **Стаб** | Когда нужно просто проигнорировать внешний вызов          | Что основная логика работает                |
| **Фейк** | Когда нужно имитировать реальное поведение без сложностей | Что данные правильно обрабатываются         |

**Пример**
Перепишем наш код с использованием **паттерна репозиторий**. Данный подход позволит нам продемонстрировать подход к тестированию с использованием фейков
```python
import requests  
from fastapi import Depends, FastAPI, Query, status  
from sqlalchemy.orm import declarative_base, mapped_column, Mapped, sessionmaker, Session  
from sqlalchemy import Integer, create_engine, select  
from pydantic import BaseModel  
  
# Базовый класс для моделей  
Base = declarative_base()  
  
# SQLAlchemy модель с Mapped аннотациями  
class Receipt(Base):  
    __tablename__ = "receipts"  
  
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)  
    total: Mapped[int]  
    vat: Mapped[int]  
    client_phone: Mapped[str]  
    cashier_inn: Mapped[str]  
  
# Pydantic схемы  
class ReceiptBase(BaseModel):  
    total: int  
    vat: int  
    client_phone: str  
    cashier_inn: str  
  
class ReceiptCreate(ReceiptBase):  
    pass  
  
class ReceiptPublic(ReceiptBase):  
    id: int  
  
# Настройка базы данных  
DATABASE_URL = "sqlite:///./receipts.db"  
engine = create_engine(  
    DATABASE_URL,  
    echo=False,  
    connect_args={"check_same_thread": False},  
)  
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  
  
# Зависимости  
def get_session():  
    with SessionLocal() as db:  
        yield db  
  
def get_repository(session: Session = Depends(get_session)): # <-- добавим зависимость получения репозитория  
    return ReceiptRepository(session)  
  
# Создание таблиц  
def create_db_and_tables():  
    Base.metadata.create_all(bind=engine)  
  
# FastAPI приложение  
app = FastAPI()  
  
  
@app.on_event("startup")  
def on_startup():  
    create_db_and_tables()  
  
class ReceiptRepository: # <-- добавим репозиторий и его методы  
    def __init__(self, session: Session):  
        self.session = session  
  
    @staticmethod  
    def _map_to_receipt(record: Receipt) -> ReceiptPublic:  
        return ReceiptPublic(**record.__dict__)  
  
  
    def create(self, receipt: ReceiptCreate) -> ReceiptPublic:  
        db_receipt = Receipt(**receipt.model_dump())  
        self.session.add(db_receipt)  
        self.session.commit()  
        self.session.refresh(db_receipt)  
        return self._map_to_receipt(db_receipt)  
  
    def get_all(self, offset: int = 0, limit: int = 100) -> list[ReceiptPublic]:  
        stmt = select(Receipt).offset(offset).limit(limit)  
        receipts = self.session.scalars(stmt).all()  
        return [self._map_to_receipt(receipt) for receipt in receipts]  
  
  
# Роуты  
@app.post("/receipts/", response_model=ReceiptPublic, status_code=status.HTTP_201_CREATED,)  
def create_receipt(*, receipt: ReceiptCreate, repo: ReceiptRepository = Depends(get_repository)):  
    return repo.create(receipt) # <-- используем репу  
  
  
@app.get("/receipts/", response_model=list[ReceiptPublic])  
def read_receipts(  
    *,  
    repo: ReceiptRepository = Depends(get_repository),  
    offset: int = 0,  
    limit: int = Query(default=100, le=100),  
):  
    return repo.get_all(offset=offset, limit=limit) # <-- используем репу
```

Содержимое **conftest.py**
```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session
from fastapi.testclient import TestClient
from src.main import app, Base, get_session, get_repository, ReceiptCreate, ReceiptPublic


@pytest.fixture()
def test_engine():
    engine = create_engine(
        "sqlite:///testing.db", connect_args={"check_same_thread": False}
    )
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture
def test_session(test_engine):
    with Session(test_engine) as session:
        yield session

@pytest.fixture
def test_client(test_session):
    app.dependency_overrides[get_session] = lambda: test_session
    yield TestClient(app)
    app.dependency_overrides.clear()

#Добавим фейковый репозиторий

@pytest.fixture(scope="function")
def fake_repo():
    return FakeRepo()

@pytest.fixture
def test_client_with_fake_uow(fake_repo):
    app.dependency_overrides[get_repository] = lambda: fake_repo
    yield TestClient(app)
    app.dependency_overrides.clear()

class FakeRepo:
    def __init__(self):
        self.data = []

    def create(self, data: ReceiptCreate) -> ReceiptPublic:
        new_record = ReceiptPublic(id=len(self.data) + 1, **data.model_dump())
        self.data.append(new_record)
        return new_record

    def get_all(self, offset: int = 0, limit: int = 100) -> list[ReceiptPublic]:
        return self.data[offset:offset+limit]
```

Содержимое **test_main.py**
```python
from fastapi import status
from sqlalchemy.orm import Session
from fastapi.testclient import TestClient

from src.main import Receipt, ReceiptPublic
from tests.conftest import FakeRepo


def test_create_receipt(test_client: TestClient):
        data = {
            "total": 10000,
            "vat": 2000,
            "client_phone": "+79111111111",
            "cashier_inn": "7357735773577357",
        }

        response = test_client.post("/receipts/", json=data)
        data = response.json()

        assert response.status_code == status.HTTP_201_CREATED
        assert data["id"] is not None

def test_read_receipts(test_session: Session, test_client: TestClient):
    receipt_1 = Receipt(total=10000, vat=2000, client_phone="+79111111111", cashier_inn="7357735773577357")
    receipt_2 = Receipt(total=5000, vat=100, client_phone="+7953535353", cashier_inn="1111111111111111")
    test_session.add(receipt_1)
    test_session.add(receipt_2)
    test_session.commit()

    response = test_client.get("/receipts/")
    data = response.json()

    assert response.status_code == status.HTTP_200_OK

    assert len(data) == 2
    for receipt, observed in zip((receipt_1, receipt_2), data):
        assert observed["id"] == receipt.id
        assert observed["total"] == receipt.total

# напишем тесты на фековом репозитрии

def test_create_fake(test_client_with_fake_uow: TestClient):
    data = {
        "total": 10000,
        "vat": 2000,
        "client_phone": "+79111111111",
        "cashier_inn": "7357735773577357",
    }

    response = test_client_with_fake_uow.post("/receipts/", json=data)
    data = response.json()

    assert response.status_code == status.HTTP_201_CREATED
    assert data["id"] is not None

def test_read_receipts_fake(fake_repo: FakeRepo, test_client_with_fake_uow: TestClient):
    receipt_1 = ReceiptPublic(id=1, total=10000, vat=2000, client_phone="+79111111111", cashier_inn="7357735773577357")
    receipt_2 = ReceiptPublic(id=2, total=5000, vat=100, client_phone="+7953535353", cashier_inn="1111111111111111")
    fake_repo.data.extend([receipt_1, receipt_2])

    response = test_client_with_fake_uow.get("/receipts/")
    data = response.json()

    assert response.status_code == status.HTTP_200_OK
    assert len(data) == 2
    for receipt, observed in zip((receipt_1, receipt_2), data):
        assert observed["id"] == receipt.id
        assert observed["total"] == receipt.total
```

![[Pasted image 20251020212114.png]]

Получаем, что удалось избежать взаимодействия с базой данных, используя фековый репозиторий, обычно в коде достаточно тесты обработчиков писать на фейковом репозитории, а тесты на методы репозитория писать с использованием базы данных.

Такой подход особенно полезен для:
* юнит-тестов, где важна скорость;
* тестирования без доступа к реальной БД;
* изоляции тестов от инфраструктуры.