
Правильный выбор инструментов для тестирования помогает эффективно покрывать код на всех уровнях. Вот какие технологии и фреймворки чаще всего используются на каждом этапе:  
  
**Unit-тесты (модульные)**

**Цель:** Проверка отдельных функций, методов или классов **в изоляции**.  
**Инструменты:**
- **Python:** `pytest`, `unittest`
- **Mocking:** `unittest.mock`
- **Покрытие кода:** `pytest-cov`
    
**Интеграционные тесты**

**Цель:** Проверка взаимодействия между компонентами (API ↔ БД, сервисы ↔ сервисы).  
**Инструменты:**

- **Python:** `pytest`, `unittes`    
- **Mocking:** `unittest.mock`
- **Тестирование интеграций:** `Django TestCase` (ORM), `Testcontainers` (Docker), `Trstcontainers`  

 **E2E-тесты (сквозные)**

**Цель:** Имитация действий пользователя в полном окружении (UI, API, внешние сервисы).  
**Инструменты:**
- **Веб-приложения:** `Selenium`, `Cypress`, `Playwright`
- **Мобильные приложения:** `Appium`, `Espresso` (Android), `XCUITest` (iOS)


### Сравнение unittest и pytest
  
`Unittest` и `pytest` являются популярными фреймворками для тестирования кода на Python , однако `pytest` считается более современным и удобным инструментом. Ниже переведены описание каждого модуля. 

**unittest (встроенный в Python)**

**Особенности:**

- Требует ООП-стиля (классы, методы `setUp/tearDown`).
- Жёсткая структура: тесты должны быть методами класса, наследованного от `unittest.TestCase`.
- Ассерты через встроенные методы (`self.assertEqual()`, `self.assertTrue()` и т.д.).
- Запуск через `unittest.main()` или командную строку.

**Пример:**
```python
import unittest

class TestStringMethods(unittest.TestCase):
    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
```

**Плюсы:**
- Встроен в Python — не требует установки.

**Минусы:**
- Менее гибкий для параметризации и фикстур.

**pytest (сторонний фреймворк)**

**Особенности:**
- Гибкий: тесты можно писать как функции (без ООП), но поддерживает и классы.
- Простые ассерты через `assert` (без лишних методов).
- Автоматическое обнаружение тестов (ищет файлы `test_*.py` и функции `test_*`).
- Поддержка фикстур (`@pytest.fixture`) для подготовки данных.
- Параметризация тестов (`@pytest.mark.parametrize`).
- Плагины (`pytest-cov`, `pytest-mock`, `pytest-xdist` для параллельного запуска).

**Пример:**
```python
def test_add():
    assert 1 + 1 == 2

# Параметризованный тест
@pytest.mark.parametrize("a, b, expected", [(1, 2, 3), (0, 0, 0)])
def test_sum(a, b, expected):
    assert a + b == expected
```

**Плюсы:**
- Минимум кода — максимум функциональности.
- Поддержка сложных сценариев (фикстуры, моки, параметризация).
- Детальные отчёты об ошибках.
- Большое сообщество и плагины.

**Минусы:**
- Требует установки (`pip install pytest`).