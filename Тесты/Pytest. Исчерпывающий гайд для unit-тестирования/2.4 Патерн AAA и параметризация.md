При написании тестов стоит пользоваться паттерна AAA (три А). Данный паттерн говорит о структуре юнит теста. Соответственно данный паттерн предполагает структуру теста, который состоит из 3 блоков:
* arrange (подготовка) - Подготовка тестовых данных
* act (действие) - Выполнение тестового кода
* assert (проверка) - Проверка результатов

Давайте посмотрим как это выглядит на практике. Изначально необходимо расширить функцию дополнительным функционалом: добавим флаг на чувствительность к регистру.

**example.py**
```python
def find_elem_index(text: str, element: str, case_sensitive: bool = True) -> int:
    """
    Находит индекс первого вхождения `element` в `text`.
    
    Args:
        text: строка для поиска
        element: подстрока для нахождения
        case_sensitive: учитывать регистр (по умолчанию True)
    """
    if not isinstance(text, str) or not isinstance(element, str):
        raise TypeError("Оба аргумента должны быть строками")
        
    if not case_sensitive:
        text = text.lower()
        element = element.lower()
        
    return text.index(element)
```

В таком случае расширим тестовый класс и приведем его к формату по паттерну AAA.  
**test_example.py:**
```python
import pytest  
from src.example import find_elem_index  
  
  
class TestFindElemIndex:  
    """Тесты функции find_elem_index с применением AAA подхода"""  
    TEST_TEXT = "abcdef"  
  
    def test_find_existing_element(self):  
        """Нахождение существующего элемента"""  
        # Arrange  
        search_element = "c"  
        expected_index = 2  
  
        # Act  
        result = find_elem_index(self.TEST_TEXT, search_element)  
  
        # Assert  
        assert result == expected_index  
  
    def test_find_int(self):  
        """Проверка с некорректным типом аргумента"""  
        # Arrange  
        search_element = 123  
  
        # Act  
        with pytest.raises(TypeError) as exc_info:  
            find_elem_index(self.TEST_TEXT, search_element)  
  
        # Assert  
        assert str(exc_info.value) == "Оба аргумента должны быть строками"
```

Данный паттерн позволил избежать ещё одного **антипаттерна Магические числа.**  

Данный паттерн позволил избежать ещё одного антипаттерна Магические числа.  

Магические числа — это "голые" числовые или строковые константы, встроенные прямо в код без пояснений. Они:
1. не имеют понятного смысла без контекста;
2. не описаны в документации;
3. могут изменяться без очевидных последствий.

Магические числа допустимы в:
1. научных вычислениях с общеизвестными константами
2. очевидных математических операциях (x * 0 или i + 1)
3. Помните: хороший код объясняет себя сам без дополнительных комментариев!


## Параметризация тестов
Видим, что предыдущий тест на проверку некорректных типов покрывает только случай некорректного элемента и только относительно целого числа.
```python
import pytest  
from src.example import find_elem_index  
  
  
class TestFindElemIndex:  
    """Тесты функции find_elem_index с применением AAA подхода"""  
    TEST_TEXT = "abcdef"  
  
    def test_find_existing_element(self):  
        """Нахождение существующего элемента"""  
        # Arrange  
        search_element = "c"  
        expected_index = 2  
  
        # Act  
        result = find_elem_index(self.TEST_TEXT, search_element)  
  
        # Assert  
        assert result == expected_index  
  
    def test_find_int(self):  
        """Проверка с некорректным типом аргумента"""  
        # Arrange  
        search_element = 123  
  
        # Act  
        with pytest.raises(TypeError) as exc_info:  
            find_elem_index(self.TEST_TEXT, search_element)  
  
        # Assert  
        assert str(exc_info.value) == "Оба аргумента должны быть строками"
```

Чтобы доработать тест по подходу AAA добавим в блок **Arrange** кортеж тестовых данных.
```python
import pytest  
from src.example import find_elem_index  
  
  
  
class TestFindElemIndex:  
    """Тесты функции find_elem_index с применением AAA подхода"""  
  
    TEST_TEXT = "abcdef"  
  
    def test_find_existing_element(self):  
        """Нахождение существующего элемента"""  
        # Arrange  
        search_element = "c"  
        expected_index = 2  
  
        # Act  
        result = find_elem_index(self.TEST_TEXT, search_element)  
  
        # Assert  
        assert result == expected_index  
  
    def test_non_string_arguments(self): # <-- заменили метод test_find_int  
        """Передача нестроковых аргументов"""  
        # Arrange  
        test_data = (  
            (123, 456),  
            (123, None),  
            (True, 456),  
            (True, None),  
            (self.TEST_TEXT, 456),  
            (self.TEST_TEXT, None)  
        )  
  
        for text, element in test_data:  
            # Act  
            with pytest.raises(TypeError) as exc_info:  
                find_elem_index(text, element)  
            # Assert  
            assert "Оба аргумента должны быть строками" in str(exc_info.value)
```
![[Pasted image 20251016145651.png]]

**При написании тестов старайтесь избегать множественных секций arrange, act и assert. Если вы видите тест, содержащий серию действий и проверок, отрефакторите его: выделите каждое действие в отдельный тест.**

**В этом нам поможет параметризация!**
Декоратор **@pytest.mark.parametrize** позволяет запускать один тест с разными наборами входных данных и ожидаемых результатов. Это значительно сокращает объем кода и упрощает тестирование граничных случаев.  
Для понимания перепишем тест **test_non_string_arguments** при помощи декоратора 
**@pytest.mark.parametriz**
```python
import pytest
from src.example import find_elem_index



class TestFindElemIndex:
    """Тесты функции find_elem_index с применением AAA подхода"""

    TEST_TEXT = "abcdef"

    def test_find_existing_element(self):
        """Нахождение существующего элемента"""
        # Arrange
        search_element = "c"
        expected_index = 2

        # Act
        result = find_elem_index(self.TEST_TEXT, search_element)

        # Assert
        assert result == expected_index

    @pytest.mark.parametrize(
        "text,search_element",
        [(123, 456), (123, None), (True, 456), (True, None), (TEST_TEXT, 456), (TEST_TEXT, None)],
    )
    def test_non_string_arguments(self, text, search_element):
        """Передача нестроковых аргументов"""
        # Act
        with pytest.raises(TypeError) as exc_info:
            find_elem_index(text, search_element)
        # Assert
        assert "Оба аргумента должны быть строками" in str(exc_info.value)
```

![[Pasted image 20251016145936.png]]

В этом примере:
- декоратор определяет две пары параметров `"text,search_element"`, которые передаются одной строкой;
- тест `test_non_string_arguments` выполнится 6 раз - по одному разу для каждого набора параметров.

Также параметры можно комбинировать параметры, что позволит уменьшить количество передаваемых значений
```python
import pytest
from src.example import find_elem_index



class TestFindElemIndex:
    """Тесты функции find_elem_index с применением AAA подхода"""

    TEST_TEXT = "abcdef"

    def test_find_existing_element(self):
        """Нахождение существующего элемента"""
        # Arrange
        search_element = "c"
        expected_index = 2

        # Act
        result = find_elem_index(self.TEST_TEXT, search_element)

        # Assert
        assert result == expected_index

    # перепишем один декоратор на 2
    # @pytest.mark.parametrize(
    #     "text,search_element",
    #     [(123, 456), (123, None), (True, 456), (True, None), (TEST_TEXT, 456), (TEST_TEXT, None)],
    # )
    @pytest.mark.parametrize("search_element", [456, None])
    @pytest.mark.parametrize("text", [123, True, TEST_TEXT])
    def test_non_string_arguments(self, text, search_element):
        """Передача нестроковых аргументов"""
        # Act
        with pytest.raises(TypeError) as exc_info:
            find_elem_index(text, search_element)
        # Assert
        assert "Оба аргумента должны быть строками" in str(exc_info.value)
```

![[Pasted image 20251016150120.png]]

