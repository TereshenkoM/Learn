## Тестирование исключений в pytest

Вернёмся к предыдущему тесту, но немного изменим его.

example.py
```python
def find_elem_index(text: str, element: str) -> int:
    """Находит индекс первого вхождения `element` в `text`."""
    if not isinstance(text, str) or not isinstance(element, str):  # <-- добавим проверку на типы данных
        raise TypeError("Оба аргумента должны быть строками")
    return text.index(element)
```

test_example.py
```python
from src.example import find_elem_index  
  
  
def test_find_elem_index():  
    """Проверка функции find_elem_index"""  
    assert find_elem_index("abcdef", "c") == 2
```

Покроем тест случаем, когда элемент **не соответствует** ожидаемому типу str.
```python
from src.example import find_elem_index


def test_find_elem_index():
    """Проверка функции find_elem_index"""
    assert find_elem_index("abcdef", "c") == 2

def test_find_int():  # <-- добавлен тест
    """Проверка с некорректным типом аргумента"""
    assert find_elem_index("abcdef", 123) == -1
```

При запуске теста видим следующее
![[Pasted image 20251016143555.png]]

Видно, что тест `test_find_int` упал с ошибкой `TypeError: Оба аргумента должны быть строками`. Понимаем, что такое поведение заложено бизнес-логикой и в тестах нужно отлавливать, что при переданных параметрах функция должна выбросить ошибку. Для проверки выброса исключений в тестах используйте `pytest.raises()` как контекстный менеджер:

```python
from src.example import find_elem_index
import pytest

def test_find_elem_index():
    """Проверка функции find_elem_index"""
    assert find_elem_index("abcdef", "c") == 2

def test_find_int():
    """Проверка с некорректным типом аргумента"""
    with pytest.raises(TypeError):  # <-- добавлен
        find_elem_index("abcdef", 123)
```


**Доступ к информации об исключении**

Если нужно получить детали исключения, то стоит использовать exc_info.
```python
from src.example import find_elem_index
import pytest

def test_find_elem_index():
    """Проверка функции find_elem_index"""
    assert find_elem_index("abcdef", "c") == 2

def test_find_int():
    """Проверка с некорректным типом аргумента"""
    with pytest.raises(TypeError) as exc_info:
        find_elem_index("abcdef", 123)
    assert str(exc_info.value) == "Оба аргумента должны быть строками"
```

Где `exc_info` — это экземпляр `ExceptionInfo`, содержащий атрибуты:
- `.type`: тип исключения;
- `.value`: экземпляр исключения;
- `.traceback`: трассировка стека.

**Важное замечание о наследовании исключений**

`pytest.raises()` работает аналогично `except` — ловит указанный тип исключения **и все его подклассы**.

Если нужно проверить **точное совпадение типа**, добавьте явную проверку: 
```python
def test_exact_exception():
    with pytest.raises(RuntimeError) as excinfo:
        # Код, вызывающий NotImplementedError (подкласс RuntimeError)
        raise NotImplementedError("Не реализовано")
    
    # Тест пройдет, так как NotImplementedError наследуется от RuntimeError
    # Но следующая проверка выявит несоответствие:
    assert excinfo.type is NotImplementedError  # Явная проверка точного типа
```


**Группировка тестов в pytest**
Сейчас в нашем test_examples.py находится 2 теста, со временем их количество может расти, поэтому можно группировать тесты в классы. Тестовый класс должен именоваться, начиная с префикса Test. Так же можно вынести тестируемую строку в атрибут класса TEST_TEXT.

```python
import pytest
from src.example import find_elem_index

class TestFindElemIndex:
    """Тесты функции find_elem_index"""
    TEST_TEXT = "abcdef"

    def test_find_elem_index(self):
        """Проверка функции find_elem_index"""
        assert find_elem_index(self.TEST_TEXT, "c") == 2

    def test_find_int(self):
        """Проверка с некорректным типом аргумента"""
        with pytest.raises(TypeError) as exc_info:
            find_elem_index(self.TEST_TEXT, 123)
        assert str(exc_info.value) == "Оба аргумента должны быть строками"
```

Преимущества:
1. **Организация тестов**
    - логическая структура: тесты, связанные одной функциональностью, находятся в одном классе;
    - удобство навигации: проще находить и поддерживать тесты для конкретного модуля или фичи.

2. **Общие фикстуры только для тестов класса** (поговорим про фикстуры в следующих уроках)
    - фикстуры, определенные в классе (`@pytest.fixture`), применяются только к его методам;
    - позволяет избежать "загрязнения" фикстурами других тестов.
    
3. **Применение маркеров на уровне класса:**
    - маркеры (например, `@pytest.mark.skip`) можно задать один раз для всего класса.

**Избегайте общих состояниймежду тестами — pytest автоматически создает новый экземпляр класса для каждого теста.**

```python
class TestBadExample:
    shared_data = []  # Антипаттерн!

    def test_add(self):
        self.shared_data.append(1)
        assert len(self.shared_data) == 1

    def test_check(self):
        assert len(self.shared_data) == 0  # Упадет, так как shared_data = [1] после test_add!
```