
### 1. **Проверка палиндрома**

**Задача:** Определить, является ли строка палиндромом (игнорируя регистр и неалфавитные символы).


```python
def is_palindrome(s: str) -> bool:
    s = ''.join(c.lower() for c in s if c.isalnum())
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

**Сложность:** O(n)  
**Нюансы:** Удаляем неалфавитные символы и приводим к нижнему регистру.

---

### 2. **Two Sum**

**Задача:** Найти индексы двух чисел в массиве, дающих в сумме `target`.

```python

def two_sum(nums: list[int], target: int) -> list[int]:
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```
**Сложность:** O(n)  
**Нюансы:** Используем словарь для хранения пройденных значений.

---

### 3. **FizzBuzz**

**Задача:** Вывести числа от 1 до n, заменяя числа, кратные 3, 5 и 15.


```python
def fizzbuzz(n: int) -> list[str]:
    result = []
    for i in range(1, n+1):
        s = ""
        if i % 3 == 0:
            s += "Fizz"
        if i % 5 == 0:
            s += "Buzz"
        result.append(s if s else str(i))
    return result
```

**Сложность:** O(n)  
**Нюансы:** Проверяем делимость на 15 через комбинацию 3 и 5.

---

### 4. **Проверка валидности скобок**

**Задача:** Проверить, правильно ли вложены скобки в строке.


```python
def is_valid(s: str) -> bool:
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return False
        else:
            stack.append(char)
    return not stack
```

**Сложность:** O(n)  
**Нюансы:** Используем стек для отслеживания открывающих скобок.

---

### 5. **Поиск цикла в связном списке**

**Задача:** Определить, есть ли цикл в односвязном списке.

```python
class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

def has_cycle(head: ListNode) -> bool:
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```


**Сложность:** O(n)  
**Нюансы:** Алгоритм Флойда («черепаха и заяц»).

---

### 6. **Reverse Linked List (Разворот списка)**

**Задача:** Развернуть односвязный список.


```python
def reverse_list(head: ListNode) -> ListNode:
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev
```


**Сложность:** O(n)  
**Нюансы:** Итеративный подход с тремя указателями.

---

### 7. **Binary Search (Бинарный поиск)**

**Задача:** Найти индекс элемента в отсортированном массиве.


```python
def binary_search(nums: list[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```


**Сложность:** O(log n)  
**Нюансы:** Работает только на отсортированных массивах.

---

### 8. **Fibonacci с мемоизацией**

**Задача:** Вычислить n-ое число Фибоначчи.

```python
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n+1):
        a, b = b, a + b
    return b
```


**Сложность:** O(n)  
**Нюансы:** Итеративный подход эффективнее рекурсивного.

---

### 9. **Merge Two Sorted Arrays (Слияние массивов)**

**Задача:** Объединить два отсортированных массива в один.

```python
def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:
    i, j, k = m-1, n-1, m+n-1
    while j >= 0:
        if i >= 0 and nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
```

**Сложность:** O(m + n)  
**Нюансы:** Заполняем массив с конца.

---

### 10. **Maximum Subarray (Кадана)**

**Задача:** Найти подмассив с максимальной суммой.

```python
def max_subarray(nums: list[int]) -> int:
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum
```

**Сложность:** O(n)  
**Нюансы:** Алгоритм Кадана. Учитывает отрицательные числа.