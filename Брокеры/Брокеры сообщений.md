#Брокеры #RabbitMQ
**Брокер сообщений** - компонент системы, который позволяет "общаться" разным сервисам при помощи посредника.

Producer - тот, кто записывает сообщения
Consumer - тот, кто их получает

**Плюсы брокеров:**
- Асинхронная обработка
	Брокеры сообщений позволяют сервисам обмениваться сообщениями асинхонно, т.е. отправителю не нужно ждать ответа от получателя и не нужно останавливать свою работу до получения ответа (как в синхронном варианте), он продолжает свою работу

- Надёжность
	Благодаря специальным механизмам брокеры могут гарантировать доставку даже в случае сбоев

- Гибкость масштабирования
	При использовании брокеров  легко масштабировать систему без значительных изменений в архитектуре. P.S Речь о горизонтальном масштабировании (на новых серверах, вертикально - значит увеличивать ресурсы на одном сервере)

![[Pasted image 20241121115221.png]]

**Популярные брокеры:**
1) Apache Kafka
	- Самый популярный
	- Выдерживает огромные нагрузки (больше миллиона запросов в секунду)
	- Легко масштабировать
	- Хранит все сообщения
2) RabbitMQ
	- Очень легко развернуть
	- Можно легко отложить сообщения
	- Удобное масштабирование консьюмеров (сервисов которые читают/потребляют сообщения)
3) NATS 
	- Относительно новый
	- Куча плагинов


**Базовый пример работы с RabbitMQ** 
(предварительно необходимо установить RabbitMQ)

**Producer** (отправляет сообщения)
```python
import time

from pika import BlockingConnection, ConnectionParameters # Импортируем необходимые классы из библиотеки pika для работы с RabbitMQ

  

# Настройка подключения к RabbitMQ

connection = BlockingConnection(ConnectionParameters('localhost')) # Создаем подключение к локальному экземпляру RabbitMQ
channel = connection.channel() # Создаем канал для взаимодействия с RabbitMQ

  

# Создаём очередь (если очередь с таким именем еще не существует, она будет создана)
channel.queue_declare(queue='test_queue')

  


for i in range(1000):
	# Отправляем сообщение в указанную очередь
	
	channel.basic_publish(
		exchange='', # Указываем, что сообщение не будет использовать обменник (по умолчанию используется пустой строкой)
		
		routing_key='test_queue', # Указываем имя очереди, в которую отправляем сообщение
		
		body=f'Hello RabbitMQ {i}' # Содержимое сообщения, добавляем счетчик для уникальности каждого сообщения
	)
	
	print('Сообщение отправлено!') 	
	time.sleep(1)

  

# Закрываем соединение с RabbitMQ
connection.close() # Закрываем соединение после отправки всех сообщений
```


Consumer (читает сообщения)
```python
from pika import BlockingConnection, ConnectionParameters



# Настройка подключения к RabbitMQ
connection = BlockingConnection(ConnectionParameters('localhost')) # Создаем подключение к локальному экземпляру RabbitMQ
channel = connection.channel() # Создаем канал для взаимодействия с RabbitMQ


# Создаём очередь (если очередь с таким именем еще не существует, она будет создана)
channel.queue_declare(queue='test_queue') # Объявляем очередь с именем 'test_queue'

  

# Функция для обработки полученных сообщений
def callback(ch, method, properties, body):
	print(f'Получено сообщение: {body.decode()}')

  

# Настраиваем получение сообщений из очереди

channel.basic_consume(
	queue='test_queue', # Указываем очередь, из которой получаем сообщения,
	on_message_callback=callback, # Указываем функцию для обработки сообщений
	auto_ack=True # Автоматически подтверждаем получение сообщения из очереди
)

print("Ожидание сообщений")

channel.start_consuming() # Начинаем получать сообщения
```

**!ВАЖНО!** 
В брокер не стоит передавать большие сообщения. Обычно это просто небольшие строки/json'ы.
## Более сложный пример работы с RabbitMQ

**Producer**

```python
from pika import ConnectionParameters, BlockingConnection  

# Настраиваем параметры подключения
connectiom_params = ConnectionParameters(
    host='localhost',  # Указываем адрес хоста RabbitMQ (в данном случае локальный сервер)
    port=5672  # Указываем порт, на котором запущен RabbitMQ (по умолчанию это 5672)
)


def main():
    # Используем контекстный менеджер для подключения к RabbitMQ и гарантированного закрытия соединения
    with BlockingConnection(parameters=connectiom_params) as conn:
        # Создаем канал для взаимодействия с RabbitMQ, также с использованием контекстного менеджера
        with conn.channel() as ch:
            # Объявляем очередь с именем 'messages' (создаем её, если не существует)
            ch.queue_declare(queue="messages")
            # Публикуем сообщение в указанную очередь
            ch.basic_publish(
                exchange="",  # Указываем обменник по умолчанию (пустая строка)
                routing_key="messages",  # Указываем имя очереди, в которую отправляем сообщение
                body="Hello RabbitMQ"  # Тело сообщения, которое будет отправлено в очередь
            )
            print("Message sent!")  # Выводим в консоль подтверждение отправки сообщения


if __name__ == '__main__':
    main()

```


**Consumer**

```python
from pika import ConnectionParameters, BlockingConnection

# Настраиваем параметры подключения
connectiom_params = ConnectionParameters(
    host='localhost',  # Указываем адрес хоста RabbitMQ (локальный сервер)
    port=5672  # Указываем порт, на котором запущен RabbitMQ (по умолчанию это 5672)
)

# Функция обратного вызова для обработки сообщений из очереди
def callback(ch, method, properties, body):
    # Печатаем полученное сообщение, декодируя его из байтов в строку
    print(f'Получено - {body.decode()}')
    # Подтверждаем успешную обработку сообщения, чтобы RabbitMQ мог удалить его из очереди
    ch.basic_ack(delivery_tag=method.delivery_tag)  # Хороший метод подтверждения сообщений: сначала обрабатываем, а потом удаляем


def main():
    # Используем контекстный менеджер для подключения к RabbitMQ и гарантированного закрытия соединения
    with BlockingConnection(parameters=connectiom_params) as conn:
        # Создаем канал для взаимодействия с RabbitMQ, также с использованием контекстного менеджера
        with conn.channel() as ch:
            # Объявляем очередь с именем 'messages' (создаем её, если не существует)
            ch.queue_declare(queue="messages")
            # Настраиваем потребление сообщений из указанной очереди
            ch.basic_consume(
                queue="messages",  # Указываем имя очереди, из которой нужно получать сообщения
                on_message_callback=callback,  # Указываем функцию обратного вызова для обработки каждого полученного сообщения
                # auto_ack=True  # Автоматическое подтверждение получения сообщения (не рекомендуется).
                # При auto_ack=True мы сразу удаляем сообщение, а потом его обрабатываем, что может привести к потере сообщения в случае ошибки.
            )
            print("Wait")  # Уведомляем в консоль, что потребитель готов и ждет сообщения
            ch.start_consuming()  # Запускаем процесс потребления сообщений, он будет работать в бесконечном цикле, пока не остановлен


if __name__ == '__main__':
    main()

```


## Скрипт для установки RabbitMQ

```sh
#!/bin/sh

sudo apt-get install curl gnupg apt-transport-https -y

## Team RabbitMQ's main signing key
curl -1sLf "https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/com.rabbitmq.team.gpg > /dev/null
## Community mirror of Cloudsmith: modern Erlang repository
curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-erlang.E495BB49CC4BBE5B.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg > /dev/null
## Community mirror of Cloudsmith: RabbitMQ repository
curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-server.9F4587F226208342.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.9F4587F226208342.gpg > /dev/null

## Add apt repositories maintained by Team RabbitMQ
sudo tee /etc/apt/sources.list.d/rabbitmq.list <<EOF
## Provides modern Erlang/OTP releases
##
deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main
deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main

# another mirror for redundancy
deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main
deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main

## Provides RabbitMQ
##
deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main
deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main

# another mirror for redundancy
deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main
deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main
EOF

## Update package indices
sudo apt-get update -y

## Install Erlang packages
sudo apt-get install -y erlang-base \
                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \
                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \
                        erlang-runtime-tools erlang-snmp erlang-ssl \
                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing

```


## RabbitMQ Management 

**docker-compose**
```docker
services:
	rabbitmq:
		image: rabbitmq:3.10.7-management
		hostname: rabbitmq
		ports:
		- 15672:15672
		- 5672:5672
```

Доступ к management системе по http://127.0.0.1:15672

![[Pasted image 20241121131042.png]]