
Алгоритм - набор инструкций для выполнения какой-либо задачи.

## О - большое (скорость работы алгоритма)

O-большое - скорость выполнения алгоритма, а именно описывает, насколько быстро работает алгоритм. **O-большое НЕ СООБЩАЕТ СКОРОСТЬ В СЕКУНДАХ, А ПОЗВОЛЯЕТ СРАВНИТЬ КОЛИЧЕСТВО ОПЕРАЦИЙ**. Оно указывает, насколько быстро возрастает время работы алгоритма. Также стоит понимать, что О-большое описывает худший сценарий. 

**ВАЖНО**
* Скорость алгоритмов измеряется не в секундах, а в темпе роста кол-ва операций
* По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных
## Примеры для О-большое

Простой (линейный) поиск - O(n), где n - количество элементов в массиве. 
Следовательно, для O(128) - потребуется выполнить 128 операций.

Бинарный поиск - O(log n), где n - количество элементов в массиве.
Следовательно, для O(128) - потребуется выполнить 7 операций.

Быстрая сортировка - O(n * log n)

Медленная сортировка - O(n^2)

Очень медленные алгоритмы - O(n!)

## О-большое для разных типов данных

1. Массивы 
	1. Чтение O(1)
	2. Вставка O(n)
	3. Удаление O(n)
2. Связные  списки
	1. Чтение O(n)
	2. Вставка O(1)
	3. Удаление O(1)
	**Примечание к массивам и связанным спискам**. Для произвольного доступа к объекту лучше подходят массивы, а для манипулирования данными (вставка/удаление).

## Бинарный поиск

Бинарный поиск - алгоритм, который на входе получает отсортированный список элементов. Если искомый элемент присутствует в списке, то бинарный поиск возвращает ту позицию, на которой он находится. В противном случае возвращает null.

Пример реализации
```python
def binary_search(arr, item):
	low = 0 # Границы поиска
	high = len(arr) - 1 # Границы поиска

	while low <=high: # Пока часть не сократится до одного элемента
		mid = (low+high) // 2 # Высчитываем индекс среднего элемента
		guess = arr[mid] # Берём средний элемент

		if guess==item: # Если равны, то возвращаем
			return mid
		elif guess > item: # В случае, если средний элемент больше загаданного, то уменьшаем верхнюю границу поиска
			high = mid - 1
		else:
			low = mid + 1 # В случае, если средний элемент меньше загаданного, то увеличиваем верхнюю границу поиска

	return None
```


## Сортировка выбором

Выполняется за время O(n^2).

```python
def find_smallest(arr):
	smallest = arr[0]
	smallest_index = 0

	for index in range(len(arr)):
		elem = arr[index]
		if elem < smallest:
		smallest = elem
		smallest_index = index

	return smallest_index


def selection_sort(arr):
	new_arr = []
	copied_arr = list(arr)

	for _ in range(len(copied_arr)):
		smallest = find_smallest(copied_arr)
		new_arr.append(copied_arr.pop(smallest))

	return new_arr

print(selection_sort([1,2,3,4,-1])) # [-1, 1, 2, 3, 4]
```


## Алгоритм быстрой сортировки
```python
def quick_sort(arr):
	if len(arr) < 2:
		return arr
	else:
		pivot = arr[0]

		less = [i for i in arr[1:] if i<=pivot]
		greater = [i for i in arr[1:] if i > pivot]

		return quick_sort(less) + [pivot] + quick_sort(greater)


print(quick_sort([1, 6, 21, 99, 22, -4, 0]))
# [-4, 0, 1, 6, 21, 22, 99]
```

**Пояснение**. pivot - опорный элемент. less - массив элементов, который меньше pivot.
greater - массив элементов, который больше опорного элемента.

Далее каждому к less и greater применяется тот же метод: снова формируется pivot, less и greater.

Когда рекурсия заканчивается все подмассивы оказывается отсортированными.
На каждом уровне рекурсии мы «склеиваем» три части.
Благодаря этому все элементы в итоге встают на правильные места, и мы получаем полностью отсортированный массив.

**СКОРОСТЬ РАБОТЫ АЛГОРИТМА ЗАВИСИТ ОТ ВЫБОРА ОПОРНОГО ЭЛЕМЕНТА**



## Поиск в ширину

Алгоритм поиска в ширину строится на понятии графа. 
Граф состоит из узлов (круги) и рёбра (стрелки). Граф может быть направленным (когда направление от узла к узлу идёт стрелками) и не неправленый (когда их просто соединяет прямая линия). 

![[Pasted image 20250110105629.png]]

Программная реализация графа
```python
# Создаём граф
graph = {}

graph["вы"] = ["Алиса", "Боб", "Клэр"]
graph["Боб"] = ["Анудж", "Пегги"]
graph["Алиса"] = ["Пегги"]
graph["Клэр"] = ["Том", "Джонни"]
graph["Анудж"] = []
graph["Пегги"] = []
graph["Том"] = []
graph["Джонни"] = []
```

Пример реализации поиска в ширину 

```python
from collections import deque # Двухсторонняя очередь
# Позволяет удалять/добавлять элементы и слева, и справа 
  

def search(name):
	search_queue = deque() # Создаём очередь
	search_queue += graph[name] # Добавляем в очередь
	searched = set() # Множество для уже проверенных
	# элементов (чтобы не проверять один узел много раз)

	while search_queue: # Проходимся циклом по всем
		person = search_queue.popleft() # Удаляем элемент
		if not person in searched: # Если имени нет в множестве проверенных
			if person_is_seller(person): # Проверка (по сути затычка)
				print("Продавец манго " + person)
				return True
			else:
				search_queue += graph[person] # Добалвяем элементы в очередь
				searched.add(person) # Добаляем во множество уже проверенных
	return False


def person_is_seller(name):
	return name[-1] == 'м'


search("вы")
```

**Пояснение**. Это простой пример для графа, где нужно найти продавца манго. Продавец манго - человек, чьё имя заканчивается на м (бред, но ладно xD).
Граф для этой реализации.

![[Pasted image 20250110114514.png]]

**Шпаргалка**

1. Поиск в ширину позволяет определить кратчайший путь из A в B.
2. Если путь существует, то поиск в ширину помогает найти кратчайший.


## Поиск в глубину

```python
import os


def printfiles(dir):
	# Берём список файлов и проходимся циклом
	for file in os.listdir(dir):
		fullpath = os.path.join(dir, file) # Создаём полный путь
		if os.path.isfile(fullpath): # Если это файл - печатаем
			print(file)
		else: # Если не файл, рекурсивно вызываем функцию с новым path
			printfiles(fullpath)

printfiles(".venv")
```
## Деревья

Как и графы деревья состоят из рёбер и узлов. По сути дерево - ациклический граф.
В деревьях, в отличии от графов, не может быть циклов.
### Бинарное дерево

Бинарное дерево - представляет с собой дерево, котором у родительского узла может быть максимум два дочерних.

![[Pasted image 20250110133746.png]]


### Сбалансированные деревья

Как и в бинарной дереве каждый узел имеет до двух дочерних элементов. При этом значение левого дочернего узла всегда меньше, чем значение узла, а значение правого дочернего узла всегда больше. 

![[Pasted image 20250110135409.png]]

**Дерево для худшего случая - его высота равна O(n)**. (например тогда, когда дочерний узел всегда больше родительского).

![[Pasted image 20250110140339.png]]

### АВЛ-деревья

АВЛ-деревья обеспечивает нужную высоту O(log n), которая достигается самобалансировкой и поворотами. 

Поворот - Если между в одной из частей дерева разность между узлами больше одного, то в таком случае делается поворот.
![[Pasted image 20250110140932.png]]![[Pasted image 20250110141028.png]]

### Как АВЛ-дерево узнаёт, что нужен поворот?

Чтобы дерево знало, когда нужен поворот (самобалансировка), оно должно хранить дополнительную информацию. В каждом узле хранится один или два вида информации :
**Значение высоты (или коэффициент самобалансировки)  который может быть равекн: -1, 0, 1. Если же коэффициент выходит за эти пределы, то нужна перебалансировка**.

![[Pasted image 20250110165509.png]]

**Со значениями в пределах от -1 до 1 всё нормально, т.к. АВЛ-деревья не обязаны быть идеально сбалансированы**

В случае если коэффициент балансировки (BF) выходит за эти значения, то тогда дерево перебалансируется.
Пример (H-высота):
![[Pasted image 20250110170305.png]]




**Шпаргалка**
* Сбалансированные бинарные деревья обеспечивают такую же производительность в нотации О-большое, как массивы, и лучшую производительность вставки.
* Высота дерева влияет на его производительность


## Алгоритм Дейкстры

Алгоритм Дейкстры работает с графами. Суть его в том, что каждому ребру в графе может задаваться какое-то числовое значение (такое значение зовётся **весом**, следовательно граф с весами называется взвешенным, а без весов невзвешенным). Например время в минутах. Следовательно поиск кратчайшего пути будет зависеть не от количество шагов от одного узла к другому, а от количества минут для каждого ребра.
![[Pasted image 20250111120443.png]]

Алгоритм Дейкстры состоит из 4 шагов:
1. Найти узел с наименьшей стоимостью
2. Обновить стоимость соседей этого узла
3. Повторять, пока это не будет сделано для всех узлов графа
4. Вычислить итоговый путь


**Примечания**. Веса также могут быть отрицательными. Однако алгоритм дейкстры в таком случае работать не будет.

**Пример**

![[Pasted image 20250111131426.png]]
Граф для примера.

Для реализации примера понадобятся 3 хеш таблицы. 
![[Pasted image 20250112153837.png]]

```python
import math
processed = set()


def find_lowest_cost_node(costs):
	lowest_cost = math.inf
	lowest_cost_node = None

	for node in costs: # Перебрать все узлы
		cost = costs[node]
		# Если это узел с наим. стоимостью из уже виденных
		# и он ещё не был обработан

		if cost <= lowest_cost and node not in processed:
			lowest_cost = cost # Он назначается узлом с наим. стоим.
			lowest_cost_node = node

	return lowest_cost_node

  

# Хеш таблица весов
graph = {}
graph['начало'] = {}
graph['начало']['a'] = 6
graph['начало']['b'] = 2
graph['a'] = {}
graph['a']['конец'] = 1
graph['b'] = {}
graph['b']['a'] = 3
graph['b']['конец'] = 5
graph['конец'] = {}

# Хеш таблица стоимостей
costs = {}
infinity = math.inf
costs['a'] = 6
costs['b'] = 2
costs['конец'] = infinity # Т.к.

# Хещ таблица родители
parents = {}
parents['a'] = 'начало'
parents['b'] = 'начало'
parents['конец'] = None


node = find_lowest_cost_node(costs) # Найти узел с наименьшей стоимостью
while node is not None: # Пока узел не None
	cost = costs[node] # Берём цену узла
	neighbors = graph[node] # Берём цену соседей
	for n in neighbors.keys(): # Перебираем всех соседей текущего узла
		new_cost = cost + neighbors[n]
		if costs[n] > new_cost: # Если к соседу можно добраться быстрее
		# через текущий узел
			costs[n] = new_cost # Обновить стоимость для этого узла
			parents[n] = node # Этот узел становится новым родителем для соседа
		processed.add(node) # Помечаем узел как обработанный
		node = find_lowest_cost_node(costs) # Найти следующий узел и повторить цикл

print(costs)
```


**Шпаргалка**
* Поиск в ширину вычисляет кратчайший путь в невзвешенном графе
* Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе
* Алгоритм Дейстры работает только в том случае, если все веса положительные


## Жадные алгоритмы

Жадный алгоритм - алгоритм, который определяет локально-оптимальное решение для каждого шага (этапа).

Пример: необходимо рассчитать минимальный набор станций, который покрывал бы все 50 штатов США.

**Алгоритм:** (приближённый)
* Выбрать станцию, покрывающую наибольшее количество штатов, ещё не входящих в покрытие. Если станция будет покрывать некоторые штаты, уже входящие в набор, это будет оптимально.
* Повторять, пока не останутся штаты, не входящие в покрытие.

**Пример**
```python
# Список штатов
states_needed = set(['mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'])

# Ключ - название станций
# Значение - сокращённые обозначения штатов
stations = {
	"kone": set(["id", "nv", "ut"]),
	"ktwo": set(["wa", "id", "mt"]),
	"kthree": set(["or", "nv", "ca"]),
	"kfour": set(["nv", "ut"]),
	"kfive": set(["ca", "az"]),
}

# Итоговый набор станций
final_stations = set()

while states_needed:
	# Набор станций, который перекрывает больше всего штатов
	best_station = None
	states_covered = set()

	for station, states in stations.items():
		# Пересечение множества нужных штатов и штатов, покрываемых станцией

		covered = states_needed & states
		if len(covered) > len(states_covered):
			best_station = station
			states_covered = covered

  

	# Удаляем покрытые штаты из множества нужных штатов
	states_needed -= states_covered
	# Добавляем выбранную станцию в итоговый набор
	final_stations.add(best_station)

print(final_stations)
```


