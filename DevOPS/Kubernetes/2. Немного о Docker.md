Docker - одна из систем контейнеризировать приложения. Это самая популярная платформа для создания и управления контейнерами.

Два главных термина:
* Контейнер - исполняемый пакет с приложением, подобен легковесной ВМ с изолированным внутри окружением
* Образ (Image) - это шаблон для запуска такой "машины". Если приводить аналогию, то контейнер - печенье, а образ - форма для выпекания.


## Пример простого контейнера

**Файлы в Listings/2. Немного о Docker

Создаём python файл с простым содержимым
```python
print("Hello from Docker")
```

И пишем простой Dockerfile. Dockerfile - инструкция для сборки образа, файл должен быть без расширения 
```dockerfile
FROM python:3.6-alpine3.8 ## загружаем легковесный образ Python на базе Alpine Linux. 
COPY 1.py /app/ ## копируем файл 1.py с вашего компьютера в директорию /app внутри образа. 
WORKDIR /app ## устанавливаем директорию /app как рабочую директорию для последующих команд. 
ENTRYPOINT ["python3", "/app/1.py"] ## запускаем Python и указываем ему выполнить файл 1.py.
```

Теперь соберём докер образ из текущей директории (точка) и присвоим ему тег (имя).
```bash
docker build . -t py_app:v0.1
```

Этот образ мы можем увидеть при помощи команды
```bash
docker images
```

Для запуска контейнера на основе созданного образа нужно выполнить команду
```bash
docker run py_app:v0.1
```



## Лучшие практики
### MultiStage сборка образов
**Файлы в Listings/2. Немного о Docker/multistage_example**

Есть совсем простенький веб-сервис, написанный на Go.Вот код
```go
package main


import (
	"fmt"
	"log"
	"net/http"
)


func handler(w http.ResponseWriter, r *http.Request) {
	//Ответ клиенту
	fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
	
	// Логируем время, путь и статус
	log.Printf("Received request on path %s", r.URL.Path)
}


func main() {
	http.HandleFunc("/", handler)
	log.Println("Starting server on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

Он получает HTTP запрос, и возвращает все что передавалось после слеша (`/`). 

**Обычная сборка. Шаги**
1. Создали директорию и сохранили всё в файл `main.go`

2. Создали там Dockerfile
```dockerfile
	FROM golang:1.20
	WORKDIR /app
	COPY . .
	RUN go build -o main .
	CMD ["./main"]
```

3. Также создали файл `go.mod`. Это вспомагательный файл, который нужен Go для управления зависимостями
```go
module example.com/myapp

go 1.20
```

4. Получаем такое содержимое директорий
```bash
-rw-rw-r-- 1 ishimura ishimura  80 окт  2 15:27 Dockerfile
-rw-rw-r-- 1 ishimura ishimura  34 окт  2 15:29 go.mod
-rw-rw-r-- 1 ishimura ishimura 446 окт  2 15:24 main.go
```

5. Билдим образ
```bash
docker build . -t go:v0.1
```

**MultiStage сборка. Шаги**
1. Обновляем Dockerfile
```Dockerfile
# Создаем временный Докер Образ и называем его builder
FROM golang:1.20 AS builder                                  
WORKDIR /app
COPY . .
# Компилируем приложение специально для дальнейшего запуска в Alpine
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . 


# Создаем финальный Докер Образ на базе легковесного alpine
FROM alpine:latest                       
WORKDIR /root/
# Копируем собранное приложение из образа builder
COPY --from=builder ./app .              
EXPOSE 8080
CMD ["./app"]
```

2. Для сборки образа выполним команду
```bash
docker build . -t go:v0.2
```

3. Проверим образы
```bash
go v0.1 49dc5c3165eb   5 minutes ago    914MB
go v0.2 69bfb64d8df6   42 minutes ago   74.6MB
```

**Второй образ весит в 12 раз меньше! Как так вышло?**

В первом Dockerfile мы поручили докеру собрать Образ, в котором будут:
* golang
* наше приложение
Docker имеют слоистую/луковичную архитектуру, то есть команды FROM, COPY, AND, RUN создают новые слои поверх предыдущих, а эти слои занимают место на диске.

![[Pasted image 20251002155511.png]]

Но Go - компилируемый язык. Когда мы будем собирать исходники Go, мы получим бинарный файл, который можно запустить везде (условно). То есть мы можем запустить сборку командной go build,  затем через COPY забрать полученный бинарник в образ, который весит меньше, чем golang:1.20.

Alpine - крайне легковесный образ из которого мы можем запустить бинарник. Alpine весит около 7Mb. Получается, что тяжелый компилятор Golang со всеми его библиотеками и утилитами нам нужен только при сборке приложения, а для запуска есть более оптимальные решения.

Поэтому во втором `Dockerfile` мы использовали Golang и собрали бинарный артефакт с именем `app` в первом этапе (**Stage**), а во втором этапе мы использовали легковесный `alpine`, чтобы запускать наше приложение.

![[Pasted image 20251002155903.png]]

Dokcer попросту не включает слои из первого этапа в финальный Образ. Поэтому мы получаем легковесный образ alpine с исполняемым файлом.

Запуск веб сервиса в Docker выглядит  так:
1) Запускаем контейнер с пробросом портов
```bash
docker run -d -p 8080:8080 go:v0.2
```

2) Проверяем наличие образа
```docker 
docker ps -a
```

Чтобы остановить контейнер
```bash
docker ps # получаем id
docker stop <id>
```

**Везде где это возможно стоит использовать multistage сборку**


### Минимизация количества слоёв
Команды FROM, COPY, RUN, AND - создают слои в Docker образе. Слои накапливаются, накладываются один на другой и требуют больше ресурсов. Это увеличивает размер финального Docker образа. Чем больше слоёв - тем больше данных хранится в Образе. Это замедляет сбору  и деплой.

Один из способов оптимизации - уменьшение количества слоёв.
Пример:
Этот Dockerfile создаёт три отдельных слоя
```
RUN apt-get update
RUN apt-get install ca-certificates
RUN update-ca-certificates
```

Оптимизированный вариант. Использование всех команд в одной строке при помощи &&. Это позволяет сократить количество слоёв до одного.
```dockerfile
RUN apt-get update && apt-get install ca-certificates && update-ca-certificates
```

Можно ещё оптимизировать, если удалить ненужные файлы после установки пакетов. Например
```dockerfile
RUN apt-get update && apt-get install -y ca-certificates && update-ca-certificates && rm -rf /var/lib/apt/lists/*
```


### Держите статичные слои как можно выше

Docker Образы имеют луковую архитектуру. Каждый новый слой накладывается на следующий. Слои создают команды `FROM`, `RUN`, `COPY` и `ADD`

Если изменится один из слоёв указанных в верхней части Dockerfile, все последующие слои будут пересобраны заново - Docker не может использовать кеш для этих слоёв. Это может значительно увеличить время сборки. Поэтому важно размещать команды, которые редко изменяются, как можно выше в Dockerfile. Это позволит Docker эффективнее использовать кеш и уменьшить время сборки образов.

Например
```Dockerfile
FROM python:3.9
COPY . /app
COPY requirements.txt /app/
RUN pip install -r /app/requirements.txt
```

В текущем примере, мы сначала создаем слой с исходниками (они меняются часто), и затем накладываем на него слой с requirements и установку зависимостей. Зависимости меняются значительно реже, чем исходный код, однако при таком `Dockerfile` скачивание всех зависимостей будет происходить при каждом изменении исходного кода..

Оптимизация
```Dockerfile
FROM python:3.9
COPY requirements.txt /app/
RUN pip install -r /app/requirements.txt
COPY . /app
```

В обновленном `Dockerfile` мы сначала копируем файл с зависимостями и устанавливаем их через `pip install`. Затем мы копируем исходный код, который меняется часто. Таким образом, если мы будем менять только исходный код, слои с зависимостями Docker возьмет из кэша.

## Registry

Registry - это хранилище Docker образов, в этой роли могут выступать различные сервисы, вроде Gitlab, Nexus, Harbor и многие другие.
Также есть и публичные Registry, например - Docker Hub.

Шаги для работы.
1. **Создайте аккаунт в Docker Hub** и создайте новый публичный репозиторий с именем `lesson1`
2. **Выполните вход в Docker Hub** из терминала. Введите команду:
```bash
    docker login
```

После этого вам будет предложено ввести логин и пароль от вашего Docker Hub аккаунта.
3. **Присвойте тег Вашему Docker Образу** в соответствии с именем Вашего репозитория:
```bash
    docker tag go:v0.2 <Ваш username в Докерхаб>/lesson1:v0.2
```

4. **Опубликуйте Образ в Docker Hub**. Для этого выполните команду:    
```bash
    docker push <Ваш username в Докерхаб>/lesson1:v0.2
```