## Контроллеры

Контроллеры в K8s позволяют автоматизировать управление приложениями, поддерживая их в желаемом состоянии. Без низ управление Подами было бы ручным и подверженным человеческим ошибкам.

Контроллеры в Kubernetes можно сравнить с контроллером освещения в системе умного дома. Стало темнее - включил лампочки, стало светло - выключил. Контроллеры приводят **текущее** состояние к **желаемому**.

В Kubernetes контроллеры управляют самыми разными ресурсами, часть из них прямо или косвенно управляет Подами и очень сильно облеyгчает нам жизнь. Один из таких контроллеров — Deployment.

**Deployment**
Это самый популярный контроллер в K8s, он используется для управления Подами и для поддержания их в требуемом  количестве. Мы описываем, в каком  состоянии мы хотим видеть приложение, а Deployment заботится о том, чтобы оно всегда соответствовало этому состоянию.

Создадим новый namespace
**Файлы в Listings/3. Kubernetes. Первые объекты и контроллеры/deployment_example**

1. Создадим namespace
```
apiVersion: v1
kind: Namespace
metadata:
  name: web-app-stage
```

2. Применим yaml-манифест
```
kubectl apply -f ns.yaml 
```


Теперь создадим новый деплоймент
1. Создадим файл deployment.yaml
```
apiVersion: apps/v1  
kind: Deployment  
metadata:  
  name: goapp-deployment  
  namespace: web-app-stage  
  labels:  
    app: goapp  
spec:  
  replicas: 3  
  selector:  
    matchLabels:  
      app: goapp  
  template:  
    metadata:  
      labels:  
        app: goapp  
    spec:  
      containers:  
        - name: web  
          image: ksxack/lesson1:v0.2  
          ports:  
            - containerPort: 8080```
```


Описание файла
* apiVersion - указывает версию API K8s, которую использует ресурс. Для deployment обычно указывают apps/v1

* kind - определяет тип ресурса - в данном случае Deployment

* metadata - метаданные ресурса, в нашем случае имя деплоймента, неймспейс - пространство имён и метки для группировки/фильтрации ресурсов (labels)

* spec - описание желаемого состояния деплоймента
	* replicas - количество запущенных копий подов
	* selector - определяет, какие поды управляются под этим Deployment
	* matchLabels - поды с указанным label (в нашем случае app: goapp) будут связаны с этим деплойментом
	
* template - шаблон для создания подов
	* metadata - метаданные для каждого пода
	* labels - метки пода (app: goapp), должны совпадать с selector.matchLabels
	
	* spec - спецификация контейнеров в поде
		* containers - список контейнеров
			* name - имя контейнера (в нашем случае web)
			* image - Docker образ контейнера
			* ports - настройки портов
				* containerPort - порт, который слушает контейнер

2. Применим манифест
```bash
kubectl apply -f deployment.yaml 
```

3. Проверим запустившиеся поды
```
kubectl -n web-app-stage get pods
NAME                                READY   STATUS    RESTARTS   AGE
goapp-deployment-58cdf45f9d-n2cgj   1/1     Running   0          10s
goapp-deployment-58cdf45f9d-wqwj4   1/1     Running   0          10s
goapp-deployment-58cdf45f9d-vh82m   1/1     Running   0          10s
```

И так, мы заказли у K8s 3 реплики нашего приложения, и он из создал.
Попробуем открыть две сессии в терминале, в одной попробуем удалить все поды, а в другой будем за ними наблюдать.
![[Pasted image 20251003221309.png]]

Мы увидим, что после удаления всех трёх подов K8s сразу создаст им замену.


**ВАЖНО! Deployment не контролирует поды!!!**

Дело в том, что контроллер Деплоймент, это контроллер контроллера ReplicaSet. 
![[Pasted image 20251003221547.png]]

`ReplicaSet` — очень простой контроллер. В его спеке также описывается количество реплик, и все, что он делает — поддерживает желаемое количество реплик. 
Deployment наследует весь функционал ReplicaSet и добавляет к этому функционалу дополнительные возможности: 

- Deployment создает ReplicaSet и хранит _историю релизов_. В старых ReplicaSet'ах он просто ставит количество реплик 0
- Благодаря истории релизов, Deployment позволяет делать _откаты_
- ReplicaSet и вовсе _не поддерживает обновления_, он только приводит количество Подов к желаемому состоянию
- Deployment поддерживает обновления и позволяет настраивать _стратегии обновления_ (рассмотрим через один шаг)

Ключевые моменты: 

- ReplicaSet контролирует количество Подов
- **Deployment контролирует ReplicaSet'ы**


## Deployment. Обновление приложения.

**RollingUpdate** - это стратегия обновления, которая позволяет плавно обновлять приложение, обеспечивая его доступность на протяжении  всего процесса обновления. Принцип работы заключается в том, что сначала создаются новые Поды с новой версией приложения, и только после их успешного запуска удаляются старые поды.

Пример использования 
**Файлы в Listings/3. Kubernetes. Первые объекты и контроллеры/deployment_rolling_update_example

```
apiVersion: v1  
kind: Namespace  
metadata:  
  name: rolling  
---  
apiVersion: apps/v1  
kind: Deployment  
metadata:  
  name: goapp-deployment  
  namespace: rolling  
  labels:  
    app: goapp  
spec:  
  replicas: 3  
  strategy:  
    type: RollingUpdate  
    rollingUpdate:  
      maxUnavailable: 1 # Не более одного недоступного Пода во время обновления  
      maxSurge: 1 # Одновременно можно создавать один новый Под  
  selector:  
    matchLabels:  
      app: goapp  
  template:  
    metadata:  
      labels:  
        app: goapp  
    spec:  
      containers:  
        - name: web  
          image: ksxack/lesson1:v0.2  
          ports:  
            - containerPort: 8080
```

- maxUnavailable — задает максимальное количество Подов, которые могут быть недоступны в процессе обновления (в процентах или абсолютном значении).
- maxSurge — указывает, на сколько новых Подов, контроллеру разрешено превышать запланированное количество (параметр replicas) во время обновления.

**Rollout**
Kubernetes также предоставляет удобные команды для управления процессом обновления, которые можно использовать для проверки статуса и отката.

- **Проверка истории деплоймента:**
  ```bash
    kubectl -n rolling rollout history deployment/goapp-deployment
  ```    
Показывает историю релизов с возможностью просмотреть изменения.

- **Откат к предыдущей версии:**
```bash    
kubectl -n rolling rollout undo deployment/goapp-deployment
```    
Эта команда откатывает Деплоймент на предыдущую версию в случае проблем с новой версией.

- **Плавный рестарт Подов:**    
	Мы можем рестартовать Поды, используя `kubectl delete pod`, т.к. Деплоймент сам их пересоздаст, однако  есть и более надежный механизм:     
```bash
    kubectl -n rolling rollout restart deployment/goapp-deployment    
```
Перезапускает все Поды плавно, без простоя


**Примечание**
Используя команду `kubectl get` мы можем получать ресурсы **любого вида**: 

```yaml
kubectl get ns
kubectl -n rolling get deployment
kubectl -n rolling get replicaset
kubectl -n rolling get pod
kubectl -n rolling get serviceaccount
kubectl get clusterrolebindings
```


## DaemonSet
![[Pasted image 20251003223521.png]]

Порой нам нужно задеплоить по одному Поду на каждую Ноду кластера. Обычно это связано с инфраструктурными кейсами, так, например, DaemonSet [node-exporter](https://github.com/prometheus-operator/kube-prometheus/blob/main/manifests/nodeExporter-daemonset.yaml) устанавливает на каждую Ноду кластера Под, который собирает метрики с этой Ноды. Эти метрики передаются в Prometheus или Victoria Metrics. Затем по полученным метрикам можно строить дашборды в Grafana и настраивать на них алерты.


## Job
Job — это контроллер, который запускает Pod для выполнения конкретной задачи, а затем завершает его работу. В отличие от Deployment, Job не пытается поддерживать постоянное количество реплик или заменять Pod'ы. Когда Pod завершает выполнение своей задачи, Job также завершает свою работу.

Job — одноразовая задачка. Вот пример Job с использованием Python для вывода числа Пи:
**Listings/3. Kubernetes. Первые объекты и контроллеры/job_example**

```
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-job
spec:
  template:
    spec:
      containers:
      - name: pi
        image: python:3.9
        command: ["python", "-c", "from math import pi; print(f'{pi:.20f}')"]
      restartPolicy: Never
  backoffLimit: 4
```


## CronJob
CronJob — это контроллер контроллера Job. CronJob запускает Job по расписанию, подобно cron в Linux. Это полезно для регулярных задач, таких как резервное копирование данных (например [бэкап Postgres](https://github.com/pagottoo/pgdump-k8s-cronjob/blob/master/cronjob.yaml)), отправка уведомлений или выполнение периодических вычислений. Периодичность запуска Job задается в CronJob в формате Cron ([crontab.guru](https://crontab.guru/))

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: pi-cronjob
spec:
  schedule: "*/2 * * * *"  # Запуск каждые 2 минуты
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: pi
            image: python:3.9
            command: ["python", "-c", "from math import pi; print(f'{pi:.20f}')"]
          restartPolicy: Never
```

## StatefulSet

Возможно, Вам никогда не понадобится описывать StatefulSet. Однако почти наверняка Вы много-много раз будете с ним работать (пользоваться). Поэтому этот шаг рассчитан на понимание и визуализацию, но не на практику.

**StatefulSet** — это контроллер для управления Подами, которым нужны следующие возможности:

- уникальные идентификаторы
- стабильные сетевые имена
- стабильное постоянное хранилище для каждого Пода

Исходя из названия, можно догадаться, что StatefulSet применяется там, где надо сохранять состояние: 

- **Базы данных** (MySQL, PostgreSQL, Cassandra) 
- **Кэш-системы** (Redis, Zookeeper) 
- **Брокеры сообщений** (RabbitMQ, Apache Kafka)
- **Файловые системы и хранилища** (Minio, Nexus)

### **StatefulSet vs. Deployment**

Давайте сравним StatefulSet и Deployment (популярный вопрос на собеседованиях)

**1. Порождение объектов:**

![Deployment vs. StatefulSet](https://ucarecdn.com/8725a040-1916-4f71-a3c9-ea46e11f2845/)

- Deployment порождает ReplicaSet, который контролирует Поды
- StatefulSet напрямую управляет Подами, обеспечивая их порядок и идентичность

**2. Управление Подами:**

![Deployment vs. StatefulSet](https://ucarecdn.com/d50e1d0e-bd10-40d2-9f9e-a100c870086f/)

- **Deployment** не гарантирует порядок и уникальность Подов. Поды могут запускаться в любом порядке, и их имена не сохраняются при пересоздании
- **StatefulSet** гарантирует уникальные имена Подов и их запуск в строгом порядке (по порядковым номерам). Это важно для кластеризированных приложений

**3. Монтирование хранилища:**

![Deployment vs. StatefulSet](https://ucarecdn.com/b1ecbc78-9e61-4215-add6-a0a7e170b991/)

- В Deployment все Поды могут монтировать **один и тот же PV (Persistent Volume)**, если он указан
- В StatefulSet каждый Под монтирует **свой собственный PV**, что важно для репликации данных в случае stateful-приложений (например, БД)

**4. Перезапуск Подов:**

- Deployment перезапускает Поды в любом порядке при обновлениях или сбоях
- StatefulSet перезапускает Поды в строгом порядке (последовательно)

**5. Обновления:**

- Deployment имеет возможность гибко обновлять наше приложение (**rolling updates**), но не учитывает порядок Подов
- StatefulSet обновляет Поды строго последовательно, начиная с самого старшего, `pod-2 -> pod-1 -> pod-0`

**6. Сетевые идентификаторы:**

- Deployment не обеспечивает постоянных сетевых идентификаторов для Подов
- StatefulSet назначает Подам постоянные DNS-имена, чтобы каждый Под можно было адресовать по имени. Для точечного доступа к конкретному Поду можно использовать **Headless Service**