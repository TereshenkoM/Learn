
Что такое Kubernetes (сокращённо k8s) - это система управления контейнерами. Часто можно услышать термин "оркестратор".
K8s был разработан Google на основе их внутренней системы управления контейнерами под названием **Borg**. В 2014 году Google открыл проект Kubernetes для широкого круга пользователей, компания сделала его Open Source.
Kubernetes предоставляет стандартизированный и богатый набор API, с помощью которого можно эффективно управлять приложениями и их окружением.
Он упрощает взаимодействие **Нодами (серверами)** и **Подами (приложениями)**, обеспечивая высокий уровень контроля и надежности.

**Термины**


**Node в Kubernetes(K8s)**- также называемый рабочим узлом, — это физическая или виртуальная машина (сервер), которая служит основной рабочей единицей в кластере

**Воркер-нода (worker node)** — это рабочий узел в кластере Kubernetes, на котором непосредственно запускаются контейнеры с вашими приложениями. Если представить кластер как фабрику, то мастер-нода (control plane) — это управляющий офис, а воркер-ноды — это цеха, где происходит вся производственная работ

**По сути воркер-нода и нода - одно и тоже.**

**Pod в Kubernetes** (K8s)- это минимальная единица, в составе Пода может быть несколько Контейнеров. Подами можно управлять разными способами, об этом поговорим в дальнейшем.

**Кластер в Kubernetes (K8s)** — это группа серверов (узлов), которые работают вместе как единая система для запуска и управления контейнеризированными приложениями

**Деплоймент (Deployment)** в Kubernetes — это контроллер высшего уровня, который управляет жизненным циклом приложений, обеспечивая их развертывание, обновление, масштабирование и откат.

## Что позволяет делать K8s?
* Деплой приложения - позволяет запускать контейнеризированные приложения в кластере
* Управление репликами - автоматически поддерживает нужно количество экземпляров приложения для повышения отказоустойчивости
* Ограничение ресурсов - позволяет задавать лимиты на использование ресурсов, такие как CPU и память
* Масштабирование - автоматическое увеличение или уменьшение количества реплик в зависимости от нагрузки
* Балансирование нагрузки - распределение входящего трафика между репликами приложения
* Управление доступами - позволяет настраивать права пользователей и сервисов на взаимодействие с кластером
* Настройка сетей - предоставляет возможность конфигурировать маршрутизацию и доступы для приложений по сети
* Сине-зелёные деплои - развёртывание новой версии приложения параллельно со старой с возможностью быстрого отката
* Rollback - позволяет откатываться на предыдущую версию в случае проблем с новым релизом
* Канареечные релизы - постепенное развёртывание, где на новую версию направляется только часть трафика
* Стратегии обновлений - настройка  стратегий обновления приложений
* Health-check - проверка состояния приложения и перезапуск реплик, если они работают некорректно
* Автоматический перезапуск - перезапуск приложения в случае его падения или некорректной работы

## Инфраструктурная платформа
Можно ли считать Kubernetes универсальным решением для всех задач? Конечно, нет.

Несмотря на все преимущества, ванильного Kubernetes недостаточно для полноценной работы в производственной среде. Чтобы создать надежную инфраструктуру на базе Kubernetes, потребуется интеграция множества других инструментов и сервисов. В каждом коллективе определяют свой набор инструментов, мы попробуем показать "среднюю температуру по больнице":

- **Мониторинг** (Victoria Metrics / Prometheus + Grafana) — для наблюдения за состоянием k8s и приложений
- **Логирование** (Elasticsearch/OpenSearch/Loki, Fluentd/Vector, Kibana) — для централизованного сбора, хранения и анализа логов
- **Репозитории кода** (Gitlab) — для хранения и управления исходным кодом
- **CI/CD системы** (Gitlab CI, Jenkins, Argo CD) — для автоматизации процесса сборки и деплоя приложений
- **Хранилище Docker Образов** (Harbor, Nexus) — для хранения и версионирования Образов
- **Sentry** — для мониторинга ошибок и трекинга исключений (exception) в приложениях
- **Ingress Nginx** — для управления входящими HTTP(S)-запросами и маршрутизации их к сервисам внутри кластера
- **Cert Manager** — для автоматической генерации и управления SSL-сертификатами
- **Вспомогательные утилиты**  — все, что улучшает жизнь. Например [k8s-pinger](https://github.com/MadEngineX/k8s-pinger)/[Goldpinger](https://github.com/bloomberg/goldpinger) для проверки доступности Нод, [Dex](https://github.com/dexidp/dex)/[kubelogin](https://github.com/int128/kubelogin) для настройки доступа в контур по OIDC

## Проблемы K8s
1. Эфемерность (недолговечность) подов - поды в K8s считаются временными и могут перезапускаться или перемещаться в другие ноды. Для stateless-приложений (stateless == без сохранения состояния) это обычно не проблема, но для statefull-приложений (statefull == с сохранением состояния), такими как БД, нужно обеспечить надёжное хранение данных и  настроить механизмы восстановления состояния, что увеличивает сложность.

2. Ресурсоёмкость - K8s может требовать достаточно много ресурсов.Виртуальные машины для Нод, подсистемы для управления, балансировки и хранения данных, Контейнеры с приложениями — все эти компоненты требуют значительных вычислительных и сетевых ресурсов.

3. Сложность -  K8s имеет высокую степень сложности, особенно на этапе первоначальной настройки. Даже базовые задачи, такие как настройка кластера или деплой приложения, требуют глубокого понимания множества компонентов и терминов. Kubernetes имеет высокий порог вхождения.
## Архитектура кластера K8s

Архитектуру K8s-кластера можно поделить на два уровня:
* Control Plane (управляющий уровень)
* Data Plane (уровень выполнения)

**Control Plane** - отвечает за управления состоянием кластера
**Data Plane** - обеспечивает работу приложений на воркер-нодах.

Проще говоря, Control Plane - мозги и сердце, Data Plane - это место, где живут приложения.

**Компоненты Control Plane**
1. kube-api-server
	API-сервер - это центральная точка взаимодействия с кластером. Все команды, как от пользователей, так и от внутренних компонентов K8s, поступают через kube-api-server, который предоставляет полный набор API для управления состоянием кластера. Утилита kubectl также общается с кластером через kube-api-server.

![[Pasted image 20251002170253.png]]

2.  kube-sheduler
	Scheduler отвечает за распределение Подов, которые ещё не назначены на Воркер Ноды. Он анализирует ресуры Нод и выбирает подходящие для запука Подов, основываясь на критериях, таких как количество доступной памяти и процессорных ядер.

3. kube-contoller-manager
	Контроллер менеджер управляет контроллерами - программами, которые следят за состоянием объектов кластера (например, за состоянием Подов). Все контроллеры взаимодействуют с API-сервером, подписываясь на события, связанные с их ресурсами.

4. etcd
	Это распределённое key-value хранилище, где сохраняется вся информация о состоянии кластера. etcd - критически важный компонент, поскольку в нём лежит вся конфигурация и текущее состояние K8s. Весь кластер можно восстановить, имея резервную копию etcd. Также etcd является независимым Open Source продуктом, то есть etcd является независимым Open Source продуктом, то есть это не часть проекта K8s.

**Компоненты Data Plane**

1. kubelet
	Kubelet - агент на каждой воркер-ноде, который отвечает за управление подами. Он получает инструкцию от API-сервера и следит за тем, чтобы Контейнеры в Подах запускались и  корректно работали.

 2. kube-proxy
	Kube-proxy управляет сетевым трафиком от кластера. Он настраивает правила маршрутизации и сетевых подключений, что позволяет Подам взаимодействовать друг с другом и получать доступ к внешним сетям. Это ключевой компонент для реализации сервисов K8s, обеспечивающий корректное управление трафика нужным Подам.

3. Runtime (среда выполнения контейнеров)
	Runtime отвечает за непосредственно выполнение Контейнеров. Это может быть Docker (в старых версиях K8s), CRI-O, containerd или другая совместимая среда выполнения. Runtime взаимодействует с контейнерными Образами и запускает их на Воркер Нодах.


**Ключевые моменты**
Есть фраза, что K8s - это пять бинарей:
* kube-api-server
* kube-scheduler
* kube-controller-manager
* kubelet
* kube-proxy

2) etcd — это отдельный Open Source проект, который как и Kubernetes поддерживается фондом CNCF


## Установка K8s локально

Установка High Available Kubernetes требует большой подготовки и как минимум 4 ВМ. Для обучения K8s это не сильно нужно, можно всё сделать локально.

Мы будем использовать **Minikube** — это инструмент, который разворачивает Kubernetes на одной Ноде, что идеально подходит для тестирования, экспериментов и обучения. Ссылка  на доку - https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Fx86-64%2Fstable%2Fdebian+package

Также мы будем использовать **kubectl**. Это главный инструмент для работы в K8s, по сути бинарная уилита. Инструкция по установке - https://kubernetes.io/ru/docs/tasks/tools/install-kubectl/

## Подходы к работе с K8s

При работе с K8s есть два подхода к работе:
* императивный
* декларативный


**Императивный подход**
Подразумевает, что мы напрямую говорим системе, что именно должно быть сделано в данный момент. Вы "говорите" K8s выполнить конкретное действие. Например сказать создать деплоймент определённым образом
```bash
kubectl create deployment first-deployment  --image=ksxack/lesson1:v0.2 
```

В этом примере мы **императивно** создаем ресурс Деплоймент `first-deployment`, который будет использовать Образ `ksxack/lesson1:v0.2` для запуска приложения. При этом Kubernetes немедленно выполнит наше указание
Этот способ полезен, когда нужно быстро протестировать что-то или сделать одноразовую операцию. Однако, императивный подход не оставляет после себя описаний конфигурации, что может усложнить управление инфраструктурой в долгосрочной перспективе.


**Декларативный подход**
Декларативный подход предполагает, что мы описываем желаемое состояние системы в виде YAML-манифестов. Мы "говорим" Kubernetes, какое состояние мы хотим получить, и он сам подгоняет текущее состояние под описанное.
Пример
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: declarative-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: goapp
  template:
    metadata:
      labels:
        app: goapp
    spec:
      containers:
      - name: goapp
        image: ksxack/lesson1:v0.2
        ports:
        - containerPort: 8080
```

Этот файл описывает деплоймент `declarative-deployment`, который запускает один экземпляр нашего приложения. Чтобы применить это описание ресурса, надо использовать команду

```bash
kubectl apply -f deployment.yaml
```

`kubectl` прочитает  YAML-манифесты, переведет их в JSON и отправит запрос в **api-server**. Kubernetes приведет текущее состояние системы в соответствие с описанным, и в нашем кластере появится ресурс Деплоймент:
```
kubectl get deployments
```

Немного забегая вперед, Деплойменты контролируют Поды, так что мы можем проверить еще и наличие Подов:
```bash
kubectl get pod
```

**Лучше выбирать декларативный подход**
Использование декларативного подхода позволяет сохранять описание инфраструктуры в виде кода, что значительно упрощает управление и автоматизацию. Придерживаясь принципов _Infrastructure as Code (IAC)_, Вы всегда будете знать текущее состояние системы и сможете отслеживать изменения через Git.

IAC - важнейшая практика DevOps, ее игнорирование ставит под удар вcю [пользу](https://www.puppet.com/resources/history-of-devops-reports#2016) от внедрения DevOps практик и инструментов.

## Первые объекты в K8s

### Namespace
Позволяет логически разделять и группировать ресурсы, как поды с приложениями. Это удобный способ организации приложения, особенно в случае, если у нас много команд, работающих над разными проектами, если нужно разделить среду на разные окружения.
![[Pasted image 20251002183333.png]]
По умолчанию namespace = default

**Все файлы в Listings/3. Kubernetes. Первые объекты и контроллеры**

**Работа с Namespace**

1. Создаём файл `ns.yaml`
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: examples-dev
```

2. Применяем данный манифест в K8s 
```bash
kubectl apply -f ns.yaml
```

3. Проверим namespace
```yaml
kubectl get ns
```

Команда выведет все существующие namespace
```
> kubectl get ns
NAME              STATUS   AGE
default           Active   17m
examples-dev      Active   33s
kube-node-lease   Active   17m
kube-public       Active   17m
kube-system       Active   17m
```

4. Удалим namespace
```yaml
kubectl delete -f ns.yaml 
```

Неймспесы (как и другие ресурсы) можно создавать/менять/удалять императивно:
1. Создать ещё один namespace
```bash
kubectl create ns examples-dev2
```

2. Убедитесь, что namespace создан
```bash
kubectl get ns
```

3. Удалите namespace
```bash
kubectl delete ns examples-dev2
```

**Зачем использовать namespace?**

1. Организация управлением. Разделение доступа позволяет избежать лишних доступов или изменения ресурсов.
2. Управление доступом. Неймспейсы позволяют управлять правами доступа.
3. Безопасность. Если разделить приложения по Неймспейсам, то можно существенно повысить их безопасность.

### Pod

Часто Pod путают с контейнером. Под - это набор из Контейнеров. Чаще всего в поде находится один контейнер, но может быть и больше.
Под - это минимальная единица, которой управляет K8s. Физически Под представляет из себя запущенные контейнеры, объединённые в сетевой Linux namespace (не K8s namespace). Контейнеры в одном поде могут обмениваться файлами  через общий том (volume). Процессы Контейнеров при этом всё такие же изолированные, хотя контейнеры в поде и сильно связаны, некоторые этапы своего жизненного цикла Контейнеры проходят независимо друг от друга.

Kubernetes Namespace — это логическая абстракция самого Kubernetes, а Под (Контейнеры и Linux неймспейсы) мы можем увидеть на Ноде. Поды в одном Неймспейсе могут быть с разных Нод, но Контейнеры в одном Поде только на одной Ноде.
![[Pasted image 20251002185016.png]]

**Пример создания pod**
1. Настроим Неймспейс **web-app-dev**. Создайте файл `web-app-ns.yaml`    
```yaml
    apiVersion: v1
    kind: Namespace
    metadata:
      name: web-app-dev
```
2. Задеплойте Неймспейс: 

   ```yaml
    kubectl apply -f web-app-ns.yaml 
    ```

3. Cоздайте файл `pod.yaml`. Используйте свой Образ из урока про Docker, указав его в разделе `image` , т.к. архитектура моего процессора и Вашего может отличаться
```yaml
apiVersion: v1  
kind: Pod  
metadata:  
  name: simple-web  
  namespace: web-app-dev  
spec:  
  containers:  
    - name: web  
      image: ksxack/lesson1:v0.2  
  
      imagePullPolicy: Always  
      ports:  
        - name: web  
          containerPort: 8080  
          protocol: TCP
```

Пояснение к манифесту
```yaml
kind                  ## вид ресурса, мы уже знаем 2 вида ресурсов k8s: Namespace, Pod

metadata.name         ## имя Пода, в данном случае это simple-web.

metadata.labels       ## ярлыки (или метки) для пода, в этом случае ярлык app=goweb можно использовать для поиска или группировки подов.

spec.containers.name  ## имя контейнера внутри пода. В поде может быть несколько контейнеров, здесь контейнер называется web.

spec.containers.image ## образ контейнера, который будет использоваться. Замените значение на свой образ, созданный в предыдущих уроках.

spec.containers.ports ## указывает порт 8080, который будет открыт для доступа извне.

spec.containers.imagePullPolicy ## настройка политики загрузки образов в Kubernetes.Всегда загружает образ заново при создании или перезапуске пода
Проверяет registry на наличие новой версии образа с тем же тегом
Гарантирует свежесть образа, но может замедлить запуск
```

4. Задеплойте Под с помощью следующей команды
```
kubectl apply -f pod.yaml
```

5. Проверьте, что под в статусе Running
```
kubectl -n web-app-dev get pods 

## флаг -n нужен для указания Неймспейса 
```

6. Теперь проверим, что приложение из Пода работает корректно. Для этого мы прокинем порт из Пода к себе на комп
```bash
kubectl -n web-app-dev port-forward pod/simple-web 8080:8080
```

7. Теперь мы можем открыть бразуер и перейти по ссылке [http://localhost:8080/Kubernetes](http://localhost:8080/Kubernetes)Должны увидеть HTTP ответ:
```
Hi there, I love Kubernetes!
```


## Взаимодействие с подами

**Просмотр информации о поде**

Команда `kubectl get pods -n web-app-dev` - даёт базовую информацию о поде. Вроде
- список Подов в Namespace
- количество Контейнеров в статусе Ready  
- статусы Подов
- количество рестартов
- возраст Подов

Чтобы узнать больше можно добавить флаги:
* `-o wide` - это флаг который позволяет понять, на какой ноде находится под (в minikube бесполезно)
```bash
kubectl get pods -n web-app-dev simple-web -o wide
```
* `-o yaml` - позволяет получить yaml манифест пода
```
kubectl get pods -n web-app-dev simple-web -o yaml
```

* `--show-labels` — добавляет к выводу лейблы, которыми помечен Под

**Просмотр описания пода**
Чтобы получить более детальную информацию о поде используйте команду `describe`
```bash
kubectl describe pod -n web-app-dev simple-web
```

Эта команда покажет события (events), связанные с подом, детали по Контейнерам, время старта Пода и Контейнеров, количество рестартов, причины рестартов, QoS-класс и другую информацию.

**Просмотр логов пода**
Логи - важнейший инструмент для анализа. Чтобы посмотреть логи
```bash
kubectl -n web-app-dev logs simple-web
```
Также к команде можно добавить флаг -f, чтобы смотреть логи в режиме реального времени и флаг -с, если нужно указать имя Контейнера (когда их несколько).

**Проброс портов пода**
Когда возникает вопрос о доступности приложения или проблемах с сетевым взаимодействием, проброс портов может сильно помочь. Если Вы не знаете откуда поступают таймауты — с балансировщика, или же проблема с самим приложением, то простейший способ проверить, что приложение работает корректно — это пробросить порт Пода на локальный хост

```
kubectl -n web-app-dev logs simple-web
```

**Подключение к Shell-оболочке контейнера внутри Пода**

Иногда требуется зайти внутрь контейнера, чтобы проверить файлы или сетевой доступ.
```
kubectl exec -it -n web-app-dev pod/simple-web -c web -- sh
```

Это откроет доступ к терминалу контейнера web внутри под simple-web.

**Просмотр и утилизация ресурсов**
Для мониторинга использования ресурсов
```
kubectl top pods -n web-app-dev
```

По умолчанию может не работать в Minikube, так как требует метрик-сервера
```
minikube addons enable metrics-server
```


**Удаление poda**
```
kubectl delete pod -n web-app-dev simple-web
```

