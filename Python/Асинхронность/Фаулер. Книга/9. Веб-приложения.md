Вопросы
*  Создание веб-приложений с помощью aiohttp
* Интерфейс асинхронного серверного шлюза (ASGI)
* Создание веб-приложений ASGI с помощью Starlette
* Асинхронные представления Django

## Разработка REST API С помощью 

### Что такое REST?
Аббревиатура REST - represantional state transfer (передача представимых состояний).
Основная концепция REST - ресурс. Как правило ресурс - всё, что можно назвать именем существительным: заказчик, продукт и т.д.


## Основы разработки серверов на базе aiohttp

AIOHTTP представляет функциональность веб-сервера в модуле web. Импортировав его, мы можем определить эндпоинты. С помощью класса RouteTableDef, который предполагает декоратор, позволяющий задать тип запроса и строку с именем эндпоинта.

Также нужно запустить и само приложение, которое будет обслуживать эндпоинты. Для этого создадим экземпляр класса Application, добавив в него маршруты из RouteTableDef.

```python
from aiohttp import  web  
from datetime import datetime  
from aiohttp.web_request import Request  
from  aiohttp.web_response import Response  
  
  
routes = web.RouteTableDef  
  
@routes.get('/time')  
async def time(request: Request) -> Response:  
    today = datetime.today()  
    result = {  
        'month': today.month,  
        'day': today.day,  
        'time': str(today.time())  
    }  
  
    return  web.json_response(result)  
  
app = web.Application()  
app.add_routes(routes)  
web.run_app(app)
```

В параметре request указывается информация о запросе: тело, строка запроса и т.д.

## Подключение к БД и получение результатов

Чтобы посмотреть на механизм подключения к БД в aiohttp сделать REST с доступом к БД из главы 5.

Так как приложение асинхронное, то имеет смысл создать не одно подключение, а их пул. Вопрос: а где должен быть пул, чтобы эндпоинты могли легко им воспользоваться.

И вообще, где хранить разделяемые данные?

Для хранения разделяемых данных можно воспользоваться классом Application (его можно использовать в качестве словаря.)

```python
app['shared_dict'] = {'key': 'value'}
```

Далее нужно решить, как обращаться к приложению из маршрута. Каждый запрос (Request), передаваемый маршруту, содержит ссылку на экземпляр приложения в поле app, что позволяет легко обратиться к разделяемым данным.

Создавать пул подключений лучше там, где находится этот экземпляр приложения - затруднительно, потому что это происходит вне сопрограммы, т.е. мы не сможем использовать await.

В aiohttp есть обработчик сигнала on_startup - используется при инициализации. Можно считать, что это список сопрограмм, которые выполняются при запуске приложения.

Аналогично работает clean_up - вызовы корутин при завершении работы приложения.

И так, напишем программу, которая будет создавать пул подключений к БД о товарах.

```python
import asyncpg  
from aiohttp import web  
from aiohttp.web_app import Application  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
from asyncpg import Record, Pool  
from asyncpg.pool import Pool  
  
routes = web.RouteTableDef()  
  
DB_KEY: str = 'database'  
  
  
async def create_database_pool(app: Application) -> None:  
    print('Создаётся пул подключений')  
    pool: Pool = await asyncpg.create_pool(  
        host = '127.0.0.1',  
        port = 5432,  
        user = 'postgres',  
        password = 'postgres',  
        database = 'products',  
        min_size = 6,  
        max_size = 6  
    )  
  
    app[DB_KEY] = pool  
  
  
async def destroy_database_pool(app: Application) -> None:  
    print('Уничтожается пул подключений')  
    pool: Pool = app[DB_KEY]  
    await pool.close()  
  
  
@routes.get('/brands')  
async def brands(request: Request) -> Response:  
    connection: Pool = request.app[DB_KEY]  
    brand_query = '''  
        SELECT brand_id, brand_name        FROM brand    '''    results: list[Record] = await connection.fetch(brand_query)  
    result_as_dict: list[dict] = [dict(brand) for brand in results]  
  
    return web.json_response(result_as_dict)  
  
  
app = web.Application()  
app.on_startup.append(create_database_pool)  
app.on_cleanup.append(destroy_database_pool)  
  
app.add_routes(routes)  
web.run_app(app)
```

Далее реализуем два эндпоинта:

* Для получения конкретного товара (GET)
* Для получения нового товара (POST)

GET
```python
@routes.get(f'/products/{id}')  
async def get_product(request: Request):  
    try:  
        # Получаем параметр из id  
        str_id = request.match_info['id']  
        product_id = int(str_id)  
  
        query = \  
        """  
            SELECT                
	            product_id,  
                product_name,     
			   brand_id           
			 FROM product          
			  WHERE product_id = 1       
		 """  
        connection: Pool = request.app[DB_KEY]  
        results: Record = await connection.fetchrow(query, product_id)  
  
        if results:  
            return web.json_response(dict(results))  
        else:  
            raise web.HTTPNotFound()  
    except ValueError:  
        raise web.HTTPBadRequest()
```


POST
```python
@routes.post('/product')  
async def create_product(request: Request):  
    PRODUCT_NAME = 'product_name'  
    BRAND_ID = 'brand_id'  
  
    # Проверяем не пусто ли тело запроса  
    if not request.can_read_body:  
        raise web.HTTPBadRequest()  
  
    body = await request.json()  
  
    if PRODUCT_NAME in body and BRAND_ID in body:  
        db = request.app[DB_KEY]  
        await db.execute('''  
            INSERT INTO product(                
	            product_id,                
	            product_name,                
	            brand_id            )            
	        VALUES(DEFAULT, $1, $2)     
		''', body[PRODUCT_NAME], int(body[BRAND_ID]))  
  
        return web.Response(status=201)  
    else:  
        raise web.HTTPBadRequest()  
```

Курл запрос на ручку
```
curl -i -d '{"product_name":"product_name", "brand_id":1}'
localhost:8080/product
HTTP/1.1 201 Created
Content-Length: 0
Content-Type: application/octet-stream
Date: Tue, 24 Nov 2020 13:27:44 GMT
Server: Python/3.9 aiohttp/3.6.2
```

## Асинхронный интерфейс серверного шлюза (ASGI)


## Сравнение WSGI и ASGI

Стандарт WSG (Web Server Gateway Interface)) вырос на фрагментированном поле каркасов веб-приложений. Раньше выбор каркаса ограничивал множество пригодных для его использования веб-серверов, поскольку между теми и другими не было стандартизированного интерфейса. WSGI - решил эту проблему, специфицировав простой API для взаимодействия веб-серверов и написанных на Python каркасов.

**Однако с асинхронными нагрузками WSGI не работает. Также WSGI поддерживает только жизненные циклы запрос-ответ, т.е. не будет работать с протоколами долговременных подключений, например WebSockets. ASGI - исправляет ситуацию путём перепроектирования  API под использование сопрограмм.**

Сравнение функций application

WSGI
```python
def application(env, start_response):
	start_response('200 OK', [('Content-Type','text/html')])
	return [b"WSGI hello!"]
```

ASGI
```python
async def application(scope, receive, send):
	await send({
	'type': 'http.response.start',
	'status': 200,
	'headers': [[b'content-type', b'text/html']]
	})
	await send({'type': 'http.response.body', 'body': b'ASGI hello!'})
```

ASGI-функция application принимает три параметра:
* словарь score
* корутину receive
* корутину send

которые служат для отправки и приёма для данных. В примере мы сначала отправляем заголовки, а потом тело.

Одна из самых популярных реализаций ASGI сервера - Uvicorn. Он построен поверх uvloop и httptools - написанных на C быстрых реализаций цикла событий asyncio (на самом деле не обязательно использовать цикл событий, входящий в состав asyncio, но об этом позже) и разбора HTTP.


## Реализация ASGI в Starlette

Starlette - небольшой ASGI совместимый каркас. Посмотрим как реализовать эндпоинты WebSocket и REST.

### Эндпоинт REST в Starlette

Реализуем эндпоинт /brands из предыдущего раздела про aiohttp.

```python
import asyncpg  
from asyncpg import Record  
from asyncpg.pool import Pool  
from starlette.applications import Starlette  
from starlette.requests import Request  
from starlette.responses import JSONResponse, Response  
from starlette.routing import Route  
  
  
async def create_database_pool():  
    pool: Pool = await asyncpg.create_pool(  
        host='127.0.0.1',  
        port=5432,  
        user='postgres',  
        password='postgres',  
        database='products',  
        min_size = 6,  
        max_size = 6  
    )  
  
    app.state.DB = pool  
  
async def destroy_database_pool():  
    pool = app.state.DB  
    await pool.close()  
  
  
async def brands(request: Request) -> Response:  
    connection: Pool = request.app.state.DB  
    brand_query = '''  
        SELECT brand_id, brand_name        
        FROM brand    
	'''    
    results: list[Record] = await connection.fetch(brand_query)  
    result_as_dict: list[dict] = [dict(brand) for brand in results]  
  
    return JSONResponse(result_as_dict)  
  
app = Starlette(  
    routes=[Route('/brands', brands)],  
    on_startup=[create_database_pool],  
    on_shutdown=[destroy_database_pool]  
)
```

Протестируем производительность при помощи wrk (https://github.com/wg/wrk).

```
Running 30s test @ http://localhost:8000/brands
```

```
Running 30s test @ http://localhost:8000/brands
  2 threads and 200 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    72.31ms   27.52ms 378.95ms   84.55%
    Req/Sec     1.40k   154.83     1.60k    83.67%
  83657 requests in 30.08s, 0.90GB read
Requests/sec:   2781.44
Transfer/sec:     30.62MB
```

 За 30 секунд и из 2 потоков мы обработали 2781 запрос в секунду! Быстрее, чем в aiohttp и тем более Flask.


### WebSockets и Starlette

Традиционно клиент посылает серверу HTTP-запрос, сервер возвращаем ответ, на это всё. Но что если мы хотим построить страницу, которая обновляется сама, без участия пользователя. Например: отображать счётчик посетителей на сайте.

Для этого есть веб-сокеты. Вместо цикла запрос-ответ мы создаём постоянный сокет. А затем просто пересылаем данные через него. Сокет двунправленный, т.е. отправку может инициализировать как клиент, так и сервер.

![[Pasted image 20250724190621.png]]

Starlette имеет встроенную поддержку веб-сокетов. Построим эндпоит типа WebSocket. Но для начала установим websockets.
```
pip install websockets
```

Пример работы websockets в starletee
```python
import asyncio  
from typing import Any  
  
from starlette.applications import Starlette  
from starlette.endpoints import WebSocketEndpoint  
from starlette.routing import WebSocketRoute  
from starlette.websockets import WebSocket  
  
  
class UserCounter(WebSocketEndpoint):  
    encoding = 'text'  
    sockets = []  
  
    # Добавить клиента при подключении и сообщить остальным новое значение счётчика  
    async def on_connect(self, websocket: WebSocket) -> None:  
        await websocket.accept()  
        UserCounter.sockets.append(websocket)  
        await self._send_count()  
  
    # Удалить клиента при подключении и сообщить остальным новое значение счётчика  
    async def on_disconnect(self, websocket: WebSocket, close_code: int) -> None:  
        UserCounter.sockets.remove(websocket)  
        await self._send_count()  
  
    async def on_receive(self, websocket: WebSocket, data: Any) -> None:  
        pass  
    # Сообщить всем клиентам сколько сейчас пользователей подключено.  
    # Если во время отправки исключение, удалить соответсвующий клиент из списка    async def _send_count(self):  
        if len(UserCounter.sockets) > 0:  
            count_str = str(len(UserCounter.sockets))  
            task_to_socket = {  
                asyncio.create_task(websocket.send_text(count_str)): websocket  
                for websocket in UserCounter.sockets  
            }  
  
            done, pending = await asyncio.wait(task_to_socket)  
  
            for task in done:  
                if task.exception():  
                    if task_to_socket[task] in UserCounter.sockets:  
                        UserCounter.sockets.remove(task_to_socket[task])  
  
app = Starlette(routes=[WebSocketRoute('/counter', UserCounter)])
```

HTML код с подключением через JS
```html
<!DOCTYPE html>  
<html lang="ru">  
<head>  
<title>Starlette Web Sockets</title>  
<script>  
    document.addEventListener("DOMContentLoaded", () => {  
    let socket = new WebSocket("ws://localhost:8000/counter");  
    socket.onmessage = (event) => {  
    const counter = document.querySelector("#counter");  
    counter.textContent = event.data;  
    };  
});  
</script>  
</head>  
<body>  
<span>Подключено пользователей: </span>  
<span id="counter"></span>  
</body>  
</html>
```