Вопросы:
* Что такое asynico и какие преимущества она даёт.
* Конкурентность, параллелизм, потоки и процессы
* Глобальная блокировка интерпретатора (GIL) и создаваемые её проблемы для конкурентности
* Как неблокирующие сокеты позволяют добиться конкурентного выполнения в одном потоке
* Начала конкурентности на основе цикла событий


В любом синхронном приложении код выполняет последовательно (следующая строка выполняется после завершения предыдущей). Это ведёт к проблемам с производительностью и отзывчивостью, поскольку в каждый момент времени может выполнятся только одна операция.

Один из способов решения проблемы - ввести в программу **конкурентность**.
**Конкурентность позволяет одновременно выполнять более одной задачи.**

В Python есть несколько способов организовать такую конкурентность. Одним из них является библиотека асинхронного ввода-вывода **asyncio**. Она позволяет производить сразу несколько операций ввода-вывода.

Появилась впервые в Python 3.4, по сути включала несколько декораторов и синтаксис генератора yield from **для определения сопрограмм**.

**Сопрограмма - это метод, который можно приостановить если имеется другая, потенциально длительная задача, а затем возобновить, когда она завершится.**

Библиотека asyncio исполняет сопрограммы асинхронно, пользуясь моделью конкурентности, получившей название **однопоточный цикл событий.**
Она способна выполнять и операции других типов (по мимо операций ввода-вывода) благодаря взаимодействию с механизмом многопроцессности и многопоточности. Поэтому синтаксис async и await можно использовать в сочетании с процессами и потоками, что делает соответствующий код понятнее. Следовательно библиотека пригодна не только для организации конкурентного ввода-вывода, но и для выполнения счётных задач, активно использующих процессор.

## Что такое ограниченность производительностью ввода-вывода и ограниченность быстродействием процессора?

Говоря, что операция ограничена производительностью ввода-вывода или быстродействием процессора, мы имеем в виду фактор, препятствующий более быстрой работе.

Счётные операции в Python - это обычно вычисления и обработка данных (ограничивается быстродействием процессора). Примерами может служить вычисления цифр числа Пи или применение бизнес-логики к каждому элементу словаря.

В случае операции, ограниченной вводом-выводом, мы тратим большую часть времени на ожидание ответа от сети или другого устройства. Примерами могут служить запрос к веб-сервису или чтение файла с жёсткого диска.

## Конкурентность, параллелизм и многозадачность

### Конкурентность

Говоря, что две задачи выполняются конкурентно,мы имеем ввиду, что они работают в одно и то же время. 

### Параллелизм
Хотя конкурентность и подразумевает, что несколько задач выполняются одновременно, это ещё не значит, что они работают параллельно. Говоря о параллельной работе, мы имеем ввиду, что две задачи или более не просто чередуются, а выполняются строго в одно и то же время.

**В случае конкурентности несколько задач работает в течение одного промежутка времени, но только одна активна в каждый момент. В случае параллелизма несколько задач активно одновременно**

Говоря языком приложений, исполняемых операционной системой. Пусть работают два приложения. В конкурентной системе мы может переключаться между ними, дав немного поработать сначала одному, а потом другому. Если делать это достаточно быстро, создаётся впечатление, что два дело делаются одновременно.

В параллельной системе два приложения действительно работает одновременно, т.е. оба активны в одно и то же время.

### Различие между конкурентностью и параллелизмом

Конкрутеность возможна, когда несколько задач может работать независимо друг от друга. Конкурентность можно организовать имя процессор всего с одним ядром, применив **вытесняющую многозадачность** для переключения между задачами. Параллелизм означает, что мы должны выполнить две задачи или более строго одновременно. На машине с одним ядром это просто невозможно.

**Параллелизм всегда подразумевает конкурентность, но обратное верно не всегда.**

## Многозадачность

Делится на два типа:
1. Вытесняющая многозадачность
	**Когда ОС переключает задачи, мы говорим, что имеет место вытеснение**
2. Кооперативная многозадачность
	**Исполняемые задачи кооперируются, т.е. говорят приложению: "Я сейчас на время приостановлюсь, а ты можешь пока выполнить другие задачи."**

**В asyncio используется кооперативная многозадачность, поэтому другой код может работать, пока мы ждём получения результата, вычисляемого в фоновом режиме. Как только вычисление завершится, мы "просыпаемся" и возобновляем задачу.**

**Преимущества кооперативной многозадачности:**
1. Меньшее потребление ресурсов
2. Гранулярность (мы помечаем точки, в которых приостановить задачи наиболее эффективно)

## Процессы, потоки, многопроцессность и многопоточность

### Процесс
Процесс - работающее приложение, которому выделена область памяти, недоступная другим приложениям. Пример - запуск простого приложения "Hello world!". На одной машине может работать несколько процессов одновременно.
Алгоритмы переключения процесса зависят от ОС

### Поток
Поток можно представить как облегчённый процесс. По сути - наименьшая единица выполнения, которая может управляться ОС. Потоки ассоциируются с процессом, создавшим их. **С каждый процессом всегда ассоциирован по меньшей мере один поток, обычно называемый главным.**

**Процесс может порождать и дополнительные потоки, которые называются рабочими или фоновыми. Они могут выполнять другую работу наряду с главным потоком.** Обычное Python приложение создаёт процесс и главный поток, который отвечает за его выполнение.

![[Pasted image 20250113180052.png]]

### Многопоточность

Процессы могут порождать дополнительные потоки, разделяющие память со своим процессом-родителем. Они могут конкурентно выполнять другую работу, это называется многопоточностью.

```python
# Создание многопоточного Python-приложения
import threading


def hello_from_threading():
	print(f'Привет от потока {threading.current_thread()}')

  
hello_thread = threading.Thread(target=hello_from_threading)
hello_thread.start()

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python выполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')

hello_thread.join()
```

![[Pasted image 20250113180122.png]]
Многопоточные приложения - обычный способ реализации конкурентности во многих ЯП. Но в Python есть несколько препятствий для конкурентности с помощью потоков. Многопоточность полезна только для задач, ограниченных производительностью ввода-вывода, потому что нам мешает **Глобальная блокировка интерпретатора**

### Многопроцессность

Многопоточность не единственный способ добиться конкурентности. Можно вместо потоков создать несколько конкурентных процессов, это называется многопроцессностью. В таком случае родительский процесс создаёт один или более дочерних процессов, которыми управляет, а затем распределяет между ними эту работу. **Многопроцессность предпочтительна, когда имеется счётная задача**.

![[Pasted image 20250113180633.png]]

## Глобальная блокировка интерпретатора (GIL)

Глобальная блокировка интерпретатора (GIL, Global Interpreter lock). Говоря кратко GIL не позволяет Python-процессы выполнять более одной команды байт-кода в каждый момент времени. Это означает, что, даже если имеется несколько потоков на многоядерной машине, интерпретатор сможет в каждый момент времени исполнять только один поток, содержащий написанный на Python код.

**Примечание**
Многопроессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что у каждого Python-процесса своя собственная GIL.

Зачем нужен GIL? Дело в том, что в CPython память управляется в основном с помощью подсчёта ссылок. Т.е. для каждого объекта подсчитывается сколько объектов на данный момент использует его. Когда объект "перестаёт быть нужным" счётчик ссылок на него уменьшается, а когда вновь нужен - увеличивается. Если счётчик ссылок равен нулю, то его можно удалить из памяти, т.к. на него никто не ссылается.

**Конфликт потоков возникает из-за того, что интерпретатор CPython не является потокобезопасным.** Это означает, что если два или более потоков модифицируют разделяемую переменную, то её конечное состояние может оказаться неожиданным. Эта ситуация называется **состоянием гонки** (когда два потока одновременно обращаются к одному объекту Python).
![[Pasted image 20250113181608.png]]

В листинге 1.5 и 1.6 приведено сравнение двух программ с вычислением двух программ в синхронном варианте и в многопоточном варианте.
Многопоточный вариант работает, однако в каждый момент времени только одному из них разрешено выполнять Python-код, что сводит на нет весь смысл нескольких потоков. (время выполнение почти одинаковое).

Но на счастье GIL не удерживается постоянно, что открывает возможность для использования нескольких потоков. 
**GIL высвобождается на время выполнения операций ввода-вывода, но не для выполнения счётных задач. Происходит это потому, что в случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python (т.к. ОС напрямую не взаимодействует с объектами Python, GIL захватывается снова, только когда полученный данные переносятся в объект Python).**

В asyncio используется тот факт, что операции ввода-вывода освобождают GIL, что позволяет реализовать конкурентность даже в одном потоке. При работе с asyncio мы создаём объекты **сопрограмм (по сути - это облегчённый поток)**. Ожидая завершения сопрограмм, занимающихся вводом-выводом, мы можем выполнять другой Python код, получая таким образом конкурентность. Важно отметить, что asyncio также ограничен GIL.


## Как работает однопоточная конкурентность и что такое сокеты?

Сокет - низкоуровневая абстракция отправки и получения данных по сети. Именно с её помощью производится обмен данными между клиентами и серверами. Сокеты поддерживают две основные операции: отправку и получение данных (в виде байтов).
Пример:
Если нужно получить данный с example.com, то мы открываем сокет, подключенный к серверу example.com. Затем записываем в сокет запрос и ждём ответа от сервера.
![[Pasted image 20250113183255.png]]

**По умолчанию все сокеты блокирующие.** Это значит, что на всё время ожидания ответа от сервера приложение приостанавливается или блокируется. Следовательно оно ничего не может сделать, пока не придёт ответ от сервера.
На уровне ОС эта блокировка ни к чему. Сокеты могут работать в неблокирующем режиме., когда мы просто начинаем операцию чтения или записи и забываем о ней, а сами занимаемся другими делами. Но позже ОС уведомляет нас о том, что байты получены, и в этот момент мы можем уделить им внимание. Это позволяет приложению не ждать прихода байтов, а делать что-то полезное.

![[Pasted image 20250113183611.png]]

## Как работает цикл событий?
Цикл событий - сердце любого приложения asyncio. Это паттерн проектирования встречается достаточно часто во многих системах. По сути мы создаём очередь, в которой хранится список событий или сообщений, а затем входим в бесконечный цикл, где обрабатывается сообщение по мере их поступления.

В Python он **мог бы** выглядеть примерно так

```python
from collections import deque

message = deque()

while True:
	if message:
		message = message.pop()
		process_message(message)
```

В asyncio цикл событий управляет очередью задач, а не сообщений. Задача - это обёртка вокруг сопрограммы. Сопрограмма может приостановить выполнение, встретив операцию ввода-вывода, и дать циклу событий возможность выполнить другие задачи, которые не ждут завершения ввода-вывода. **Создавая цикл событий мы создаём пустую очередь задач. Затем добавляем в эту очередь задачи для выполнения.** На каждой итерации цикла проверяется, есть ли в очереди готовая задача,и если да, то она выполняется, пока не встретит операцию ввода-вывода. В этом момент задача приостанавливается и мы просим ОС понаблюдать за её сокетами. А сами тем временем переходим к следующей готовой задаче. На каждой итерации проверяем, завершилась ли какая-то задача ввода-вывода. Если да, то ожидавшие её завершения задачи пробуждаются и им предоставляется возможность продолжить работу.

Пример:
Для конкретики представим, что имеется три задачи, каждая из которых отправляется асинхронный веб-запрос. Допусти, что на этапе инициализации выполняется какой-то счётный код, затем посылается веб-запрос, а по его завершению обрабатывается результат, что снова требуется счёт. 
```python
def make_request():
	cpu_bound_setup()
	io_bound_web_request()
	cpu_bound_postprocess()
task_one = make_request()
task_two = make_request()
task_three = make_request()
```
![[Pasted image 20250113184602.png]]

![[Pasted image 20250113184817.png]]

## Резюме

1. Ограниченной быстродействием процессора (счетной) называется
работа, потребляющая в основном ресурсы процессора, а ограниченной производительностью ввода-вывода – работа, потребляющая в основном ресурсы сети или других устройств ввода-вывода.
Главная задача библиотеки asyncio – обеспечить конкурентность задач, ограниченных производительностью ввода-вывода, однако она также предлагает API для организации конкурентности счетных задач.

2.  Процессы и потоки – основные единицы конкурентности на уровне
операционной системы. Процессы можно использовать для рабочих нагрузок, ограниченных как производительностью ввода-вывода, так и быстродействием процессора, а потоки в Python(обычно) – только для эффективного управления задачами, ограниченными производительностью ввода-вывода, потому что GIL
не дает выполнять код параллельно.

 3. Мы видели, что в случае неблокирующих сокетов можно не приостанавливать приложение на время ожидания данных, а попросить операционную систему уведомить нас, когда данные поступят.
Именно это позволяет asyncio организовать конкурентность в од-
ном потоке.

4. Мы познакомились с циклом событий, лежащим в основе приложений asyncio. В бесконечном цикле событий исполняются счетные задачи, а задачи, ожидающие ввода-вывода, приостанавливаются.
