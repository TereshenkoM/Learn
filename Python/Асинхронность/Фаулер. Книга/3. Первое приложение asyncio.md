Вопросы
* Применение сокетов для передачи данных по сети
* Использование telnet для взаимодействия с сервером
* Использование селекторов для построения простого цикла событий
* Создание неблокирующего эхо-сервера для нескольких подключений
* Обработка исключений в задачах
* Включение специальной логики остановки в приложении asyncio


## Работа с блокирующими сокетами

Сокет - это способ читать и записывать данные по сети. Моно считать - что это своего рода почтовый ящик: мы кладём в него письмо, а оно зачтем доставляется по адресу получателя. Получатель может прочесть сообщение и, возможно, отправить сообщение в ответ.

Создадим главный сокет (его ещё называют серверным сокетом). Он будет принимать подключения от клиентов, и создавать новый сокет для взаимодействия с клиентом. Таким образом сервер становится похож не на почтовый ящик, а на почтовое отделение с несколькими ящиками.  Клиент всё также владеет только одним ящиком, поскольку для взаимодействия с сервером открывает только один сокет. 

Такой сервер можно реализовать на Python при помощи библиотеки socket.
![[Pasted image 20250117145025.png]]

Пример:
```python
# Запуск сервера и прослушивание порта для подключения
import socket
  

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)

server_socket.bind(server_address)
server_socket.listen()

connection, client_address = server_socket.accept()
print(f'Получен запрос на подключение от {client_address}!')
```

Пояснения к примеру:
Функция socket принимает два параметра: socket.AF_INET - тип адреса (хост + порт), socket.SOCK_STREAM - используется просто TCP. 

Функция setsockopt: socket.SOL_SOCKET, socket.SO_REUSEADDR, 1 - позволяет переиспользовать адрес. 

Устанавливает адресс 127.0.0.1:8000.

server_socket.listen() - прослушивает запросы от клиентов, желающих подключиться к нашему серверу.

server_socket.accept() - ждём запроса на подключение. Возвращает объект подключения и адрес подключившегося клиента. Объект подключения - это ещё один сокет.


## Пример обращения к сокету через telnet

Для чтения и записи данных на сервер будет использоваться telnet.


Чтобы подключиться к серверу:
```bash
telnet localhost 8000
```

Ответ
```bash
telnet localhost 8000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
```

При этом в консоли сервера
```bash
Получен запрос на подключение от ('127.0.0.1', 56526)!
```


## Чтение и запись данных из сокета

В классе socket имеется метод recv, который позволяет получать данные их сокета.  Метод принимает целое число, показывающее сколько байтов мы хотим прочитать. Это важно, поскольку мы не можем прочитать все данные из сокета, а должны сохранять в буфере, пока не дойдём до конца (концом является строка '\r\n').

```python
# Чтение данных из сокета
import socket


server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)

server_socket.bind(server_address)
server_socket.listen()

try:
	connection, client_address = server_socket.accept()
	print(f'Получен запрос на подключение от {client_address}!')
	buffer = b''

	while buffer[-2:] != b'\r\n':
		data = connection.recv(2) # Считываем по 2 байта и отправляем в буфер

		if not data:
			break

		else:
			print(f'Полученн данные: {data}')
			buffer += data
			print(f'Все данные: {buffer}')

	connection.sendall(buffer) # Принимает сообщение и отправляет его клиенту

finally:
	server_socket.close()
```


Сейчас сокет может обслуживать только одного клиента, но подключиться к одному серверному сокету может несколько клиентов. 


## Разрешение нескольких подключений и опасности блокирования

Сокет, находящийся в режиме прослушивания, допускает одновременное подключение нескольких клиентов. Это значит, что при повторном вызове accept мы каждый раз будем получать новый клиентский сокет для чтения и записи данных. Зная это будем вызывать его в бесконечном цикле.

```python
# Подключение нескольких клиентов
import socket


server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)

server_socket.bind(server_address)
server_socket.listen()

connections = []

try:
	while True:
		connection, client_address = server_socket.accept()
		print(f'Получен запрос на подключение от {client_address}')
		connections.append(connection)

		for connection in connections:
			buffer = b''
			while buffer[-2:] != b'\r\n':
				data = connection.recv(2)
				if not data:
					break
				else:
					print(f'Получены данные: {data}!')
					buffer += data

			print(f'Все данные: {buffer}')
			connection.send(buffer)
finally:
	server_socket.close()
```

В это коде есть проблема, второй клиент не получит никаких сообщений. Так как accept и recv блокируют выполнение программы, пока не получат данные. А значит после того, как первый клиент подключился,  мы будем ждать, пока он отправит своё сообщение (другие клиенты зависнут до следующей итерации цикла).

![[Pasted image 20250117152036.png]]


## Работа с неблокирующими сокетами

Проблему с блокирующими сокетами можно решить, если перевести их в неблокирующий режим. **По сути дела достаточно воспользоваться методом socket.setblocking(False)**.

```python
# Первая попытка создать неблокирующий сервер
import socket

  
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)
  
server_socket.bind(server_address)
server_socket.listen()
server_socket.setblocking(False) # Помечаем серверный сокет как неблокирующий

connections = []

try:
	while True:
		connection, client_address = server_socket.accept()
		# Помечаем клиентский сокет как неблокирующий
		connection.setblocking(False)
		print(f'Получен запрос на подключение от {client_address}!')
		connections.append(connection)

		for connection in connections:
			buffer = b''
	
			while buffer[-2:] != b'\r\n':
				data = connection.recv(2)
				if not data:
					break
				else:
					print(f'Получены данные: {data}!')
					buffer += data
			print(f'Все данные: {buffer}')
			connection.send(buffer)

finally:
	server_socket.close()
```

Однако программа падает сразу после запуска. Проблема в том, что к серверному сокету ещё никто не подключился и следовательно нет данных для обработки.
```python
Traceback (most recent call last):
File "echo_server.py", line 14, in <module>
connection, client_address = server_socket.accept()
File " python3.8/socket.py", line 292, in accept
fd, addr = self._accept()
BlockingIOError: [Errno 35] Resource temporarily unavailable
```

К сожалению нет простого способ узнать, есть ли в сокете данные, поэтому возможное решение - обработка ошибок.

```python
# Перехват и игнорирование ошибок блокирующего сокета
import socket


server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)

server_socket.bind(server_address)
server_socket.listen()
server_socket.setblocking(False)

connections = []

try:
	while True:
		try:
			connection, client_address = server_socket.accept()
			connection.setblocking(False)
			print(f'Получен запрос на подключение от {client_address}!')
			connections.append(connection)
		except BlockingIOError:
			pass

		for connection in connections:
			try:
				buffer = b''
				while buffer[-2:] != b'\r\n':
					data = connection.recv(2)
					if not data:
						break
					else:
						print(f'Получены данные: {data}!')
						buffer += data

				print(f'Все данные: {buffer}')
				connection.send(buffer)

			except BlockingIOError:
				pass

finally:
	server_socket.close()
```

Мы просто игнорируем исключение. Описанный подход работает, но обходится дорого.
Первая проблема - качество кода. Вторая проблема - потребление ресурсов.


## Использование модуля selectors для построения цикла событий сокетов

У ОС есть эффективные API, позволяющие следить за появлением данных в сокетах и другими событиями с ними. Они реализованы на аппаратном уровне, поэтому в мониторинге почти не участвует процессор. Эти системы лежать в основе механизма конкурентности asyncio.

Система уведомления о событиях зависит от ОС, но модуль selectors абстрагирует эту зависимость. В нём же реализован класс BaseSelector и DefaultSelector (автоматически выбирает реализацию для каждой системы уведомления).

Есть две важных концепции: 
1. Регистрация. Если мы хотим получать какие-либо уведомления от сокета, то мы регистрируем его, сообщая какие именно события мы хотим просматривать.

2. Селекция. Блокирует выполнение, пока не произойдёт какое-то событие, после чего возвращает список сокетов для обработки.

```python
# Использование селектора для построения неблокирующих сокетов
import selectors
import socket
from selectors import SelectorKey
from typing import List, Tuple


selector = selectors.DefaultSelector()

server_socket = socket.socket()
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = ('127.0.0.1', 8000)

server_socket.setblocking(False)
server_socket.bind(server_address)
server_socket.listen()

selector.register(server_socket, selectors.EVENT_READ)

while True:
	# Создать селектор с таймаутом 1
	events: List[Tuple[SelectorKey, int]] = selector.select(timeout=1)

	if len(events) == 0:
		print('Событий нет. Жду')
	
	for event, _ in events:
		# Получить сокет, для которого произошло событие
		event_socket = event.fileobj

		# Если событие произошло с серверным сокетом, значит была попытка подключения
	
		if event_socket == server_socket:
			connection, address = server_socket.accept()
			connection.setblocking(False)
			print(f'Получен запрос на подключение от {address}')
	
			# Зарегистрировать клиент, подключившийся к сокету
			selector.register(connection, selectors.EVENT_READ)
	
		else:
		# Если событие произошло не с серверным сокетом
		# получить данные от клиента и отправить обратно
			data = event_socket.recv(1024)
			print(f'Получены данные: {data}')
			event_socket.send(data)
```

Эта во многом напоминает цикл событий asyncio. В данном случае событие - получение данных через сокет. Каждая итерация нашего цикла событий asycnio запускается либо событием сокета, либо при срабатывании таймера. В цикле событий asyncio в любом из этих случаев активируется ожидающая сопрограмма и выполняется до конца или до следующего предложения await. Если await встречается в сопрограмме, где используется неблокирующий сокет, то она регистрирует этот сокет в системном селекторе и запоминает, что эта сопрограмма приостановлена в ожидании результата.


## Эхо-сервер средствами цикла событий asyncio

Методы для работы с сокетами принадлежать самому циклу событий asyncio.
Для работы нам понадобятся три метода цикла событий:
1) sock_accept. Она возвращает кортеж, состоящий из сокета и адреса клиента. Мы передаём серверный сокет и ждём, когда сопрограмма что-то вернёт. После чего уже будем иметь подключенный сокет и адрес.
2) sock_recv - ждём поступления байтов в сокет
3) sock_sendall - принимает сокет и данные, которые нужно отправить, после чего ждёт, пока все данные будут отправлены.


```python
# Построение асинхронного эхо-сервера
import asyncio
import socket
from asyncio import AbstractEventLoop


async def echo(connection: socket, loop: AbstractEventLoop) -> None:
	# В бесконечном цикле ожидаем данных от клиента.
	while data := await loop.sock_recv(connection, 1024):
		# Получив их отправляем обратно клиенту
		await loop.sock_sendall(connection, data)


async def listen_for_connection(server_socket: socket, loop: AbstractEventLoop):
	while True:
		connection, address = await loop.sock_accept(server_socket)
		connection.setblocking(False)

		print(f'Получен запрос на подключение от {address}')

		# После получения сокета на подключение создаём задачу echo
		# ожидающую данные от клиента
		asyncio.create_task(echo(connection, loop))


async def main():
	server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

	server_address = ('127.0.0.1', 8000)

	server_socket.setblocking(False)
	server_socket.bind(server_address)
	server_socket.listen()

	# Запускаем сопрограмму прослушивания порта на предмет подключений
	await listen_for_connection(server_socket, asyncio.get_event_loop())

  

asyncio.run(main())
```

В данном случае мы имеем несколько подключений, по каждому из которых в любой момент могут отправляться данные. Мы не хотим, чтобы ожидание данных по одному подключению блокировало все остальные, желательно иметь возможность читать и записывать данные для нескольких клиентов конкурентно. Поскольку это требуется обрабатывать несколько подключений одновременно, имеет смысл создать для каждого подключения задачу, которая будет отвечать за чтение и запись данных.

Таким образом мы ожидаем подключения в await loop.sock_accept() и после выполняем задачу echo на фоне.

Под капотом всё те же селекторы, но потребление процессора остаётся очень низким.

![[Pasted image 20250117180647.png]]

## Обработка ошибок в задачах

Для тестирования изменим функцию echo и будет возбуждать ошибку в случае, если пользователь написал boom.
```python
async def echo(connections: socket, loop: asyncio.AbstractEventLoop) -> None:
	while data := await loop.sock_recv(connections, 1024):
		print('got data!')

		if data == b'boom\r\n':
			raise Exception('Ошибка сети')

		await loop.sock_sendall(connections, data)
```

Исключение будет выглядеть следующий образом
```bash
Task exception was never retrieved
future: <Task finished name='Task-2' coro=<echo() done, defined at
asyncio_echo.py:5> exception=Exception('Неожиданная ошибка сети')>
Traceback (most recent call last):
File "asyncio_echo.py", line 9, in echo
raise Exception("Неожиданная ошибка сети")
Exception: Unexpected network error
```

Когда внутри задачи возникает исключение, считается, что задача завершена, а её результат является исключение. Это значит, что в стек вызовов исключение не попадёт. И очистки здесь нет. Если это исключение возбуждается, то мы не сможем отреагировать на ошибку в задаче, потому что не пытались его извлечь. Чтобы исключение дошло до нас, задачу нужно вызвать в выражении await. В таком случае исключение будет возбуждено в точке await, и это отразится на Traceback. **Если не применить await к задаче, то мы рискуем никогда не увидеть возникшего исключения.**

Однако мы ничего не увидим, пока не снимем приложение принудительно. Нет никакого способа узнать, не ожидают ли задачу в какой-то другой точке приложения, где она возбудила бы исключение. Самым простым способом решения проблемы является добавление исключений
```python
async def echo(connections: socket, loop: asyncio.AbstractEventLoop) -> None:
	try:
		while data := await loop.sock_recv(connections, 1024):
		print('got data!')

		if data == b'boom\r\n':
			raise Exception('Ошибка сети')

		await loop.sock_sendall(connections, data)
	except Exception as ex:
		logging.exception(ex)

	finally:
		connections.close()
```


## Корректная установка

Что произойдёт, если нам понадобится остановить приложение? Наверное стоило бы завершить обработку уже отправленных сообщений. Для этого можно добавить специальную логику остановки, которая даёт несколько секунд на завершение начатых задач. чтобы они отправили все сообщения, которые собирались.

### Прослушивание сигналов

Сигналы в Unix-системах - это механизм асинхронного уведомления процессора о событии, случившемся на уровне ОС. Например SIGINT (сигнал прерывания) при нажатии CTRL+C или SIGTERM (сигнал завершения). Он посылается, когда мы выполняем команду kill для снятия процесса.

Реализуем обработчики для этих сигналов (он будет снимать все задачи).

```python
# Добавление обработчика сигнала, снимающего все задачи
import asyncio
import signal
from typing import Set

from utils import delay


def cancel_tasks():
	print('Получен сигнал SIGINT')
	tasks: Set[asyncio.Task] = asyncio.all_tasks()
	print(f'Снимается {len(tasks)} задач.')
	
	[task.cancel() for task in tasks]


async def main():
	loop: asyncio.AbstractEventLoop = asyncio.get_running_loop()
	loop.add_signal_handler(signal.SIGINT, cancel_tasks)

	await delay(10)

asyncio.run(main())
```

### Ожидание завершения начатых задач

В исходной программе мы хотели дать задачам немного времени на завершение перед остановкой. Это можно сделать, обернув задачу в wait_for и ожидая их при помощи await.

Говоря о обработчике остановки стоит отметить, что это обычная функция Python которую нельзя вызвать при помощи await. Возможное решение - создать сопрограмму, которая реализует логику остановки, и в обработчике остановки обернуть её задачей:

```python
async def await_all_tasks():
	tasks = asyncio.all_tasks()
	[await task for task in tasks]


async def main():
	loop = asyncio.get_event_loop()
	loop.add_signal_handler(
		signal.SIGINT, 
		lambda: asyncio.create_task(await_all_tasks())
	)
```

У такого подхода есть недостаток: если внутри await_all_tasks возникает исключение, то мы останемся с брошенной отказавшей задачей.

Можно решить проблему, возбудив специальное исключение, которое будет останавливать нашу сопрограмму main(). Тогда мы сможем перехватить его и обработать. Для этого придётся реализовать собственный цикл событий, т.к. asyncio.run() снимает все работающие задачи, а значит, мы не сможем обернуть задачи echo функцией wait_for.


Итоговый код
```python
import asyncio
import socket
import logging
import signal

from typing import List


async def echo(connections: socket, loop: asyncio.AbstractEventLoop) -> None:
	try:
		while data := await loop.sock_recv(connections, 1024):
			print('got data!')

			if data == b'boom\r\n':
				raise Exception('Ошибка сети')

			await loop.sock_sendall(connections, data)

	except Exception as ex:
		logging.exception(ex)

	finally:
		connections.close()

  
echo_tasks = []

async def connection_listener(server_socket, loop):
	while True:
		connection, address = await loop.sock_accept(server_socket)
		connection.setblocking(False)

		print(f'Получено сообщенгие от {address}')

		echo_task = asyncio.create_task(echo(connection, loop))
		echo_tasks.append(echo_task)


class GracefulExit(SystemExit):
	pass


def shutdown():
	raise GracefulExit


async def close_echo_tasks(echo_tasks: List[asyncio.Task]):
	waiters = [asyncio.wait_for(task, 2) for task in echo_tasks]

	for task in waiters:
		try:
			await task
		except asyncio.exceptions.TimeoutError:
			# Здесь ожидаем истечения тайм-аута
				pass


async def main():
	server_socket = socket.socket()
	server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

	server_address = ('127.0.0.1', 8000)

	server_socket.setblocking(False)
	server_socket.bind(server_address)
	server_socket.listen()

	for signame in {'SIGINT', 'SIGTERM'}:
		loop.add_signal_handler(getattr(signal, signame), shutdown)
	await connection_listener(server_socket, loop)


loop = asyncio.new_event_loop()

try:
	loop.run_until_complete(main())
except GracefulExit:
	loop.run_until_complete(close_echo_tasks(echo_tasks))
finally:
	loop.close()
```


## Резюме
* Блокирующий сокет останавливает весь поток, ожидая данных. Это препятствует организации конкурентности, потому что в каждый момент времени мы можем получать данные только от одного клиента

* Неблокирующие сокеты возвращают управление немедленно - либо в результате получения данных, либо с исключением. если данные ещё не пришли. Поэтому неблокирующие сокеты позволяют обеспечить конкурентность

* Для эффективного прослушивания событий в сокетах используется модуль selectors. Он позволяет зарегистрировать сокеты, за которыми мы хотим наблюдать, и сообщает, когда в неблокирующем сокете появляются данные.

* Методы цикла событий asyncio позволяют строить приложения с неблокирующими сокетами. Они принимают сокет и возвращают сопрограмму, которую можно использовать в выражении await. Это приостанавливает родительскую сопрограмму, до тех пор пока в сокете не появятся данные. Под капотом также используется модуль selectors.