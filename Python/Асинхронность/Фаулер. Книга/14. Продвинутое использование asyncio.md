
Вопросы
* Проектирование API одновременно сопрограмм и функций
* Контекстные локальные переменные сопрограмм
* Уступка управления циклу событий
* Использование различных реализаций цикла событий
* Связь между сопрограммами и генераторами
* Создание собственного цикл событий с помощью нестандартных объектов, допускающих ожидание


## API, допускающие сопрограммы и функции

Разрабатывая API мы не можем гарантировать, что пользователи будут пользоваться программой только в асинк режиме.
Как спроектировать API, который допускал бы как асинк, так и синк?

В asyncio есть две функции:
* asyncio.iscoroutine
* asyncio.iscoroutinefunction

Они позволяют проверить, является ли вызываемый объект сопрограммой.
Пример простого класса исполнителя задач, принимающий как функции, так и сопрограммы.
```python
import asyncio  
  
  
class TaskRunner:  
    def __init__(self):  
        self.loop = asyncio.new_event_loop()  
        self.tasks = []  
  
    def add_task(self, func):  
        self.tasks.append(func)  
  
    async def _run_all(self):  
        awaitable_tasks = []  
  
        for task in self.tasks:  
            if asyncio.iscoroutinefunction(task):  
                awaitable_tasks.append(asyncio.create_task(task()))  
            elif asyncio.iscoroutine(task):  
                awaitable_tasks.append(asyncio.create_task(task))  
            else:  
                # ставит функцию в очередь на ближайшее выполнение, но не ждёт её завершения.  
                self.loop.call_soon(task)  
  
        await asyncio.gather(*awaitable_tasks)  
  
    def run(self):  
        self.loop.run_until_complete(self._run_all())  
  
  
if __name__ == "__main__":  
    def regular_function():  
        print('Привет от регулярной функции!')  
  
    async def coroutine_function():  
        print('Выполняется сопрограмма, засыпаю!')  
        await asyncio.sleep(1)  
        print('Проснулась')  
  
    runner = TaskRunner()  
    runner.add_task(coroutine_function)  
    runner.add_task(coroutine_function())  
    runner.add_task(regular_function)  
  
    runner.run()
```

Вывод
```
Выполняется сопрограмма, засыпаю!
Выполняется сопрограмма, засыпаю!
Привет от регулярной функции!
Проснулась
Проснулась
```

По итогу были успешно выполнены и сопрограммы и обычные функции.


## Контекстные переменные
Допусти мы используем REST API для доступа к веб-серверу, обрабатывающим каждый запрос в отдельном потоке.

Возникает соблазн сохранить данные отправленные пользователем глобально и сделать недоступным всем потокам сервера, но у такого подхода есть и недостатки вроде необходимости сопоставить потоку его данные и организация блокировок для предотвращения гонки.

**Эти проблемы можно решить при помощи поточно-локальных переменных**. Это глобальные переменные на уровне одного потока. Данные будут видны только потому, сохранившему их, и таким образом решаются проблемы выше.

**Контекстные переменные похожи на поточно-локальные, но локальные для задачи, а не для потока.** **Это означает, что если задача создаёт контекстную переменную, то к ней будет иметь доступ любая внутренняя сопрограмма или задача, созданная внутри задачи-создателя. А никакие задачи вне этой цепочки не смогут ни увидеть, ни модифицировать эту переменную. Это позволяет хранить состояние, связанное с конкретной задачей, не передавая его явно в виде аргумента.**

Пример

```python
import asyncio  
from asyncio import StreamWriter, StreamReader  
from contextvars import ContextVar  
  
  
class Server:  
    # Создать контекстную переменную с именем user_address  
    user_address = ContextVar('user_address')  
  
    def __init__(self, host: str, port: int):  
        self.host = host  
        self.port = port  
  
    async def start_server(self):  
        server = await asyncio.start_server(  
            self._client_connected,  
            self.host,  
            self.port  
        )  
        await server.serve_forever()  
  
    def _client_connected(self, reader: StreamReader, writer: StreamWriter):  
        # В момент подключения пользователя сохранить его адрес в контекстной переменной  
        self.user_address.set(writer.get_extra_info('peername'))  
        asyncio.create_task(self.listen_for_messages(reader))  
  
    async def listen_for_messages(self, reader: StreamReader):  
        while data := await reader.readline():  
            print(f'Получено сообщение {data} от {self.user_address.get()}')  
  
  
async def main():  
    server = Server('127.0.0.1', 9000)  
    await server.start_server()  
  
  
asyncio.run(main())
```


Вывод при подключении нескольких пользователей 
```
Получено сообщение b'Hello!\r\n' от ('127.0.0.1', 50036)
Получено сообщение b'Okay!\r\n' от ('127.0.0.1', 50038)
```


## Принудительный запуск итерации цикла событий

Обычно мы не можем повлиять на цикл событий. Он решает, когда и как выполнять сопрограммы и задачи.

Если создаётся несколько задач, то ни одна из них не начнёт работать, пока программа не дойдёт до предложения await, которое инициирует планирование задач в цикле событий и их запуск. Но что если мы хотим, чтобы каждая задача начинала выполнение сразу?

Для этого asyncio предлагает идиому приостановки текущей сопрограммы и принудительного запуска новой итерации цикла событий - вызов asyncio.sleep(0)

```python
import asyncio  
from utils import delay  
  
  
async def create_tasks_no_sleep():  
    task1 = asyncio.create_task(delay(1))  
    task2 = asyncio.create_task(delay(2))  
    print('К задачам применяет gather')  
    await asyncio.gather(task1, task2)  
  
  
async def create_tasks_sleep():  
    task1 = asyncio.create_task(delay(1))  
    await asyncio.sleep(0)  
    task2 = asyncio.create_task(delay(2))  
    await asyncio.sleep(0)  
    print('К задачам применяет gather')  
    await asyncio.gather(task1, task2)  
  
  
async def main():  
    print('--- Без asyncio.sleep(0) ---')  
    await create_tasks_no_sleep()  
    print('--- С asyncio.sleep(0) ---')  
    await create_tasks_sleep()  
  
  
asyncio.run(main())
```

Вызов sleep принудительно запускает следующую итерацию цикла событий, что выливается в немедленное выполнение задачи.

## Использование других реализаций цикла событий

Библиотека asyncio предлагает реализацию цикла событий по умолчанию, которым мы и пользовались до сих пор, но ничто не мешает взять другую реализацию, возможно, обладающую иными характеристиками.

Первый способ - написать AbstractEventLoop, реализовав необходимые методы, создать экземпляр нового класса и сделать его циклом событий, вызвав функцию asyncio.set_event_loop.
Второй способ - использовать свои готовые циклы событий. Один из них **uvloop**

uvloop - реализация цикла событий на основе библиотеки libuv, на которой зиждется node.js. Поскольку она написана на С, то она работает быстрее, чем код на чистом Python. Особенно наглядно это проявляется в приложениях, где используются сокеты и потоковый ввод-вывод.

```
pip install uvloop
```

```python
import asyncio  
from asyncio import StreamReader, StreamWriter  
import uvloop  
  
  
async def connected(reader: StreamReader, writer: StreamWriter):  
    line = await reader.readline()  
    writer.write(line)  
    await writer.drain()  
    writer.close()  
    await writer.wait_closed()  
  
  
async def main():  
    print('Старт')  
    server = await asyncio.start_server(connected, port=9000)  
    await server.serve_forever()  
  
uvloop.install()  
asyncio.run(main())
```

Здесь мы вызываем функцию uvloop.install(), которая переключает реализации цикла событий. Можно было бы сделать это и вручную

```python
loop = uvloop.new_event_loop()
asyncio.set_event_loop(loop)
```

Важно только, чтобы этот вызов был произведён раньше, чем вызов asyncio.run(main()).
Он под капотом вызывает функцию get_event_loop, которая создаст цикл событий, если он ещё не существует. Если сделать это, до того как uvloop был установлен, то мы получим стандартный цикл событий, и последующая установка uvloop уже ничего не изменит.

