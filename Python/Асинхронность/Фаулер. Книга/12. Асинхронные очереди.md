Вопросы:
* Асинхронные очереди
* Использование очередей в технологических процессах типа производитель-потребитель
* Использование очередей в веб-приложениях
* Использование очередей с приоритетами
* Асинхронные LIFO-очереди

## Основы асинхронных очередей

Очередь - структура данных с дисциплиной FIFO (первый зашёл - первый вышел). Иными словами первым будет извлечён элемент, находящийся в начале очереди.

**Принципиальное описание асинхронных очередей - несколько исполнителей выбирают данные из очереди по мере поступления**. Пример: очередь в супермаркете (одна очередь) и несколько касс,которые её обслуживают.

```python
import asyncio  
from asyncio import Queue  
from random import randrange  
from typing import List  
  
  
class Product:  
    def __init__(self, name: str, checkout_time: float):  
        self.name = name  
        self.checkout_time = checkout_time  
  
  
class Customer:  
    def __init__(self, customer_id: int, products: List[Product]):  
        self.customer_id = customer_id  
        self.products = products  
  
  
async def checkout_customer(queue: Queue, cashier_number: int):  
    while not queue.empty():  
        customer: Customer = queue.get_nowait()  
        print(  
            f'Кассир {cashier_number} '  
            f'Обслуживает покупателя '            
            f'{customer.customer_id}'  
        )  
  
        # Обрабатываем каждый товар покупателя  
        for product in customer.products:  
            print(  
                f'Кассир {cashier_number} '  
                f'Обслуживает покупателя '   
	            f'{customer.customer_id}: {product.name}'  
            )  
            await asyncio.sleep(product.checkout_time)  
  
        print(  
            f'Кассир {cashier_number} '  
            f'закончил обслуживать покупателя '
            f'{customer.customer_id}'  
        )  
        queue.task_done()  
  
async def main():  
    customer_queue = Queue()  
  
    all_products = [  
        Product('пиво', 2),  
        Product('бананы', 0.5),  
        Product('колбаса', 0.2),  
        Product('подгузники', 0.2)  
    ]  
    for i in range(10):  
        products = [  
            all_products[randrange(len(all_products))]  
            for _ in range(randrange(1, 5))  
        ]        await customer_queue.put(Customer(i, products))  
  
    cashiers = [  
        asyncio.create_task(checkout_customer(customer_queue, cashier_number))  
        for cashier_number in range(3)  
    ]  
    await asyncio.gather(customer_queue.join(), *cashiers)  
  
  
asyncio.run(main())
```

Пока очередь не пуста, задача берёт покупателя из начала очереди (get_nowait) и имитирует время сканиорования товара. Обслужив покупателя вызвали queue.task_done.

Сопрограмма join блокируется до тех пор, пока очередь не будет освобождена. Очередь считается пустой, когда внутренний счётчик незавершённых работ обратился в нуль. **Поэтому так важно вызывать task_done в исполнителях.**

```
Кассир 0 Обслуживает покупателя 0
Кассир 0 Обслуживает покупателя 0: бананы
Кассир 1 Обслуживает покупателя 1
Кассир 1 Обслуживает покупателя 1: подгузники
Кассир 2 Обслуживает покупателя 2
Кассир 2 Обслуживает покупателя 2: колбаса
Кассир 1 закончил обслуживать покупателя 1
Кассир 1 Обслуживает покупателя 3
Кассир 1 Обслуживает покупателя 3: колбаса
Кассир 2 Обслуживает покупателя 2: бананы
Кассир 1 Обслуживает покупателя 3: бананы
Кассир 0 Обслуживает покупателя 0: пиво
Кассир 2 Обслуживает покупателя 2: подгузники
Кассир 1 Обслуживает покупателя 3: колбаса
Кассир 2 закончил обслуживать покупателя 2
Кассир 2 Обслуживает покупателя 4
.......
```

**А что за приставка nowait у get_nowait и put_nowait ?** Эти варианты не блокируют выполнение и возвращают управление немедленно.

Также есть и блокирующие варианты get и put. Зачем они нужны?

Например при попытке взять элемент из пустой очереди при помощь get_nowait вызовет ошибку asyncio.queues.Empty. **get же будет "ждать" пока в очереди не появится новых элементов и заблокирует выполнение**

```python
import asyncio  
from asyncio import Queue  
  
  
async def main():  
    customer_queue = Queue()  
    # Не ошибки  
    await customer_queue.get()  
    # С ошибкой  
    # customer_queue.get_nowait()  
asyncio.run(main())
```


C put_nowait схожая ситуация. У очередей есть максимальный размер, если его превысить, то мы получим asyncio.queues.QueueFull. **put же будет ждать, пока в очереди не освободится место (также блокирующий**

```python
import asyncio  
from asyncio import Queue


async def main():  
    queue = Queue(maxsize=1)  
    #С ошибкой  
    queue.put_nowait(1)  
    queue.put_nowait(1)  
    # Без ошибки  
    queue.put_nowait(1)  
    await queue.put(1)  
  
asyncio.run(main())
```

Более реальный пример с использованием методов-сопрограмм очереди для магазина (с get и put)

```python
import asyncio  
from asyncio import Queue  
from random import randrange  
  
  
class Product:  
    def __init__(self, name: str, checkout_time: float):  
        self.name = name  
        self.checkout_time = checkout_time  
  
  
class Customer:  
    def __init__(self, customer_id, products):  
        self.customer_id = customer_id  
        self.products = products  
  
  
async def checkout_customer(queue: Queue, cashier_number: int):  
    while True:  
        customer: Customer = await queue.get()  
        print(  
            f'Кассир {cashier_number} '  
            f'Обслуживает покупателя '            
            f'{customer.customer_id}'  
        )  
  
        # Обрабатываем каждый товар покупателя  
        for product in customer.products:  
            print(  
                f'Кассир {cashier_number} '  
                f'Обслуживает покупателя '
                f'{customer.customer_id}: {product.name}'  
            )  
            await asyncio.sleep(product.checkout_time)  
  
        print(  
            f'Кассир {cashier_number} '  
            f'закончил обслуживать покупателя '
            f'{customer.customer_id}'  
        )  
        queue.task_done()  
  
  
def generate_customer(customer_id: int) -> Customer:  
    all_products = [  
        Product('пиво', 2),  
        Product('бананы', 0.5),  
        Product('колбаса', 0.2),  
        Product('подгузники', 0.2)  
    ]    
    products = [  
        all_products[randrange(len(all_products))]  
        for _ in range(randrange(10))  
    ]  
    return Customer(customer_id, products)  
  
  
async def customer_generator(queue: Queue):  
    customer_count = 0  
  
    while True:  
        customers = [  
            generate_customer(i)  
            for i in range(customer_count, customer_count + randrange(5))  
        ]  
        for customer in customers:  
            print('Ожидаю возможности поставить покупателя в очередь ...')  
            await queue.put(customer)  
            print('Покупатель поставлен в очередь')  
            customer_count += len(customers)  
            await asyncio.sleep(1)  
  
  
async def main():  
    customer_queue = Queue(5)  
  
    customer_producer = asyncio.create_task(customer_generator(customer_queue))  
  
    cashiers = [  
        asyncio.create_task(checkout_customer(customer_queue, i))  
        for i in range(3)  
    ]  
    await asyncio.gather(customer_producer, *cashiers)  
  
asyncio.run(main())
```


Вывод
```
Ожидаю возможности поставить покупателя в очередь ...
Покупатель поставлен в очередь
Кассир 0 Обслуживает покупателя 0
Кассир 0 Обслуживает покупателя 0: колбаса
Кассир 0 Обслуживает покупателя 0: пиво
Ожидаю возможности поставить покупателя в очередь ...
Покупатель поставлен в очередь
Кассир 1 Обслуживает покупателя 1
Кассир 1 Обслуживает покупателя 1: бананы
Кассир 1 Обслуживает покупателя 1: бананы
Ожидаю возможности поставить покупателя в очередь ...
Покупатель поставлен в очередь
Кассир 1 Обслуживает покупателя 1: бананы
Кассир 2 Обслуживает покупателя 2
Кассир 2 Обслуживает покупателя 2: колбаса
Кассир 0 закончил обслуживать покупателя 0
......
```



### Очереди в веб-приложениях

Очереди могут оказаться полезными в веб-приложениях, если имеется занимающая много времени операция, которую можно запустить в фоновом режиме. Если бы мы выполняли её в главной сопрограмме веб-запроса, то блокировали бы её до завершения операции, поэтому пользователь увидел бы "тормозящую" страницу.

Напишем простое веб-приложение на основе aiohttp, в котором для выполнения фоновых задач используется очередь.

```python
import asyncio  
from asyncio import Queue, Task  
from typing import List  
from random import randrange  
from aiohttp import web  
from aiohttp.web_app import Application  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
  
  
routes = web.RouteTableDef()  
  
QUEUE_KEY = 'order_queue'  
TASKS_KEY = 'order_tasks'  
  
# Выбрать заказ из очереди и обработать его  
async def process_order_worker(worker_id: int, queue: Queue):  
    while True:  
        print(f'Исполнитель {worker_id}: ожидание заказа ...')  
        order = await queue.get()  
        print(f'Исполнитель {worker_id}: обрабатывается заказ {order}')  
        await asyncio.sleep(order)  
        print(f'Испонитель {worker_id}: заказ {order} обработан')  
  
        queue.task_done()  
  
  
@routes.get('/order')  
async def place_order(request: Request) -> Response:  
    order_queue = app[QUEUE_KEY]  
    # Поместить заказ в очередь и ответить пользователю немедленно  
    await order_queue.put(randrange(5))  
    return Response(body='Order placed!')  
  
  
# Создать на 10 элементов 5 задач исполнителей  
async def create_order_queue(app: Application):  
    print('Создание очереди заказов и задач')  
    queue: Queue = asyncio.Queue(10)  
    app[QUEUE_KEY] = queue  
    app[TASKS_KEY] = [  
        asyncio.create_task(  
            process_order_worker(i, queue)  
        )  
        for i in range(5)  
    ]  
  
  
# Ждать завершения работающих задач  
async def destroy_queue(app: Application):  
    order_tasks: List[Task] = app[TASKS_KEY]  
    queue: Queue = app[QUEUE_KEY]  
    print('Ожидание завершения исполнителей в очереди...')  
  
    try:  
        await asyncio.wait_for(queue.join(), timeout=10)  
    finally:  
        print('Обработка всех заказов завершена, отменяются задачи исполнители')  
        [task.cancel() for task in order_tasks]  
  
app = web.Application()  
app.on_startup.append(create_order_queue)  
app.on_shutdown.append(destroy_queue)  
  
app.add_routes(routes)  
web.run_app(app)
```

На всякий случай мы обернули вызов join методом wait_for, ограничив время ожидания 10с. Это разумно, так как мы не хотим, чтобы какая-то сбойная задача мешала приложению остановиться.

Однако очереди asyncio не предлагают решения для сохранения и обеспечения долговечности очереди. Для таких задач лучше подходят сторонние очереди, вроде Celery и RabbitMQ.


### Очередь в веб-роботе

Задачи потребители могут одновременно выступать в роли производителей, если генерируют дополнительные элементы, помещаемые в очередь.

Пример с парсером
```python
import asyncio  
from asyncio import Queue, Task  
from typing import List  
from random import randrange  
from aiohttp import web  
from aiohttp.web_app import Application  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
  
  
routes = web.RouteTableDef()  
  
QUEUE_KEY = 'order_queue'  
TASKS_KEY = 'order_tasks'  
  
# Выбрать заказ из очереди и обработать его  
async def process_order_worker(worker_id: int, queue: Queue):  
    while True:  
        print(f'Исполнитель {worker_id}: ожидание заказа ...')  
        order = await queue.get()  
        print(f'Исполнитель {worker_id}: обрабатывается заказ {order}')  
        await asyncio.sleep(order)  
        print(f'Испонитель {worker_id}: заказ {order} обработан')  
  
        queue.task_done()  
  
  
@routes.get('/order')  
async def place_order(request: Request) -> Response:  
    order_queue = app[QUEUE_KEY]  
    # Поместить заказ в очередь и ответить пользователю немедленно  
    await order_queue.put(randrange(5))  
    return Response(body='Order placed!')  
  
  
# Создать на 10 элементов 5 задач исполнителей  
async def create_order_queue(app: Application):  
    print('Создание очереди заказов и задач')  
    queue: Queue = asyncio.Queue(10)  
    app[QUEUE_KEY] = queue  
    app[TASKS_KEY] = [  
        asyncio.create_task(  
            process_order_worker(i, queue)  
        )  
        for i in range(5)  
    ]  
  
# Ждать завершения работающих задач  
async def destroy_queue(app: Application):  
    order_tasks: List[Task] = app[TASKS_KEY]  
    queue: Queue = app[QUEUE_KEY]  
    print('Ожидание завершения исполнителей в очереди...')  
  
    try:  
        await asyncio.wait_for(queue.join(), timeout=10)  
    finally:  
        print('Обработка всех заказов завершена, отменяются задачи исполнители')  
        [task.cancel() for task in order_tasks]  
  
app = web.Application()  
app.on_startup.append(create_order_queue)  
app.on_shutdown.append(destroy_queue)  
  
app.add_routes(routes)  
web.run_app(app)
```

Исполнители продолжают скачивать страницы и обрабатывать ссылки, добавляя их в очередь, пока не будет достигнута заданная максимальная глубина.



## Очереди с приоритетами
Бывают ситуации, где рассматривать все задачи на равных нежелательно. Предположим, что есть две задачи, первая - низкоприоритетный запрос к данным, вторая - важное срочное обновление. Если очередь обычная, то вторая задача будет ждать выполнения первой.

Для решения проблемы можно воспользоваться очередью с приоритетами и заставить исполнителей задач сначала брать наиболее важные задачи. Очереди с приоритетами реализованы с помощью пирамид. Для создания такой очереди используется **asyncio.PriorityQueue**.

Для справки
Пирамида - двоичное дерево, где значение родительского узла меньше значения любого из потомков.

![[Pasted image 20250815184514.png]]

Маловероятно, что все элементы, которые помещаются в очередь, будут целыми числами. Поэтому нам необходим какой-то способ построить элемент очереди с правилом определения приоритета. Например кортеж, где первый элемент - число равное приоритету, а второй - произвольные данные задачи.

Пример
```python
import asyncio  
from asyncio import Queue, PriorityQueue  
from typing import Tuple  
  
  
async def worker(queue: Queue):  
    while not queue.empty():  
        work_item: Tuple[int, str] = await queue.get()  
        print(f'Обрабатывается элемент {work_item}')  
        queue.task_done()  
  
  
async def main():  
    priority_queue = PriorityQueue()  
  
    work_items = [  
        (3, 'Lowest'),  
        (2, 'Medium'),  
        (1, 'High')  
    ]  
    worker_task = asyncio.create_task(worker(priority_queue))  
  
    for work in work_items:  
        priority_queue.put_nowait(work)  
  
    await asyncio.gather(priority_queue.join(), worker_task)  
  
asyncio.run(main())
```

Вывод
```
Обрабатывается элемент (1, 'High')
Обрабатывается элемент (2, 'Medium')
Обрабатывается элемент (3, 'Lowest')
```

В обычной очереди вывод был бы перевёрнут, т.к. (3, 'Lowest') попал бы в очередь первым.

Кортежи работают только в простых случаях, но если элемент содержит много данных, то это решение может стать запутанным. Можно воспользоваться для более сложных случаев дата классом.

```python
import asyncio  
from asyncio import Queue, PriorityQueue  
from dataclasses import dataclass, field  
  
  
# order=True - создаёт дандер методы для сравнения  
@dataclass(order=True)  
class WorkItem:  
    priority: int  
    # Параметр compare=False говорит:
    # не использовать это поле при сравнении объектов.  
    data: str = field(compare=False)  
  
  
async def worker(queue: Queue):  
    while not queue.empty():  
        work_item: WorkItem = await queue.get()  
        print(f'Обрабатывается элемент {work_item}')  
        queue.task_done()  
  
  
async def main():  
    priority_queue = PriorityQueue()  
  
    work_items = [  
        WorkItem(3, 'Lowest'),  
        WorkItem(2, 'Medium'),  
        WorkItem(1, 'High')  
    ]    worker_task = asyncio.create_task(worker(priority_queue))  
  
    for work in work_items:  
        priority_queue.put_nowait(work)  
  
    await asyncio.gather(priority_queue.join(), worker_task)  
  
asyncio.run(main())
```

Более сложный пример. Допустим, что в веб-приложении есть приоритетные покупатели, заявки которых нужно обработать первыми.

```python
import asyncio  
from asyncio import Queue, Task  
from typing import List  
from random import randrange  
from aiohttp import web  
from aiohttp.web_app import Application  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
from enum import IntEnum  
from dataclasses import field, dataclass  
routes = web.RouteTableDef()  
  
QUEUE_KEY = 'order_queue'  
TASKS_KEY = 'order_tasks'  
  
class UserType:  
    POWER_USER = 1  
    NORMAL_USER = 2  
  
@dataclass(order=True)  
class Order:  
    user_type: UserType  
    order_delay: int = field(compare=False)  
  
  
# Выбрать заказ из очереди и обработать его  
async def process_order_worker(worker_id: int, queue: Queue):  
    while True:  
        print(f'Исполнитель {worker_id}: ожидание заказа ...')  
        order = await queue.get()  
        print(f'Исполнитель {worker_id}: обрабатывается заказ {order}')  
        await asyncio.sleep(order)  
        print(f'Испонитель {worker_id}: заказ {order} обработан')  
  
        queue.task_done()  
  
  
@routes.get('/order')  
async def place_order(request: Request) -> Response:  
    body = await request.json()  
    user_type = UserType.POWER_USER if body['power_user'] == 'True' else UserType.NORMAL_USER  
  
    order_queue = app[QUEUE_KEY]  
    await order_queue.put(Order(user_type, randrange(5)))  
    return Response(body='Order placed!')  
  
  
# Создать на 10 элементов 5 задач исполнителей  
async def create_order_queue(app: Application):  
    print('Создание очереди заказов и задач')  
    queue: Queue = asyncio.PriorityQueue(10)  
    app[QUEUE_KEY] = queue  
    app[TASKS_KEY] = [  
        asyncio.create_task(  
            process_order_worker(i, queue)  
        )  
        for i in range(5)  
    ]  
  
# Ждать завершения работающих задач  
async def destroy_queue(app: Application):  
    order_tasks: List[Task] = app[TASKS_KEY]  
    queue: Queue = app[QUEUE_KEY]  
    print('Ожидание завершения исполнителей в очереди...')  
  
    try:  
        await asyncio.wait_for(queue.join(), timeout=10)  
    finally:  
        print('Обработка всех заказов завершена, отменяются задачи исполнители')  
        [task.cancel() for task in order_tasks]  
  
app = web.Application()  
app.on_startup.append(create_order_queue)  
app.on_shutdown.append(destroy_queue)  
  
app.add_routes(routes)  
web.run_app(app)
```

Если пользователь приоритетный, то любой из исполнителей возьмёт его сразу после того, как освободится.


Любопытный случай возникает тогда, когда два элемента с одинаковыми приоритетами появляются один за другим. Будут ли исполнители обрабатывать их в порядке добавления?

```python
import asyncio  
from asyncio import Queue, PriorityQueue  
from dataclasses import dataclass, field  
  
  
@dataclass(order=True)  
class WorkItem:  
    priority: int  
    data: str = field(compare=False)  
  
  
async def worker(queue: Queue):  
    while not queue.empty():  
        work_item = await queue.get()  
        print(f'Обрабатывается элемент {work_item}')  
        queue.task_done()  
  
  
async def main():  
    priority_queue = PriorityQueue()  
  
    work_items = [  
        WorkItem(3, 'Low'),  
        WorkItem(3, 'Low 2'),  
        WorkItem(3, 'Low 3'),  
        WorkItem(2, 'Mid'),  
        WorkItem(1, 'High')  
    ]  
    worker_task = asyncio.create_task(worker(priority_queue))  
  
    for work in work_items:  
        priority_queue.put_nowait(work)  
  
    await asyncio.gather(priority_queue.join(), worker_task)  
  
asyncio.run(main())
```

Вывод
```
Обрабатывается элемент WorkItem(priority=1, data='High')
Обрабатывается элемент WorkItem(priority=2, data='Mid')
Обрабатывается элемент WorkItem(priority=3, data='Low 3')
Обрабатывается элемент WorkItem(priority=3, data='Low 2')
Обрабатывается элемент WorkItem(priority=3, data='Low')
```

Причина такого вывода в том, что алгоритм headsort неустойчив, т.е. не гарантируется, что равные элементы будут предоставляться в том порядке, в котором вставлялись. Часто порядок обработки с равными приоритетами не имеет значения, но если он важен, то следует формировать ключ, устраняющий неоднозначность.

```python
import asyncio  
from asyncio import Queue, PriorityQueue  
from dataclasses import dataclass, field  
  
  
@dataclass(order=True)  
class WorkItem:  
    priority: int  
    order: int # Ключ устраняющий неоднозначность
    data: str = field(compare=False)  
  
  
async def worker(queue: Queue):  
    while not queue.empty():  
        work_item = await queue.get()  
        print(f'Обрабатывается элемент {work_item}')  
        queue.task_done()  
  
  
async def main():  
    priority_queue = PriorityQueue()  
  
    work_items = [  
        WorkItem(3, 1, 'Low'),  
        WorkItem(3, 2, 'Low 2'),  
        WorkItem(3, 3, 'Low 3'),  
        WorkItem(2, 4, 'Mid'),  
        WorkItem(1, 5, 'High')  
    ]  
    worker_task = asyncio.create_task(worker(priority_queue))  
  
    for work in work_items:  
        priority_queue.put_nowait(work)  
  
    await asyncio.gather(priority_queue.join(), worker_task)  
  
asyncio.run(main())
```

Вывод
```
Обрабатывается элемент WorkItem(priority=1, order=5, data='High')
Обрабатывается элемент WorkItem(priority=2, order=4, data='Mid')
Обрабатывается элемент WorkItem(priority=3, order=1, data='Low')
Обрабатывается элемент WorkItem(priority=3, order=2, data='Low 2')
Обрабатывается элемент WorkItem(priority=3, order=3, data='Low 3')
```

## LIFO-очереди (стек)

Если последний элемент в очереди нужно обработать первым, то стек в помощь)

```python
import asyncio  
from asyncio import Queue, LifoQueue  
from dataclasses import dataclass, field  
  
  
@dataclass(order=True)  
class WorkItem:  
    priority: int  
    order: int  
    data: str = field(compare=False)  
  
  
async def worker(queue: Queue):  
    while not queue.empty():  
        work_item: WorkItem = await queue.get()  
        print(f'Обрабатывается элемент {work_item}')  
        queue.task_done()  
  
  
async def main():  
    lifo_queue = LifoQueue()  
    work_items = [  
        WorkItem(3, 1,'low 1'),  
        WorkItem(3, 2, 'low 2'),  
        WorkItem(3, 3, 'low 3'),  
        WorkItem(2, 4, 'mid'),  
        WorkItem(1, 5, 'high')  
    ]    worker_task = asyncio.create_task(worker(lifo_queue))  
    for work in work_items:  
        lifo_queue.put_nowait(work)  
    await asyncio.gather(lifo_queue.join(), worker_task)  
  
  
asyncio.run(main())
```

```
Обрабатывается элемент WorkItem(priority=1, order=5, data='high')
Обрабатывается элемент WorkItem(priority=2, order=4, data='mid')
Обрабатывается элемент WorkItem(priority=3, order=3, data='low 3')
Обрабатывается элемент WorkItem(priority=3, order=2, data='low 2')
Обрабатывается элемент WorkItem(priority=3, order=1, data='low 1')
```

Элементы обрабатываются в порядке противоположному тому, в котором вставлялись.