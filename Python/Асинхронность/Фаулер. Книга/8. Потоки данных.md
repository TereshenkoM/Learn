
Вопросы:
* Транспортные механизмы и протоколы
* Использование потоков данных для организации сетевых подключений
* Асинхронная обработка ввода из командной строки
* Создание клиент-серверных приложений с помощью потоков данных

## Введение в потоки данных

В asyncio потоки данных представляют собой высокоуровневые классы и функции для создания и управления сетевыми подключениями и вообще потоками данных. С их помощью мы можем создавать клиентские подключения для чтения и записи данных на сервер.

Потоковые API надстроены над низкоуровневыми API транспорта и протоколов. Они обёртывают сокеты, предоставляя чистый API для чтения и записи данных.


## Транспортные механизмы и протоколы

Транспортный механизм - это абстракция взаимодействия с произвольным потоком данных. Взаимодействуя с сокетом или любым другим потоком данных - например стандартным вводом , мы имеем дело со знакомым набором операций. Читаем данные, записываем данные и закрываем сокет. 

**Сокет - хорошо ложится на эту абстракцию - чтение, запись, закрытие **

**Транспортный механизм по сути своей отправку данных и их получение от источника**
Реализация обычно зависит от источника, но нас интересуют классы ReadTransport, WriteTransport и Transport

![[Pasted image 20250711151940.png]]


**Важно** далее будет определено понятие протокола, под протоколом имеется ввиду некий класс Python

Жизненный цикл сокета выглядит примерно так

![[Pasted image 20250711152153.png]]


Чтобы понять как транспортные механизмы и протоколы работают совместно, напишем простое приложение, которое будет отправлять один GET-запрос в HTTP.

```python
import asyncio
from asyncio import Transport, Future, AbstractEventLoop
from typing import Optional


class HTTPGetClientProtocol(asyncio.Protocol):
	def __init__(self, host: str, loop: AbstractEventLoop):
		self._host: str = host
		self._future: Future = loop.create_future()
		self._transport: Optional[Transport] = None
		self._response_buffer: bytes = b''
	
	# Ждать внутренний будущий объект,
	# пока не будет получен ответ от севрера
	async def get_response(self):
		return await self._future

	def _get_request_bytes(self) -> bytes:
		request = f"GET / HTTP/1.1\r\n" \
		f"Connection: close\r\n" \
		f"Host: {self._host}\r\n\r\n"

		return request.encode()

	def connection_made(self, transport: Transport):
		print(f'Создано подключение к {self._host}')
		self._transport = transport
		# Использовать транспорт для отправки запроса
		self._transport.write(self._get_request_bytes())
		
	def data_received(self, data):
		print('Получены данные!')
		# Получив данные сохранить их в буфере
		self._response_buffer += data

	def eof_received(self) -> Optional[bool]:
		# После закрытия подключения завершить будущий объект
		# Скопировав в него данные из буфера
		self._future.set_result(self._response_buffer.decode())
		
		return False

  

def connection_lost(self, exc: Optional[Exception]) -> None:
	if exc is None:
		print('Подключение закрыто без ошибок')
	
	else:
		self._future.set_exception(exc)
```

Протокол создаёт подключение через сокет к указанному серверу и обёртывает его подходящим транспортным механизмом.
Помимо адреса и порта он принимает фабрику протоколов, т.е. функцию, которая создаёт экземпляры протоколов.


Использование протокола
```python
async def make_request(host: str, port: int, loop: AbstractEventLoop) -> str:
	def protocol_factory():
		return HTTPGetClientProtocol(host, loop)

	_, protocol = await loop.create_connection(
		protocol_factory,
		host=host,
		port=port
	)

	return await protocol.get_response()


async def main():
	loop = asyncio.get_running_loop()
	result = await make_request('www.example.com', 80, loop)
	print(result)

asyncio.run(main())
```


## Потоковые читатели и писатели

Такой контроль над низкоуровневыми API нужен далеко не всегда. Проектировщики asyncio понимали это и создали высокоуровневый API для потоков данных. Он инкапсулирует стандартные сценарии использования транспорта и протоколов в двух классах - StreamReader и StreamWriter.

Вместо непосредственного создания экземпляров - StreamReader и StreamWriter представляет библиотечную сопрограмму open_connection, которая делает это за нас. Она принимает сервер и порт, к которым надо подключиться, и возвращает кортеж из StreamReader и StreamWriter.

StreamReader - легко понять, один из его методов - сопрограмма readline, которая ждёт получения полной строки данных. Или же можно было бы использовать сопрограмму read, которая ждёт прихода заданного количества байтов.

StreamWritter - сложнее. В нём, есть метод write, но это обычная функция. Потоковый писатель старается сразу же записать в выходной буфер сокета, но этот буфер может быть заполнен. В таком случае данные сохраняются во внутренней очереди, откуда позднее копируются в буфер. И таким образом, возникает потенциальная проблема - вызов write необязательно отсылает данные немедленно.
Как дождаться момента, когда все данные будут отправлены? Для этого имеется метод drain. Эта сопрограмма блокирует выполнениеm пока все находящиеся в очереди данные не будут отправлены в сокет.

Принцип такой - после каждого write мы должны вызывать drain.

Пример
```python
import asyncio
from asyncio import StreamReader
from typing import AsyncGenerator

  
  

async def read_until_empty(stream_reader: StreamReader) -> AsyncGenerator[str, None]:
	# Читать и декорировать пока не закончатся символы
	while response := await stream_reader.readline():
	yield response.decode()

  
  

async def main():
	host: str = 'www.example.com'
	request = f"GET / HTTP/1.1\r\n" \
			f"Connection: close\r\n" \
			f"Host: {host}\r\n\r\n"
	stream_reader, stream_writer = await asyncio.open_connection(
		host, 80
	)

	try:
		# Записать http-запрос и опустошить буффер писателя
		stream_writer.write(request.encode())
		await stream_writer.drain()
		# Читать и сохранять в списке
		responses = [
		response async for response in read_until_empty(stream_reader)
		]
		print(''.join(responses))
	finally:
		# Закрыть писатель и ждать завершения закрытия
		stream_writer.close()
		await stream_writer.wait_closed()


asyncio.run(main())
```

## Неблокирующий ввод данных командной строки

Традиционно в Python для ввода данных используется input(). Однако asyncio однопоточная, а input() блокирует поток. Чтобы убедиться в этом напишем приложение, которое будет засыпать на столько, насколько напишет пользователь.

```python
import asyncio
from utils import delay


async def main():
	while True:
		delay_time = input('Введите время сна!')
		asyncio.create_task(delay(int(delay_time)))

asyncio.run(main())
```

Если бы код работал так, как мы ожидаем, то мы увидели бы что то вроде 'засыпаю на n с'.  Однако это не так - мы не видим ничего, кроме приглашения ввода. Всё дело в том, что тут нет await, а значит мы не можем войти в цикл событий. Можно было бы воспользоваться await asyncio.sleep(0) - этот приём называется уступка управления циклу событий (подробнее в главе 14). Но это не помогает, потому что input блокирует весь поток и не даёт фоновым задачам доработать до конца.

Варианта input для сопрограммы не существует, так что нужно искать что-то другое.
Воспользуемся протоколами и потоковыми читателями. У цикла событий asyncio имеется метод-сопрограмма connect_read_pipe, который подключает протокол в файлоподобному объекту. 
Метод принимает фабрику протоколов и канал.
Фабрика протоколов - функция, создавшая экземпляры протоколов, а канал - файлоподобный объект, имеющий методы read и write.

Сопрограмма connect_read_pipe подключает канал к протоколу, созданному фабрикой, так что данные из канала из канала передаются протоколу.

Стандартный sys.stdin - удовлетворяет требованиям для файлоподобного объекта. Передав его в connect_read_pipe мы получим кортеж, состоящий из протокола и транспорта ReadTransport.

Asyncio предоставляет служебный класс StreamReaderProtocol для соединения потоковых читателей с протоколами.

```python
import asyncio
from asyncio import StreamReader
import sys


async def create_stdin_reader():
	stream_reader = StreamReader()
	protocol = asyncio.StreamReaderProtocol(stream_reader)
	loop = asyncio.get_running_loop()
	
	await loop.connect_read_pipe(lambda: protocol, sys.stdin)

return stream_reader
```


Повторно используемая сопрограмма create_stdin_reader создаёт объект StreamReader, который мы будем использовать для асинхронного чтения стандартного ввода.

```python
import asyncio
from listing_8_5 import create_stdin_reader
from utils import delay


async def main():
	stdin_reader = await create_stdin_reader()

	while True:
		delay_time = await stdin_reader.readline()
		asyncio.create_task(delay(int(delay_time)))


asyncio.run(main())
```

Теперь программа работает корректно. Но решение не лучшее. Если сообщение появится в момент ввода, то мы увидим такую картину
```
3
засыпаю на 3 с
1111111 сон в течении 3 с закончился
11
```

Помимо печати во время ввода, буфер теперь содержит только 11, а остальные цифры утеряны. Всё дело в том, что терминал работает в режиме с обработкой, когда введённые пользователем данные копируются и обрабатываются спец. клавиши.

**Сопрограмма delay пишет на стандартный вывод одновременно с эхо-копированием ввода, что приводит к состоянию гонки.**

Также проблема и в курсоре, пока мы вводим данные, курсор находится в строке, в которой мы печатаем.

Для решения нужны 2 вещи:
* передать эхо копирование от терминала к приложению
* переместить курсор на время ввода


### Режим терминала без обработки и сопрограмма read
Нужно привести терминал в режим без обработки. В этом режиме терминал не занимается буферизацией данных, их предобработкой и эхо-копированием, а просто передаёт каждое нажатие клавиши приложению.

Python позволяет привести терминал не только в режим без обработки, но и в режим cbreak. Он отличается тем, что CTRL+C всё же интерпретируется, что избавляет нас от части работы.
Вход в режим при помощи setcbread из модуля tty
```
import tty
import sys
tty.setcbreak(sys.stdin)
```

Сопрограмма readline больше работать не будет, потому что в режиме без обработки вводимые данные не копируются на стандартный вывод. Мы должны читать по 1 символу при помощи потокового читателя (его метода read). Мы будем считывать по 1 символу, который затем сохраним в буфере.

Требования:
* Поле ввода должно всегда находиться в последней строке экрана
* Сообщения сопрограммы должны начинаться с верхней строки
* Когда уже на экране нет свободных строк для сообщений, уже выведенные сообщения должны прокручиваться вверх


Поскольку мы хотим прокручивать сообщения вверх, когда сообщений больше, чем доступных строк, запись на экран с print не годится.

Вместо этого воспользуемся двухсторонней очередью (декой). Максимальное число элементов - сделаем равно числу строк на экране терминала. Это позволит реализовать желаемое поведение при заполнении очереди, поскольку элементы в конце будут отбрасываться. Когда в очередь попадает сообщение, мы перерисовываем все сообщения, начиная с верхней точки экрана. Так мы реализуем прокрутку, не храня информацию о состоянии стандартного вывода.
![[Pasted image 20250721232637.png]]

План такой:
* Перемещаем курсор на последнюю строку экрана и, когда пользователь нажимает клавишу, добавлять её во внутренний буфер и эхо-копировать на стандартный ввод
* Когда жмётся Enter - создаётся задача delay, но не записывать выходные сообщения на стандартный вывод, а помещать их в очередь, максимальное число элементов в котором равно числу строк на экране
* После добавления сообщения в очередь перерисовывать экран. Для этого сначала переместить курсор в левую верхнюю позицию экрана. Затем вывести все находящиеся в очереди сообщения. И после этого вернуть курсор в ту позицию, где он был до этого

Вспомогательные функции для вывода управляющих последовательностей в терминале
```python
import sys
import shutil


def save_cursor_position():
	sys.stdout.write('\0337')


def restore_cursor_position():
	sys.stdout.write('\0338')


def move_to_top_of_screen():
	sys.stdout.write('\033[H')


def delete_line():
	sys.stdout.write('\033[2K')


def clear_line():
	sys.stdout.write('\033[2K\033[0G')


def move_back_one_char():
	sys.stdout.write('\033[1D')


def move_to_bottom_of_screen() -> int:
	_, total_rows = shutil.get_terminal_size()
	input_row = total_rows - 1
	sys.stdout.write(f'\033[{input_row}E')
	return total_rows

```

Имея функции для перемещения курсора по экрану, реализуем допускающую повторное использование сопрограмму для чтения одного символа из стандартного ввода. Для этого воспользуемся сопрограммой read. Прочитав символ, мы записываем его на стандартный вывод и сохраняем во внутреннем буфере. Мы также хотим обрабатывать нажатие Delete, поэтому следим за её появлением. После Delete удаляем символ из буфера и из стандартного вывода.

```python
import sys
from asyncio import StreamReader
from collections import deque
from chapter_8.listing_8_7 import move_back_one_char, clear_line


async def read_line(stdin_reader: StreamReader) -> str:
	# Функция удаления предыдщуео символа из стандартного вывода
	def erase_last_chat():
		move_back_one_char()
		sys.stdout.write(' ')
		move_back_one_char()

	delete_char = b'\x7f'
	input_buffer = deque()

	while (input_char := await stdin_reader.read(1)) != b'\n':
		# Если введём символ delete, то удалить предыдущий символ
		if input_char == delete_char:
			if len(input_buffer) > 0:
				input_buffer.pop()
				erase_last_chat()
				sys.stdout.flush()
			else:
				# Все символы, кроме delete, добавляются
				# в конец буфера и эхо-копируются
				input_buffer.append(input_char)
				sys.stdout.write(input_char.decode())
				sys.stdout.flush()

	clear_line()
	return b''.join(input_buffer).decode()
```

Следующий шаг - реализация очереди, в которой будет храниться сообщение для записи на стандартный вывод. Поскольку мы хотим перерисовать экран после добавления каждого сообщения, то определим класс, который обёртывает двустороннюю очередь и принимает допускающий ожидание объект обратного вызова. Этот объект будет отвечать за перерисовку экрана. Также добавим в класс метод-сопрограмму append, который будет добавлять элементы в конец двусторонней очереди и вызывать обратный вызов, передавая ему текущее содержимое очереди

```python
from collections import deque


class MessageStore:
	def __init__(self, callback, max_size):
		self._deque = deque(maxlen=max_size)
		self._callback = callback

	async def append(self, item):
		self._deque.append(item)
		await self._callback(self._deque)
```

Теперь перепишем метод delay, чтобы он добавлял сообщения в хранилище. В main создадим вспомогательную сопрограмму, которая будет перерисовывать экран из очереди. Эту сопрограмму будем передавать нашему классу MessageStore в качестве обратного вызова. Затем воспользуемся ранее написанной сопрограммой  read_line, которая принимает от пользователя данные и создаёт задачу delay при нажатии Enter.
```python
import asyncio
import tty
import os
from collections import deque
from chapter_8.listing_8_5 import create_stdin_reader
from chapter_8.listing_8_7 import *
from chapter_8.listing_8_8 import read_line
from chapter_8.listing_8_9 import MessageStore


async def sleep(delay:int, message_store: MessageStore):
	await message_store.append(f'Начало задержки {delay}')
	await asyncio.sleep(delay)
	await message_store.append(f'Конец задержки {delay}')


async def main():
	tty.setcbreak(sys.stdin)
	os.system('clear')

	rows = move_to_top_of_screen()
	# Обратный вызов, который перемещает курсор в начало
	# экрана, перерисовывает экран и возвращает курсор обратно
	async def redraw_output(items: deque):
		save_cursor_position()
		move_to_top_of_screen()

		for item in items:
			delete_line()
			print(item)

		restore_cursor_position()

  
	messages = MessageStore(redraw_output, rows - 1)
	stdin_reader = await create_stdin_reader()

	while True:
		line = await read_line(stdin_reader)
		delay_time = int(line)
		asyncio.create_task(sleep(delay_time, messages))

asyncio.run(main())
```

Теперь мы сможем создавать задержки и видеть, как сообщения выводятся на консоль, даже во время ввода данных. Это конечно сложнее, чем первая попытка, зато нет проблем с записью на стандартный вывод.

Приведём более реалистичный пример с асинхронным SQL-клиентом
```python
import asyncio
import asyncpg
import tty
import os
from asyncpg.pool import Pool
from collections import deque
from chapter_8.listing_8_5 import create_stdin_reader
from chapter_8.listing_8_7 import *
from chapter_8.listing_8_8 import read_line
from chapter_8.listing_8_9 import MessageStore


async def run_query(query: str, pool: Pool, message_store: MessageStore):
	async with pool.acquire() as connection:
	try:
		result = await connection.fetch_row(query)
		await message_store.append(f'Выбрано {len(result)} строк по запросу')
	except Exception as e:
		await message_store.append(f'Получено исключение {e} от: {query}')


async def main():
	tty.setcbreak(sys.stdin)
	os.system('clear')

	rows = move_to_bottom_of_screen()

	# Обратный вызов, который перемещает курсор в начало
	# экрана, перерисовывает экран и возвращает курсор обратно

	async def redraw_output(items: deque):
		save_cursor_position()
		move_to_top_of_screen()

		for item in items:
			delete_line()
			print(item)
		restore_cursor_position()

	messages = MessageStore(redraw_output, rows - 1)
	stdin_reader = await create_stdin_reader()

  
	async with asyncpg.create_pool(
		host='127.0.0.1',
		port=5432,
		user='postgres'
		password='postgres',
		database='products',
		min_size=6,
		max__size=6
	) as pool:
		while True:
			query = await read_line(stdin_reader)
			asyncio.create_task(run_query(query, pool, messages))

  

asyncio.run(main())
```

## Создание серверов

Для создания сервера asyncio предоставляет более высокоуровневый api - **asyncio.start_server**. Она принимает несколько факультативных параметров, например для настройки SSL, но нас прежде всего интересует host, port и cleimt_connected_cb.

client_connected_cb - это функция или сопрограмма обратного вызова, которая вызывается, когда к серверу подключился клиент. Она принимает объекты StreamReader и StreamWriter, позволяющие читать данные от клиента и записывать для него ответные данные.
При выполнении await start_server мы получаем объект AbstractServer. Ему не достаёт много нужных методов, но есть serve_forever, который исполняет код сервера, пока мы не остановим его. Он также  является контекстным менеджером, т.е. может употребляться в конструкции async with, гарантирующей корректную остановку сервера при завершении сопрограммы.

Пример эхо сервера
```python
import asyncio
import logging
from asyncio import StreamReader, StreamWriter


class ServerState:
	def __init__(self):
		self._writers = []

	# Добавить клиента в состояние сервера и создать задачу эхо-копирования
	async def add_client(self, reader: StreamReader, writer: StreamWriter):
		self._writers.append(writer)
		await self._on_connect(writer)
		asyncio.create_task(self._echo(reader, writer))

	# После подключения нового клиента сообщить ему, сколько клиентов
	# подключено и уведомить остальных о новом пользователе
	async def _on_connect(self, writer: StreamWriter):
		writer.write(
			f'Добро пожаловать! Число подключённых пользователей
			{len(self._writers)}!\n'.encode()
		)
		await writer.drain()
		await self._notify_all('Подключился новый пользователь!\n')

  

	# Обработка эхо-копирования ввода при отключении клиента
	async def _echo(self, reader: StreamReader, writer: StreamWriter):
		try:
			while (data := await reader.readline()) != b'':
				writer.write(data)
				await writer.drain()
			self._writers.remove(writer)
			await self._notify_all(
				f'Клиент отключился. Осталось пользователей: 
				{len(self._writers)}!\n'
			)

		except Exception as e:
			logging.exception('Ошибка чтения данных от клиента.', exc_info=e)
		self._writers.remove(writer)

	async def _notify_all(self, message: str):
		for writer in self._writers:
			try:
				writer.write(message.encode())
				await writer.drain()
			except ConnectionError as e:
				logging.exception('Ошибка записи данных клиенту.', exc_info=e)
				self._writers.remove(writer)

  

async def main():
	server_state = ServerState()
	async def client_connected(
		reader: StreamReader, writer: StreamWriter
	) -> None:
		await server_state.add_client(reader, writer)

	server = await asyncio.start_server(client_connected, '127.0.0.1', 8000)

	async with server:
		await server.serve_forever()


asyncio.run(main())
```


