Вопросы:
* Основы синтаксиса async await и сопрограмм
* Конкурентное выполнение сопрограммы с помощью задач
* Снятие задач
* Создание цикла событий вручную
* Измерение времени выполнения сопрограммы
* Наблюдение за проблемами при выполнении сопрограмм


## Знакомство с сопрограммами

Сопрограмму можно рассматривать как обычную функцию в Python, наделённую сверхспособностью: **приостанавливаться, встретив операцию, для которой нужно заметное время. По завершению такой операции сопрограмму можно "пробудить", после чего она продолжит выполнение. Пока приостановленная сопрограмма ждёт завершения операции, мы можем выполнять другой код**. Для создания и приостановки сопрограммы нам придётся использовать ключевые слова Python async и await. **Слово async определяет сопрограмму, а слово await приостанавливает её на время выполнения длительной операции.**

Сопрограммы не выполняются, если их вызвать напрямую. Вместо этого возвращается объект сопрограммы, который будет выполнен позже. **Для запуска сопрограммы стоит использовать asyncio.run()**.

Пример
```python
import asyncio


async def coroutine_add_one(number: int) -> int:
	return number + 1

coroutine_res = asyncio.run(coroutine_add_one(1))

print(f'Результат сопрограммы равен {coroutine_res}, а его тип равен {type(coroutine_res)}')
```

asyncio.run() делает несколько вещей:
1. Создаёт новое событие. Потом она выполняет код переданной сопрограммы до конца  и возвращает результат. 
2. Подчищает всё, что могло остаться после завершения сопрограммы
3. Останавливает и закрывает цикл событий

**asyncio.run() задумана как главная точка входа в созданное нами приложение asyncio.**

### Приостановка выполнения с помощью ключевого слова await

**asyncio** может приостановить выполнение и дать циклу событий возможность выполнить другие задачи, пока длительная операция делает своё дело. Для приостановки выполнения стоит воспользоваться ключевым словом **await**, за ним обычно следует обращение к сопрограмме (точнее к объекту который *допускает ожидание*, который необязательно является сопрограммой).

Использование ключевого слова **await** приводит к выполнению следующей за ним сопрограммы, а не просто к возврата объекту сопрограммы, как при прямом вызове. 
Кроме этого **await** приостанавливает объемлющую сопрограмму до того момента, как сопрограмма, которую мы ожидаем, завершится и вернёт результат.
А после мы получим доступ к возвращённому результату, а объемлющая сопрограмма пробудится и обработает результат.

Ключевое слово await следует поместить перед вызовом сопрограммы.

Пример:
```python
# Использование await для ожидания результата сопрограммы
import asyncio


async def add_one(number: int) -> int:
	return number + 1
  

async def main() -> None:
	one_plus_one = await add_one(1) # Приостановить и ждать результата
	two_plus_one = await add_one(2) # Приостановить и ждать результата


print(one_plus_one)
print(two_plus_one)

asyncio.run(main())
```

![[Pasted image 20250114162941.png]]

Этот код работает так же, как и обычный последовательный код. 


## Моделирование длительных операций с помощью sleep

Для моделирования длительный операций можно использовать **asyncio.sleep().** Она заставляет сопрограмму "заснуть" на заданное количество секунд, т.е. приостанавливает её на заданное время.

**asyncio.sleep() сама является сопрограммой, поэтому её стоит вызывать с await**

Пример 
```python
# Первое применение sleep
import asyncio


async def hello_world_message() -> str:
	await asyncio.sleep(1)
	return 'Hello world!'


async def main() -> None:
	message = await hello_world_message()
	print(message)


asyncio.run(main())
```

Эта сопрограмма ждёт 1с, а затем печатает сообщение "Hello world!". Поскольку hello_world_message - сопрограмма, а мы приостанавливаем её на 1 с, у нас появляется одна секунда, в течении которой мог бы конкурентно работать другой код.


Пример для двух сопрограмм
```python
# Выполнение двух сопрограмм
import asyncio
from utils import delay


async def add_one(number: int) -> int:
	return number + 1
  

async def hello_world_message() -> str:
	await delay(1)
	return 'Hello world!'


async def main() -> None:
	message = await hello_world_message() # Приостановить main до возврата 
	one_plus_one = await add_one(1) # Приостановить main до возврата
	
	print(one_plus_one)
	print(message)

asyncio.run(main())
```

![[Pasted image 20250114163958.png]]
**В данном случае код ведёт себя как последовательный.**

**И main, и hello_world_message приостановлены в ожидании delay(1). А когда это случится, main возобновляется и может выполнить add_one.

Хотелось бы уйти от последователньой модели и выполнять add_one конкурентно с hello_world_message.

**ДЛЯ ЭТОГО СТОИТ ИСПОЛЬЗОВАТЬ КОНЦЕПЦИЮ ЗАДАЧ**


## !!! Конкурентное выполнение с помощью задач (важно)

**Задача** - это обёртка вокруг сопрограммы, которая планирует выполнение последней (имеется ввиду сопрограммы) в цикле событий как можно раньше. 

**И планирование, и выполнение происходят в неблокирующем режиме, т.е. создав задачу мы можем сразу приступить к выполнению другого кода, пока эта задача работает на фоне** (в отличии от прямого вызова с await).

**Способность создавать задачи и планировать их для немедленного выполнения в цикле событий означает, что несколько задач может работать приблизительно в одно и то же время. Пока одна задача выполняет длительную операцию, другие могут работать конкурентно**.

### Основы создания задач
**Для создания задач используется asyncio.create_task()**.

Пример
```python
# Создание задачи
import asyncio
from utils import delay


async def main():
	sleep_for_three = asyncio.create_task(delay(3))
	print(type(sleep_for_three))
	result = await sleep_for_three
	print(result)

asyncio.run(main())
```

Здесь мы создали задачу, для выполнения которой нужно 3с. Кроме того мы печатаем тип задачи, в данном случае `<class '_asyncio.Task'>`.
Следует отметить, что предложение о печати отправляется выполняется сразу после запуска (имеется ввиду `print(type(sleep_for_three))`), если бы мы просто использовали вызов с await, то увидели бы сообщение только спустя 3 секунды.

Напечатав сообщение мы применяем await к задаче sleep_for_three. Это приостанавливает сопрограмму main до получения результата.

### Конкурентное выполнение нескольких задач

Пример
```python
# Конкурентное выполнение нескольких задач
import asyncio
from utils import delay
import time


async def main():
	start = time.time()
	
	sleep_for_three = asyncio.create_task(delay(3))
	sleep_again = asyncio.create_task(delay(3))
	sleep_one_more = asyncio.create_task(delay(3))
	
	await sleep_for_three
	await sleep_again
	await sleep_one_more

	end = time.time()
	
	print(f'Время выполнения {end-start:.4f}') # ~ 3 секунды


asyncio.run(main())
```


Здесь мы запустили 3 задачи, каждой для завершения нужно 3 секунды. Каждое обращение к create_task возвращает управление немедленно, поэтому до  
await sleep_for_three мы доходим сразу же.

Ранее сказали, что выполнение задач планируется как можно раньше. На практике это означает, что в точке, где хранится первое после создания задачи предложение await, все ожидающие задачи начинают выполнятся, т.к. await запускает очередную итерацию цикла событий.

**Поскольку первым мы встречаем await sleep_for_three все три задачи начинают выполняться и засыпают одновременно. Значит, программа завершится примерно за 3с (в отличии от 9с в синхронной версии). Конкурентность позволила уменьшить время работы в три раза!!!**

![[Pasted image 20250114165921.png]]

**Примчение**
Это превосходство будет расти по мере увеличения числа задач; если бы мы запустили 10 таких задач, то программа работала бы те же 3с, что дало бы 10-кратное увеличение.

**Пока один код ожидает, можно было бы выполнить другой. Допустим, мы хотим один раз в секунду печатать сообщение о состоянии, пока какие-то длительные задачи работают.**

Пример с выполнением кода, когда другие операции простаивают.
```python
# Выполнение кода, пока другие операции работают на фоне
import asyncio
from utils import delay


async def hello_every_second():
	for _ in range(2):
		await asyncio.sleep(1)
		print('Пока я жду, исполняется другой код')


async def main():
	first_delay = asyncio.create_task(delay(3))
	second_delay = asyncio.create_task(delay(3))
	
	await hello_every_second()
	await first_delay
	await second_delay

asyncio.run(main())
```

Сначала мы запускаем две задачи, работающие по 3с. Пока эти задачи проставивают, мы видим, что каждую секунду печатается "Пока я жду, исполняется другой код". Это значит, что даже во время выполнения длительных операций наше приложение может выполнять другие задачи.


![[Pasted image 20250114170515.png]]

**Потенциальная проблема заключается в том, что задача может работать неопределённо долго.  Может возникнуть ситуация, когда захочется остановить задачу. Такая возможность поддерживается и называется СНЯТИЕМ**.


## Снятие задач и задание тайм-аутов

В рассмотренных примерах если бы задачи работали вечно, то мы бы застряли в предложении await без всякой обратной связи и остановить бы задачу просто не смогли. 

В библиотеке asyncio предусмотрены обе ситуации - мы можем снять задачу и задать тайм-аут.

### Снятие задачи

У каждого объекта задачи есть метод `.cancel()`, который можно вызвать если требуется приостановить задачу. В результате снятия задача возбудит исключение CanceledError, когда мы ждём её с помощью await. Это исключение можно обработать, как того требует ситуация.

Пример
```python
# Снятие задачи
import asyncio
from asyncio import CancelledError
from utils import delay
  

async def main():
	long_task = asyncio.create_task(delay(10))
	second_elapsed = 0

	while not long_task.done(): # Проверка на готовность
		print('Задача не закончилась, следующая проверка через секунду')
		await asyncio.sleep(1)
		second_elapsed = second_elapsed + 1

		if second_elapsed == 5:
			long_task.cancel() # Отмена задачи

		try:
			await long_task
		except CancelledError:
			print('Задача снята')

asyncio.run(main())
```


### Задание тайм-аута и снятие с помощью wait_for

Постоянно проверять состояние - не лучшая стратегия. В идеале хотелось бы иметь вспомогательную функцию, которая позволяла бы взять тайм-аут и снять задачу по его истечении.

В asyncio есть такая возможность в виде функции **asyncio.wait_for**. Она принимает объект сопрограммы или задачи и тайм-аут в секундах и возвращает сопрограмму, к которой можно применить await.

Если задача не завершилась в условленное время, то возбуждается `asyncio.exceptions.TimeoutError` и задача автоматически снимается.

```python
# Задание таймаута с помощью wait_for
import asyncio
from utils import delay


async def main():
	delay_task = asyncio.create_task(delay(2))

	try:
		result = await asyncio.wait_for(delay_task, timeout=1)
		print(result)
	except asyncio.exceptions.TimeoutError:
		print('Тайм-аут!')	
		print(f'Задача была снята? {delay_task.cancelled()}')


asyncio.run(main())
```


Также задачи можно защитить от снятия при помощи `asyncio.shield`.
```python
# Защита задачи от снятия
import asyncio
from utils import delay


async def main():
	task = asyncio.create_task(delay(10))
	try:
		result = await asyncio.wait_for(asyncio.shield(task), 5)
		print(result)
	except asyncio.exceptions.TimeoutError:
		print('Задача заняла более 5 с, скоро она закончится')
		result = await task
		print(result)


asyncio.run(main())
```


## Задачи, сопорограммы, будущие объекты и объекты, допускающие ожидание


### Введение в будущие объекты

Объект **future** в Python содержит одно значение, которое мы ожидаем получить в будущем, но пока не получили. Обычно в момент создания **future** не обретает никакого значения, потому что его ещё не существует. Объект в таком состоянии называется неполным, неразрешимым или просто неготовым. И только получив результат, мы можем установить значение объекта **future**, в результате чего он становится полным и из него можно извлечь результат.

Пример
```python
# Основы будущих объектов
from asyncio import Future


my_future = Future()
print(f'my_future готов? {my_future.done()}')

my_future.set_result(42)
print(f'my_future готов? {my_future.done()}')

print(f'Результат {my_future.result()}')
```

Для создания объекта future нужно вызвать его конструктор. В этот момент в future нет никакого результата, поэтому вызов метода done возвращает False. Затем мы устанавливаем значение future методом set_result, который помечается как готовый.

**Причение**. Если вызвать result прежде, чем результат будет установлен, то будет возбуждено исключение InvalidState.

Будущие объекты также можно использовать в выражениях await. Это означает "я посплю, пока в будущем объекта не появится значение, а когда оно будет готово, разбуди и дай мне с ним поработать."

### Связь между будущими объектами, задачами и сопрограммами

Связующим звеном между ними является абстрактный базовый класс Awaitable. В нём определён единственный абстрактный метод `__await__`. Мы не будем вдаваться в детали того, как создавать собственные объекты, допускающие ожидание, а просто скажем, что любой объект, который реализует метод `__await__`, можно использовать в выражении await. Сопрограммы, как и будущие объекты, наследую Awaitable напрямую.

![[Pasted image 20250115141344.png]]

**Далее будет называть объекты в выражениях await - допускающими ожидание (awaitable).**


### Ловушки сопрограмм и задач

В программе могут быть функции, которые выполняют счётный код. Выполнять такой код асинхронно - не лучшая идея (из-за GIL).

Пример 
```python
# Попытка конкурентного выполнения счётного кода
import asyncio
from utils import async_timed


@async_timed()
async def cpu_bound_work() -> int:
	counter = 0
	for _ in range(100000000):
		counter += 1

	return counter


@async_timed()
async def main():
	task_one = asyncio.create_task(cpu_bound_work())
	task_two = asyncio.create_task(cpu_bound_work())

	await task_one
	await task_two

asyncio.run(main())

# выполняется <function main at 0x10a8f6c10> с аргументами () {}
# выполняется <function cpu_bound_work at 0x10a8c0430> с аргументами () {}
# <function cpu_bound_work at 0x10a8c0430> завершилась за 4.6750 с
# выполняется <function cpu_bound_work at 0x10a8c0430> с аргументами () {}
# <function cpu_bound_work at 0x10a8c0430> завершилась за 4.6680 с
# <function main at 0x10a8f6c10> завершилась за 9.3434 с
```

Выполнение кода займёт столько же времени, сколько и синхронный код. В таком случае просто расставить везде async/await кажется не таким критичным. **Однако такой подход может привести к снижению производительности приложения (в том случае, если есть другие сопрограммы или задачи, в которых встречается await).**

```python
# Счётный код и длительная задача
import asyncio
from utils import async_timed, delay


@async_timed()
async def cpu_bount_work() -> int:
	counter = 0

	for _ in range(100000000):
		counter += 1

	return counter


@async_timed()
async def main():
	task_one = asyncio.create_task(cpu_bount_work())
	task_two = asyncio.create_task(cpu_bount_work())
	task_three = asyncio.create_task(delay(4))

	await task_one
	await task_two
	await task_three


asyncio.run(main())
```



Также может возникнуть соблазн использовать существующие библиотеки ввода-вывода, обернув их сопрограммами. Однако эти библиотеки будут блокировать главной поток.

Базовым пример является ошибочное использование requests в асинхронном коде (библиотека requests блокирующая). 

Пример
```python
# Неправильное использование блокирующего API как сопрограммы
import asyncio
import requests
from utils import async_timed


@async_timed()
async def get_example_status() -> int:
	return requests.get('https://www.example.com')


@async_timed()
async def main():
	task_one = asyncio.create_task(get_example_status())
	task_two = asyncio.create_task(get_example_status())
	task_three = asyncio.create_task(get_example_status())

	await task_one
	await task_two
	await task_three

asyncio.run(main())
```


## Ручное управление циклом событий

* Мы можем создать цикл событий вручную, воспользовавшись методом **asyncio.new_event_loop**. Он возвращает экземпляр цикла событий, который даёт доступ ко всем низкоуровневым методам, в частности методу **run_until_complete**, который принимает сопрограмму и исполняет до её завершения. Закончив работу с циклом событий мы должны закрыть его, чтобы освободить занятые ресурсы. Обычно это делается в блоке finally, чтобы цикл был закрыт в случае исключения. 
  
  ```python
# Создание цикла событий вручную
import asyncio


async def main():
	await asyncio.sleep(1)
	
	loop = asyncio.new_event_loop()

	try:
		loop.run_until_complete(main())
	finally:
		loop.close()
  ```

* Иногда бывает необходимо получить доступ к текущему циклу событий. Библиотека asyncio предоставляет для этой цели **get_running_loop**. В качестве примера рассмотрим метод call_soon, который планирует выполнение функции на следующей итерации цикла событий.
```python
# Получение доступа к циклу событий
import asyncio
from utils import delay


def call_later():
	print('Меня вызовут в близжайшем будущем')


async def main():
	loop = asyncio.get_running_loop()	
	loop.call_soon(call_later)
	
	await delay(1)


asyncio.run(main())
```


## Отладочный режим

* Функция asyncio.run() имеет параметр debug (по умолчанию False), но если он равен True, то активируется отладочный режим.

Выполнение счётного кода в отладочном режиме
```python
# Выполнение счётного кода в отладочном режиме
import asyncio
from utils import async_timed


@async_timed()
async def cpu_bound_work() -> int:
	counter = 0
	
	for _ in range(100000000000):
		counter += 1
	
	return counter
 

async def main():
	task_1 = asyncio.create_task(cpu_bound_work())
	
	await task_1
	

asyncio.run(main(), debug=True)
```

При запуске этой программы мы увидим сообщение о том, что задача task_one работает слишком долго и, следовательно, блокирует цикл событий, не давая ему выполнять другие задачи.

Пример вывода 
```python
Executing <Task finished name='Task-2' coro=<cpu_bound_work() done, defined
at listing_2_9.py:5> result=100000000 created at tasks.py:382> took 4.829
seconds
```


По умолчанию параметры задаются так, что предупреждение выдаётся через 100мс. Однако это можно изменить:
```python
# Изменение продолжительности медленного обратного вызова
import asyncio


async def main():
	loop = asyncio.get_event_loop()
	loop.slow_callback_duration = .250

asyncio.run(main(), debug=True)
```


## Резюме
* Сопрограммы создаются с помощью ключевого слова async. Она может приостановить себя встретив блокирующую операцию. Это даёт возможность поработать другим сопрограммам. После завершения операции, она пробуждается и продолжает работу с указанного места.
* Вызову сопрограммы должно предшествовать ключевое слово await, означающее, что нужно дождаться возврата значения. При этом сопрограмма, внутри которой встретилось слово await, приостанавливается в ожидании результата. В это время могут работать и другие сопрограммы.
* Точкой входа является функция asyncio.run(), она же запускает сопрограмму.
* Задачи - это обёртки вокруг сопрограмм, которые исполняются в цикле событий. Созданная задача планирует выполниться как можно раньше.
* Задачи можно снять при помощи .cancel и проверить их готовность с помощью .done. После снятия задачи возбуждается исключение CancelledError, когда мы ожидаем результат.
* Если имеются ограничения на время работы задачи, то можно задать тайм-аут в методе asyncio.wait_for.
* Типичные ошибки для начинающих в asycnio:
	1. Выполнение счётного кода в сопрограммах
	2. Блокирующий ввод-вывод
* Отладочный режим запускается при помощи debug=True в asyncio.run()


