
Вопросы:
* Асинхронное выполнение нескольких подпроцессов
* Обработка стандартного вывода подпроцесса
* Взаимодействие с подпроцессами с помощью стандартного ввода
* Предотвращение взаимоблокировок и других подводных камней в подпроцессах


## Создание подпроцесса

Пусть требуется расширить функциональность существующего API, на Python. При это другая команда уже разработала нужную нам функциональность на другом языке.

Поскольку у приложения имеется командный интерфейс, мы можем запустить его в отдельном подпроцессе, а затем прочитать полученные результаты и использовать его в нашем API.

Библиотека asyncio предлагает две сопрограммы для создания подпроцессов:
* create_subprocess_shell
* create_subprocess_exec
Обе возвращают экземпляр класса Process, имеющего наряду с прочими, методы для завершения и ожидания процесса.

Сопрограмма create_subprocess_shell создаёт подпроцесс внутри установленной в системе оболочки, например zsh или bash. Вообще говоря тоже самое делает и create_subprocess_exec и лучше использовать именно его, если не нужна функциональность оболочки.

Пример работы с подпроцессами
```python
import asyncio  
from asyncio.subprocess import Process  
  
  
async def main():  
    process: Process = await asyncio.create_subprocess_exec('ls', '-l')  
    print(f'pid процесса {process.pid}')  
    status_code = await process.wait()  
    print(f'Код состояния: {status_code}')  
  
  
asyncio.run(main())
```

Создав процесс мы печатаем его pid и вызываем сопрограмму wait. Она будет ждать завершения процесса, после чего вернёт код его состояния, в данном случае он должен быть равен нулю.

Заметим, что сопрограмма wait блокирует выполнение, до тех пор пока подпроцесс не завершится, а никаких гарантий касательно времени его работы нет.
Если беспокоит таймаут, что можно воспользоваться asyncio.wait_for, однако завершится только задача, а не весь процесс. Если нужно остановить процесс, то класс Process даёт два метода для этого:
* kill - по сути SIGKILL
* terminate - по сути SIGTERM

Оба метода неблокирующие и сопрограммами не являются. Они просто посылают сигнал. Если вы хотите получить код состояния завершившегося подпроцесса или дождаться завершения, чтобы произвести какую-то очистку, то нужно ещё раз вызвать wait.

```python
import asyncio  
from asyncio.subprocess import Process  
  
  
async def main():  
    process: Process = await asyncio.create_subprocess_exec('sleep', '3')  
    print(f'pid процесса: {process.pid}')  
  
    try:  
        status_code = await asyncio.wait_for(process.wait(), timeout=1)  
        print(status_code)  
    except asyncio.TimeoutError:  
        print('Тайм-аут, завершаю принудительно ...')  
        process.terminate()  
        status_code = await process.wait()  
        print(status_code)  
  
asyncio.run(main())
```

**Важно иметь ввиду, что вызов wait внутри блока except тоже может работать долго, если это вас беспокоит, оберните его в wait_for**


### Управление стандартным выводом

У сопрограммы create_subprocess_exec есть параметр stdout, позволяющий указать, куда направлять стандартный вывод подпроцесса: на наш собственный стандартный вывод, соединить каналом со StreamReader или игнорировать, перенаправить в /dev/null.

Попробуем предпослать каждой выведенной строке сведения о породившем его процессе, а именно команду и её аргументы.
Для этого первым делом присвоим параметры stdout значение asyncio.subprocess.PIPE. Это значит, что подпроцесс должен создать новый экземпляр класса StreamReader, который должен будет использовать для чтения вывода процесса. Доступ к этому экземпляру даёт поле Process.stdout.

```python
import asyncio  
from asyncio import StreamReader  
from asyncio.subprocess import Process  
  
  
async def write_output(prefix: str, stdout: StreamReader):  
    while line := await stdout.readline():  
        print(f'[{prefix}]: {line.rstrip().decode()}')  
  
  
async def main():  
    program = ['ls', '-la']  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE  
    )  
  
    print(f'pid процесса: {process.pid}')  
    stdout_task = asyncio.create_task(  
        write_output(' '.join(program),  
        process.stdout  
    ))  
  
    return_code, _ = await asyncio.gather(process.wait(), stdout_task)  
    print(f'Процесс вернул: {return_code}')  
  
  
asyncio.run(main())
```

Важная особенность использования каналов и вообще работы с вводом и выводом подпроцессов - возможность взаимоблокировок. Особенно этому подвержена сопрограмма wait в случае, когда процесс порождает большой объём вывода, а его потребление организованно некоректно.

```python
import sys  
  
  
[sys.stdout.buffer.write(b'HI!!\n') for _ in range(1000000)]  
sys.stdout.flush()
```

Здесь мы 1000000 раз записываем данные в буфер стандартного ввода. Посмотрим, что будет при организации канала связи. 

```python
import asyncio  
from asyncio.subprocess import Process  
  
  
async def main():  
    program = ['python3', 'listing_13_4.py']  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE  
    )  
  
    print(f'pid процесса: {process.pid}')  
  
    return_code = await process.wait()  
    print(f'Процесс вернул: {return_code}')  
  
asyncio.run(main())
```

Запустив мы увидим только pid. Приложение зависнет навсегда и завершить его можно только принудительно.

Проблема связана с взаимоблокировками. Когда буфер заполнен, любая попытка записать в него ещё что-то приводит к блокированию до освобождения места в буфере. Хотя буфер и полон, процесс не оставляет попыток впихнуть в него все свои данные.
Проблему можно решить, если использовать вместо wait метод-сопрограмму communicate, который вообще избегает взаимоблокировок. Он блокирует выполнение, пока подпроцесс не завершится и конкурентно потребляет stdout и stderr, возвращая всё, что было выполнено в процессе работы.

```python
import asyncio  
from asyncio.subprocess import Process  
  
  
async def main():  
    program = ['python3', 'listing_13_4.py']  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE  
    )  
  
    print(f'pid процесса: {process.pid}')  
    stdout, stderr = await process.communicate()  
    print(stdout)  
    print(stderr)  
    print(f'Процесс вернул: {process.returncode}')  
  
asyncio.run(main())
```


## Конкурентное выполнение подпроцессов

Пусть требуется зашифровать несколько фрагментов текста, хранящегося в памяти и для пущей безопасности использовать шифр Twofish.

```bash
echo 'encrupt this!' | gpg -c --batch --passphrase 3ncryptm3 --cipher-algo TWOFISH
```

Это нельзя сделать при помощи create_subprocess_exec, поскольку | недоступен.

Однако метод communicate и wait позволяют организовать канал со стандартным выводом и стандартным выводом ошибок.

```python
import asyncio  
import random  
import string  
import time  
from asyncio.subprocess import Process  
  
  
async def encrypt(text: str) -> bytes:  
    program = ['gpg', '-c', '--batch', '--passphrase', '3ncryptm3', '--cipher-algo', 'TWOFISH']  
  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE,  
        stdin=asyncio.subprocess.PIPE  
    )  
  
    stdout, stderr = await process.communicate(text.encode())  
    return stdout  
  
  
async def main():  
    text_list = [  
        ''.join(random.choice(string.ascii_letters) for _ in range(1000))  
        for _ in range(100)  
    ]  
    s = time.time()  
    tasks = [asyncio.create_task(encrypt(text)) for text in text_list]  
    encrypted_text = await asyncio.gather(*tasks)  
    e = time.time()  
  
    print(f'Время работы: {e - s}')  
    print(encrypted_text)  
  
asyncio.run(main())
```

Однако этот метод тоже не очень. Помимо того, что мы создали кучу процессов, пожирающих ресурсы, так они ещё и блокируются. Вот удобный случай для семафора

```python
import asyncio  
import random  
import string  
import time  
import os  
from asyncio import Semaphore  
from asyncio.subprocess import Process  
  
  
async def encrypt(sem: Semaphore, text: str) -> bytes:  
    program = ['gpg', '-c', '--batch', '--passphrase', '3ncryptm3', '--cipher-algo', 'TWOFISH']  
  
    async with sem:  
        process: Process = await asyncio.create_subprocess_exec(  
            *program,  
            stdout=asyncio.subprocess.PIPE,  
            stdin=asyncio.subprocess.PIPE  
        )  
        stdout, stderr = await process.communicate(text.encode())  
  
        return stdout  
  
  
async def main():  
    text_list = [  
        ''.join(random.choice(string.ascii_letters)  
        for _ in range(1000))  
        for _ in range(100)  
    ]    semaphore = Semaphore(os.cpu_count())  
    s = time.time()  
    tasks = [asyncio.create_task(encrypt(semaphore, text)) for text in text_list]  
    encrypted_text = await asyncio.gather(*tasks)  
    e = time.time()  
  
    print(f'Время работы: {e - s}')  
  
asyncio.run(main())
```


## Взаимодействие с подпроцессами

До сих пор взаимодействие с подпроцессами было односторонним, но что если от нас требуется ввод данных.

Если есть всего один элемент, то communicate идеально подходит.
Имитация программы (echo)
```python
username = input('Введите имя')  
print(f'Вы ввели имя {username}')
```


Пример 
```python
import asyncio  
from asyncio.subprocess import Process  
  
  
async def main():  
    program = ['python3', 'listing_13_9.py']  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE,  
        stdin=asyncio.subprocess.PIPE  
    )  
  
    stdout, stderr = await process.communicate(b'Zoot')  
    print(stdout)  
    print(stderr)  
  
asyncio.run(main())
```

Рассмотрим приложение сложнее. Оно в цикле запрашивает и копирует их на стандартный вывод, пока пользователь не снимет программу.

Имитация (echo)
```python
user_input = ''  
  
while user_input != 'quit':  
    user_input = input('Введите текст: ')  
    print(user_input)
```

Пример
```python
import asyncio  
from asyncio import StreamReader, StreamWriter  
from asyncio.subprocess import Process  
  
  
async def consume_and_send(text_list, stdout: StreamReader, stdin: StreamWriter):  
    for text in text_list:  
        line = await stdout.read(2048)  
        print(line)  
        stdin.write(text.encode())  
        await stdin.drain()  
  
  
async def main():  
    program = ['python3', 'listing_13_11.py']  
  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE,  
        stdin=asyncio.subprocess.PIPE  
    )  
  
    text_input = ['one\n', 'two\n', 'three\n', 'four\n', 'quit\n']  
  
    await asyncio.gather(consume_and_send(text_input, process.stdout, process.stdin), process.wait())  
  
asyncio.run(main())
```

consume_and_send читает ввод, пока не получит ожидаемое сообщение. Эти действия повторяются, пока все данные не будут переданы подпроцессу.

Сделаем программу echo чуть более сложной. Она будет копировать данные случайное число раз. 
```python
from random import randrange  
import time  
  
user_input = ''  
  
while user_input != 'quit':  
    user_input = input('Введите текст: ')  
    for i in range(randrange(10)):  
        time.sleep(.5)  
        print(user_input)
```

Если запустить с предыдущей версией, то будет виден недостаток. Заключается он в том, что код чтения и ввода сильно связан. Это сложнее для понимания и отладки.

Проблему можно решить, отделив stdout от stdin.


```python3
import asyncio  
from asyncio import StreamWriter, StreamReader, Event  
from asyncio.subprocess import Process  
  
  
async def output_consumer(input_ready_event: Event, stdout: StreamReader):  
    while (data := await stdout.read(1024)) != b'':  
        print(data)  
        if data.decode().endswith('Введите текст: '):  
            input_ready_event.set()  
  
  
async def input_writer(text_data, input_ready_event: Event, stdin: StreamWriter):  
    for text in text_data:  
        await input_ready_event.wait()  
        stdin.write(text.encode())  
        await stdin.drain()  
        input_ready_event.clear()  
  
  
async def main():  
    program = ['python3', 'listing_13_13.py']  
    process: Process = await asyncio.create_subprocess_exec(  
        *program,  
        stdout=asyncio.subprocess.PIPE,  
        stdin=asyncio.subprocess.PIPE  
    )  
  
    input_ready_event = asyncio.Event()  
  
    text_input = ['one\n', 'two\n', 'three\n', 'four\n', 'quit\n']  
  
    await asyncio.gather(  
        output_consumer(input_ready_event, process.stdout),  
        input_writer(  
            text_input, input_ready_event, process.stdin  
        ),  
        process.wait()  
    )  
  
asyncio.run(main())
```