Вопросы:
* Основы микросервисов
* Паттерн backend-for-frontend
* Использование asyncio для взаимодействия с микросервисами
* Использование asyncio для обработки ошибок и повторных попыток

Многие веб-приложения проектируются как монолиты. В этом контексте имеются ввиду средне или крупно-масштабные приложения, содержащие несколько модулей. 

В самих монолитах ничего плохого нет, в определённых случаях они вполне приемлимы. Однако у них есть недостатки.

Один из главных недостатков монолитов - высокая связность и сложности в развёртывании. Многие проблемы монолита - решают микросервисы.

## Зачем нужны микросервисы?

Стандартного определения микросервисов не существует. Однако есть важные характеристики которые определяют микросервисы:
* У них есть свой независимый технологический стек, включающий модель данных
* Они взаимодействуют  друг с другом по какому-то протоколу
* Они слабо связаны и развёртываются независимо
* Он следуют принципу "одной обязанности", т.е. "микросервис должен делать что-то одно, но делать это хорошо".

Если бы нам требовалось микросервисная реализация например интернет магазина, то было бы несколько сервисов для реализации различных аспектов. Например, API товаров (в одном сервисе) и API пользователей (в другом сервисе).


Преимущества микросервисов:
* Сложность кода
	При развитии системы - её сложность возрастает, растёт связность. В монолитной архитектуре - это может вызвать проблемы с разработкой нового, т.к. изменение одного элемента приведёт к клубку ошибок в других. Микросервисы такой проблемы решены

 * Масштабируемость
	 При масштабировании монолита - приходится добавлять экземпляры всего приложения. В микросервисной архитектуре - можно масштабировать конкретные сервисы с наибольшей нагрузкой
	
* Независимость от команды и тех. стека
	В монолите n команд может вносить изменения в проект одновременно. Это усложняет разработку и развёртывание. В микросервисах каждый сервис можно развивать и разворачивать независимо от других команд. Также не столь важно, какой ЯП использует каждая команда, он может разниться.

* Чем может помочь asyncio?
	Так как сервисы общаются по HTTP или gRPC, то мы можем выполнять общаться с несколькими севрисами одновременно, открывается возможность выполнять запросы конкурентно и добиваться эффективности, невозможной в синхронном приложении.


## Введение в паттерн backend-for-frontend

В микросервисной архитектуре UI данные обычно поступают из нескольких источников и объединяются в одном представлении.

Это ставит несколько проблем.
Первая - неудобство пользователя. Когда сервисы автономны, UI клиенты должны запрашивать данные из разных источников. В результате на получение данных может уйти достаточно много времени.

Также имеются проблемы с принципом хорошего проектирования ПО. Помимо веб-интерфейса может иметься и мобильное приложение. Если вызвать каждый сервис непосредственно и объединить ответы, то придётся повторить одну и ту же логику несколько раз.

Существует много паттернов решающих эту проблему, но в описанной ситуации может помочь **паттерн backend-for-frontend**
Его идея в том, что UI не взаимодействует с сервисами напрямую, а создаст новый сервис, который отправляет вызовы и агрегирует результаты.

![[Pasted image 20250731164354.png]]


## Реализация API списка товаров

В архитектуре с несколькими независимыми сервисами мы должны будем запрашивать данные у каждого и объединять их для получения единого ответа. Начнём с определения базовых сервисов и моделей данных.

### Описание базовых сервисов

* Сервис избранного - отвечает за отображение пользователя на идентификаторы товаров, которые он поместил в список избранного. 

* Сервис корзины - отвечает за отображение идентификатора пользователя на идентификаторы товаров, которые он положил в корзину. Модель данных такая же, как для сервиса избранного.

* Сервис наличие на складе - отвечает за отображение идентификатора товара на наличие этого товара на складе

* Сервис товаров - отвечает за информацию о товаре, например описание и SKU.


### Реализация базовых сервисов

Начнём с реализации приложения aiohttp для сервиса наличия на складе. Для него мы не будем создавать отдельную модель данных, а просто вернём случайное число от 0 до 100, имитирующее складской остаток. Кроме того добавим задержку, чтобы смоделировать нестабильную скорость работы и воспользуемся ей, чтобы продемонстрировать обработку тайм-аутов в сервисе списка товаров.

```python
import asyncio  
import random  
from aiohttp import web  
from aiohttp.web_response import Response  
from aiohttp.web_request import Request  
  
routes = web.RouteTableDef()  
  
  
@routes.get('/products/{id}/inventory')  
async def get_inventory(request: Request) -> Response:  
    delay: int = random.randint(0, 5)  
    await asyncio.sleep(delay)  
    inventory: int = random.randint(0, 100)  
  
    return web.json_response({'inventory': inventory})  
  
  
app = web.Application()  
app.add_routes(routes)  
web.run_app(app, port=8001)
```

Далее реализуем сервис корзины и избранного.

Вставим в таблицу несколько записей для таблиц.
```sql
CREATE TABLE user_cart(
	user_id INT NOT NULL,
	product_id INT NOT NULL
);

INSERT INTO user_cart VALUES (1, 1);
INSERT INTO user_cart VALUES (1, 2);
INSERT INTO user_cart VALUES (1, 3);
INSERT INTO user_cart VALUES (2, 1);
INSERT INTO user_cart VALUES (2, 2);
INSERT INTO user_cart VALUES (2, 5);


CREATE TABLE user_favorite
(
	user_id INT NOT NULL,
	product_id INT NOT NULL
);
INSERT INTO user_favorite VALUES (1, 1);
INSERT INTO user_favorite VALUES (1, 2);
INSERT INTO user_favorite VALUES (1, 3);
INSERT INTO user_favorite VALUES (3, 1);
INSERT INTO user_favorite VALUES (3, 2);
INSERT INTO user_favorite VALUES (3, 3);

```

Поскольку нам понадобится делать сразу несколько подключений к БД, напишем код для создания пула подключений, который будем использовать во всех сервисах.

```python
import asyncpg  
from aiohttp.web_app import Application  
from asyncpg.pool import Pool  
  
DB_KEY = 'products'  
  
async def create_database_pool(  
        app: Application,  
        host: str,  
        port: int,  
        user: str,  
        database: str,  
        password: str  
):  
    pool: Pool = await asyncpg.create_pool(  
        host=host,  
        port=port,  
        user=user,  
        password=password,  
        database=database,  
        min_size=6,  
        max_size=6  
    )  
  
    app[DB_KEY] = pool  
  
  
async def destroy_database_pool(app: Application):  
    pool: Pool = app[DB_KEY]  
    await pool.close()
```

Далее перейдем к созданию сервисов. В терминах REST избранное и корзина – подсущности пользователя. Это означает, что корнем каждой оконечной точки должен быть users, а дополнительным параметром – идентификатор пользователя.

```python
import functools  
from aiohttp import web  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
from listing_10_4 import DB_KEY, create_database_pool, destroy_database_pool  
  
routes = web.RouteTableDef()  
  
  
@routes.get('/users/{id}/favorites')  
async def favorites(request: Request) -> Response:  
    try:  
        str_id = request.match_info['id']  
        user_id = int(str_id)  
        db = request.app[DB_KEY]  
  
        favorite_query = 'SELECT product_id FROM user_favorite WHERE user_id = $1'  
        result = await db.fetch(favorite_query, user_id)  
  
        if result:  
            return web.json_response([dict(record) for record in result])  
        else:  
            raise web.HTTPNotFound()  
  
    except ValueError:  
        raise web.HTTPBadRequest()  
  
  
app = web.Application()  
app.on_startup.append(  
    functools.partial(  
        create_database_pool,  
          host='127.0.0.1',  
          port=5432,  
          user='postgres',  
          password='password',  
          database='favorites'  
        )  
)  
  
  
app.on_cleanup.append(destroy_database_pool)  
app.add_routes(routes)  
web.run_app(app, port=8002)
```

Далее напишем сервис корзины. Он очень похож на предыдущий. Отличается только БД.

```python
import functools  
from aiohttp import web  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
from chapter_10.listing_10_4 import DB_KEY, create_database_pool, destroy_database_pool  
  
  
routes = web.RouteTableDef()  
  
  
@routes.get('/users/{id}/cart')  
async def time(request: Request) -> Response:  
    try:  
        str_id = request.match_info['id']  
        user_id = int(str_id)  
        db = request.app[DB_KEY]  
        favorite_query = 'SELECT product_id from user_cart where user_id = $1'  
        result = await db.fetch(favorite_query, user_id)  
        if result is not None:  
            return web.json_response([dict(record) for record in result])  
        else:  
            raise web.HTTPNotFound()  
    except ValueError:  
        raise web.HTTPBadRequest()  
  
  
app = web.Application()  
app.on_startup.append(  
    functools.partial(  
        create_database_pool,  
        host='127.0.0.1',  
        port=5432,  
        user='postgres',  
        password='password',  
        database='cart'  
    )  
)  
  
app.on_cleanup.append(destroy_database_pool)  
app.add_routes(routes)  
web.run_app(app, port=8003)
```

Наконец напишем сервис товаров. Последний из 4 сервисов для гипотетического интернет магазина.

```python
import functools  
from aiohttp import web  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
from chapter_10.listing_10_4 import DB_KEY, create_database_pool, destroy_database_pool  
  
routes = web.RouteTableDef()  
  
  
@routes.get('/products')  
async def products(request: Request) -> Response:  
    db = request.app[DB_KEY]  
    product_query = 'SELECT product_id, product_name FROM product'  
    result = await db.fetch(product_query)  
    return web.json_response([dict(record) for record in result])  
  
  
app = web.Application()  
app.on_startup.append(functools.partial(create_database_pool,  
                                        host='127.0.0.1',  
                                        port=5432,  
                                        user='postgres',  
                                        password='password',  
                                        database='products'))  
app.on_cleanup.append(destroy_database_pool)  
app.add_routes(routes)  
web.run_app(app, port=8000)
```


### Реализация сервиса backend-for-frontend

Построим сервис backend-for-frontend. Время загрузки товаров для нашего приложения критично, поскольку чем больше юзер ждёт, тем меньше шансов что он что-то купит.

Требования:
* api не должен ждать ответа от сервиса товаров дольше 1с. Если за это время ответ не пришёл, то мы должны вернуть ошибку тайм-аута (http код 504), чтобы UI не зависал

* Данные о тележке и избранном факультативны. Если удастся получить за 1с, прекрасно! А если нет, ограничимся только сведениями о товаре

* Данные о наличии складе тоже факультативны. Если не сумеем их получить, покажем только сведения о товаре.

Следует понять, какое максимальное число запросов мы будем отправлять конкурентно. Чем больше их будет, тем быстрее мы сможем вернуть ответ своим клиентам – теоретически. В нашем случае нельзя запрашивать наличие до получения идентификаторов товаров, поэтому конкурентно выполнять эти запросы нельзя, но сервисы товаров, корзины и избранного не зависят друг от друга. Это означает, что к ним можно обращаться конкурентно и ждать ответа с по­мощью функции asyncio wait. Вызов wait с тайм-аутом даст нам множество done, на основании которого мы сможем узнать, какие запросы завершились с ошибкой, а какие еще работают после таймаута. Это позволит обработать ошибки любого вида. Затем, получив идентификаторы товаров и, возможно, данные о корзине и избранном, мы сможем объединить все в окончательный ответ и отправить его клиенту.

```python
import asyncio  
from asyncio import Task  
import aiohttp  
from aiohttp import web, ClientSession  
from aiohttp.web_request import Request  
from aiohttp.web_response import Response  
import logging  
from typing import Dict, Set, Awaitable, Optional, List  
  
routes = web.RouteTableDef()  
  
PRODUCT_BASE = 'http://127.0.0.1:8000'  
INVENTORY_BASE = 'http://127.0.0.1:8001'  
FAVORITE_BASE = 'http://127.0.0.1:8002'  
CART_BASE = 'http://127.0.0.1:8003'  
  
  
@routes.get('/products/all')  
async def all_products(request: Request) -> Response:  
    async with aiohttp.ClientSession() as session:  
        products = asyncio.create_task((session.get(f'{PRODUCT_BASE}/products')))  
        favorites = asyncio.create_task(session.get(f'{FAVORITE_BASE}/users/3/favoritres'))  
        cart = asyncio.create_task(session.get(f'{CART_BASE}/users/3/cart'))  
  
        requests = [products, cart, favorites]  
        # Создать задачи для опроса всех трёх сервисов и запустить их конкурентно  
        done, pending = await asyncio.wait(requests, timeout=1.0)  
  
        # Если запрос к сервису товаров завершился  
        # по тайм-ауту, вернуть ошибку, потому что        # продолжение невозможно        if products in pending:  
            [request.cancel() for request in requests]  
            return web.json_response(  
                {'error': 'Не удалось подключиться к сервису товаров'},  
                status=504  
            )  
        elif products in done and products.exception():  
            [request.cancel() for request in requests]  
            logging.exception(  
                'Ошибка сервера при подключении к сервису товаров.',  
                exc_info=products.exception()  
            )  
  
            return web.json_response(  
                {'error': 'Ошибка сервера при подключении к сервису товаров'},  
                status=500  
            )  
        # Извлечь данные из ответа на запрос о товарах  
        # и использовать их для получения информации        # о наличии        else:  
            product_response = await products.result().json()  
            product_results: List[Dict] = await get_products_with_inventory(  
                session, product_response  
            )  
  
            cart_item_count: Optional[int] = await get_response_item_count(  
                cart,  
                done,  
                pending,  
                'Error getting user cart.'  
            )  
            favorite_item_count: Optional[int] = await get_response_item_count(  
                favorites,  
                done,  
                pending,  
                'Error getting user favorites.'  
            )  
  
            return web.json_response({  
                'cart_items': cart_item_count,  
                'favorite_items': favorite_item_count,  
                'products': product_results  
  
            })  
  
  
# Получив данные о товарах,  
# отправить запросы о наличии  
async def get_products_with_inventory(  
        session: ClientSession,  
        product_response  
) -> List[Dict]:  
    def get_inventory(session: ClientSession, product_id: str) -> Task:  
        url = f"{INVENTORY_BASE}/products/{product_id}/inventory"  
        return asyncio.create_task(session.get(url))  
  
    def create_product_record(product_id: int, inventory: Optional[int]) -> Dict:  
        return {'product_id': product_id, 'inventory': inventory}  
  
    inventory_tasks_to_product_id = {  
        get_inventory(session, product['product_id']): product['product_id']  
        for product in product_response  
    }  
  
    inventory_done, inventory_pending = await asyncio.wait(inventory_tasks_to_product_id.keys(), timeout=1.0)  
    product_results = []  
  
    for done_task in inventory_done:  
        if done_task.exception() is None:  
            product_id = inventory_tasks_to_product_id[done_task]  
            inventory = await done_task.result().json()  
            product_results.append(  
                create_product_record(  
                    product_id,  
                   inventory['inventory'])  
            )  
        else:  
            product_id = inventory_tasks_to_product_id[done_task]  
            product_results.append(create_product_record(product_id, None))  
            logging.exception(  
            f'Не удалось получить сведения о наличии товара {product_id}',  
                exc_info=inventory_tasks_to_product_id[done_task].exception()  
            )  
    for pending_task in inventory_pending:  
        pending_task.cancel()  
        product_id = inventory_tasks_to_product_id[pending_task]  
        product_results.append(create_product_record(product_id, None))  
  
    return product_results  
  
  
async def get_response_item_count(task: Task, done: Set[Awaitable], pending: Set[Awaitable], error_msg:str) -> Optional[int]:  
    if task in done and task.exception() is None:  
        return len(await task.result().json())  
    elif task in pending:  
        task.cancel()  
    else:  
        logging.exception(error_msg, exc_info=task.exception())  
        return  
  
  
app = web.Application()  
app.add_routes(routes)  
web.run_app(app, port=9000)
```

Эта реализация дает достаточно надежный способ обработки ошибок и тайм-аутов некритичных сервисов и гарантирует, что разумный ответ будет быстро получен даже в случае ошибок нижележащих сервисов. 


### Повтор неудачных запросов

В первой реализации мы предполагали, что если от сервиса получено исключение, то всё пропало. Иногда так и есть, но бывает, что ошибка имеет временный характер.

В таких случаях имеет смысл несколько раз повторить попытку с небольшой задержкой. Возможно ошибка исчезнет сама.

Для реализации такой идеи отлично подходит `asyncio.wait_for`. Она возбуждает полученное исключение и позволяет задать тайм-аут. Если таймаут истечёт, то будет возбуждено исключение и запущенная задача будет снята.

```python
import asyncio  
import logging  
from typing import Callable, Awaitable  
  
  
class TooManyRetries(Exception):  
    pass  
  
  
async def retry(  
        coro: Callable[[], Awaitable],  
        max_retries: int,  
        timeout: float,  
        retry_interval: float  
):  
    for retry_num in range(0, max_retries):  
        try:  
            return await asyncio.wait_for(coro(), timeout=timeout)  
        except Exception as e:  
            logging.exception(  
                f'Во время ожидания произошло исключение (попытка {retry_num}), пробую ещё раз', exc_info=e  
            )  
            await asyncio.sleep(retry_interval)  
  
    raise TooManyRetries()
```


Для тестирования напишем две сопрограммы, они будут завершаться с ошибками.  Первая - всегда возбуждает исключение, вторая не будет заканчиваться в отведённое время.

```python
import asyncio  
from chapter_10.listing_10_9 import retry, TooManyRetries  
  
  
async def main():  
    async def always_fail():  
        raise Exception('Я грохнулась')  
  
    async def always_timeout():  
        await asyncio.sleep(1)  
  
    try:  
        await retry(  
            always_fail,  
            max_retries=3,  
            timeout=.1,  
            retry_interval=.1  
        )  
    except TooManyRetries:  
        print('Слишком много попыток')  
  
  
    try:  
        await retry(  
            always_timeout,  
            max_retries=3,  
            timeout=.1,  
            retry_interval=.1  
        )  
    except TooManyRetries:  
        print('Слишком много попыток')  
  
asyncio.run(main())
```



### Паттерн Прерыватель

В нашей реализации имеется проблема, когда один из сервисов упал или работает медленно. Это может вызвать затык сервиса. В данном случае, поскольку проблема может сохраняться в течении длительного времени, всякий, кто обратился к сервису будет ждать 1 секунду даже в том случае, когда сервис не работает. Хотелось бы обойти эту проблему. Для этого можно воспользоваться паттерном Прерыватель (circuit breaker).

Паттерн позволяет "перещёлкнуть" прерыватель, если в течении какого-то времени произошло n количество ошибок, то мы просто не будем к нему обращаться до тех пор, пока проблема не решится.

У паттерна Прерыватель есть два состояния:
* Разомкнут
* Замкнут

В замкнутом состоянии всё хорошо: отправляем запросы как обычно.
В размокнутом: не идём в сервис и сразу возвращаем ошибку.

Есть ещё и третье состояние - полуразомкнутое. В нём мы отправляем одиночный запрос, чтобы проверить, всё ли окей. Если да - замыкаемся, если нет - остаёмся в разомкнутом состоянии.

![[Pasted image 20250801162931.png]]

Пример простого прерывателя

```python
import asyncio  
from datetime import datetime, timedelta  
  
  
class CircuitOpenException(Exception):  
    pass  
  
  
class CircuitBreaker:  
    def __init__(  
            self,  
            callback,  
            timeout: float,  
            time_window: float,  
            max_failures: int,  
            reset_interval: float  
    ):  
        self.callback = callback  
        self.timeout = timeout  
        self.time_window = time_window  
        self.max_failures = max_failures  
        self.reset_interval = reset_interval  
        self.last_request_time = None  
        self.last_failure_time = None  
        self.current_failures = 0  
  
    async def request(self, *args, **kwargs):  
        if self.current_failures >= self.max_failures:  
            if datetime.now() > self.last_request_time + timedelta(seconds = self.reset_interval):  
                self._reset('Переходим из разомкнутого состояния в замкнутое, сброс!')  
                return await self._do_request(*args, **kwargs)  
            else:  
                print('Разомкнуто. Быстрый отказ.')  
                raise CircuitOpenException()  
        else:  
            if self.last_failure_time and datetime.now() > self.last_failure_time + timedelta(seconds=self.time_window):  
                self._reset('Интервал с момента первого сбоя истек, сброс!')  
            print('Замкнут! Отправляю запрос')  
            return await self._do_request(*args, **kwargs)  
  
    # Сбросить счётчик и время последнего отказа  
    def _reset(self, msg: str):  
        print(msg)  
        self.last_failure_time = None  
        self.current_failures = 0  
  
    async def _do_request(self, *args, **kwargs):  
        try:  
            print('Отправляю запрос')  
            self.last_request_time = datetime.now()  
  
            return await asyncio.wait_for(  
                self.callback(*args, **kwargs),  
                timeout = self.timeout  
            )  
        except Exception:  
            self.current_failures += 1  
            if self.last_request_time is None:  
                self.last_failure_time = datetime.now()  
  
            raise
```

Применение прерывателя в простом примере
```python
import asyncio  
from chapter_10.listing_10_11 import CircuitBreaker  
  
  
async def main():  
    async def slow_callback():  
        await asyncio.sleep(2)  
  
    cb = CircuitBreaker(  
        slow_callback,  
        timeout=1,  
        time_window=5,  
        max_failures=2,  
        reset_interval=5  
    )  
  
    for _ in range(4):  
        try:  
            await cb.request()  
        except Exception as e:  
            pass  
  
    print('Засыпаю на 5 с, чтобы прерыватель запустился...')  
    await asyncio.sleep(5)  
  
    for _ in range(4):  
        try:  
            await cb.request()  
        except Exception as e:  
            pass  
  
  
asyncio.run(main())
```

```
Цепь замкнута, отправляю запрос!
Цепь замкнута, отправляю запрос!
Цепь разомкнута, быстрый отказ!
Цепь разомкнута, быстрый отказ!
Засыпаю на 5 с, чтобы прерыватель замкнулся...
Цепь переходит из разлокнутого в замкнутое состояние, сброс!
Цепь замкнута, отправляю запрос!
Цепь разомкнута, быстрый отказ!
Цепь разомкнута, быстрый отказ!
```