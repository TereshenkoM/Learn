
## Что такое JWT аутентификация?
**JWT -** JSON Web Token, метод аутентификации, при котором в JSON добавляется цифровая подпись, а сам JSON содержит информацию (утверждение) о пользователе.

## JWT Обычно состоит из:
* Заголовка (содержит метаданные о токене, например алгоритм подписи);
* Полезной нагрузки (содержит утверждение, которые могут включать пользовательскую информацию и другие пользовательские данные);
* Подписи (генерируется с использованием специального секретного ключа, который известен только серверу).

## Алгоритм работы JWT
* Пользователь вводит учётные данные и отправляет их на сервер. Сервер проверяет их и генерирует JWT.

* Сервер отправляет JWT обратно клиенту (обычно в заголовке Authorization ответа) в качестве токена

* При последующих запросах пользователь отправляет JWT токен в заголовке Authorization. Затем сервер проверяет подпись при помощи секретного ключа. Если подпись действительна, то сервер разрешает ему доступ к запрошенным ресурсам (для которых понятно дело необходима авторизация)

## Плюсы JWT
* **Без сохранения состояния**: серверу не нужно хранить информацию о сеансе, что делает его более масштабируемым для распределенных систем.  

* **Междоменность (кросс-доменность):** Поскольку JWT обычно отправляются в заголовке "Авторизация" (Authorization), они хорошо работают с CORS (совместное использование ресурсов разных источников - Cross-Origin Resource Sharing) и могут использоваться в разных доменах.  

* **Пользовательские утверждения:** Вы можете добавлять пользовательские утверждения в полезную нагрузку, обеспечивая гибкое хранение пользовательской информации.


## Немного о безопасности
Хотя аутентификация на основе JWT дает множество преимуществ, она также сопряжена с соображениями безопасности:  

- **Срок действия токена**: установите подходящее время истечения срока действия токена, чтобы в случае его кражи (перехвата) злоумышленником время для причинения ущерба было ограничено.  

- **Используйте HTTPS**: Всегда используйте HTTPS для шифрования связи между клиентом и сервером.  

- **Защита секретного ключа**: Сохраняйте секретный ключ, используемый для подписи JWT, в безопасности. Компрометация ключа может привести к нарушениям безопасности.  

- **Размер токена**: Помните о размере токена, поскольку он отправляется с каждым запросом. Избегайте включения конфиденциальных или ненужных данных в полезную нагрузку.

На следующем уроке мы рассмотрим управление доступом на основе ролей, которое позволяет детально управлять разрешениями в вашем приложении FastAPI.
## Пример более продвинутой защиты

Иногда нужно быстро сделать аутентификацию, используя имя **пользователя** и **пароль** _(например, при разработке внутри компании)._ Для этого можно использовать возможности **FastAPI** по работе с **OAuth2**:

**Примечание: устанавливаемая библиотека PyJWT**https://pyjwt.readthedocs.io/en/latest/installation.html

```python
#models.py
from pydantic import BaseModel


class User(BaseModel):
	username: str
	password: str

# в реальной БД мы храним только ХЭШИ паролей
USERS_DATA = [
	{'username': 'user1', 'password': 'pass1'}
]
```

```python
#main.py
from fastapi import FastAPI, Depends
from fastapi.security import OAuth2PasswordBearer
from models import User, USERS_DATA
import jwt


app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# Секретный ключ для подписи и верификации токенов JWT 
SECRET_KEY = "mysecretkey" # тут мы в реальной практике используем что-нибудь вроде команды Bash (Linux) 'openssl rand -hex 32', и храним очень защищенно
ALGORITHM = "HS256" # плюс в реальной жизни мы устанавливаем "время жизни" токена

def create_jwt_token(data: dict):
	return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM) # Кодируем словарь    с пользовательскими данными, которые хотим разместить


# Функция получения юзера по токену
def get_user_from_token(token: str = Depends(oauth2_sheme)):
	try:
		# Декодируем токен
		payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
		return payload.get('sub') # Берём полезную и возвращаем утверждение о          пользователе sub (subject).
	except jwt.ExpiredSignatureError:
		pass # тут какая-то логика ошибки истечения срока действия токена
	except jwt.InvalidTokenError:
		pass # тут какая-то логика обработки ошибки декодирования токена


# Функция для получения пользовательских данных на основе имени пользователя 
def get_user(username: str):
	for user in USERS_DATA:
		if user.get("username") == username: 
			return user 
	return None


# Так делать не стоит, это для примера. Хорошй вариант в ссылке под этим куском кода
@app.post('/login/')
async def login(user_in: User):
	for user in USERS_DATA:
		if user.get('username') == user_in.username and user.get('password') ==       user_in.password:
			return {
				'token': create_jwt_token({'sub': user_in.username}),
				'token_type': 'bearer'
			}
	return {'error': 'bad'}


# защищенный роут для получения информации о пользователе
@app.get("/about_me")
async def about_me(current_user: str = Depends(get_user_from_token)):
	user = get_user(current_user)
	if user: 
		return user 
	return {"error": "User not found"}
			
```

Хороший вариант авторизации - [[4.3 Управления доступом на основе ролей (RBAC)]]