
## Понимание внедрения зависимостей в FastAPI

Внедрение зависимостей - это шаблон проектирования, используемый в FastAPI для управления и предоставления зависимостей компонентам вашего приложения. С помощью внедрения зависимостей вы можете разделить различные части вашего приложения, сделав его более **модульным и простым** в обслуживании. Встроенная система внедрения зависимостей FastAPI позволяет вам внедрять зависимости в функции маршрутизации и обработчики запросов.

Это очень удобно, когда вам нужно:

- Иметь общую логику (одна и та же логика кода снова и снова).
- Совместное использование подключений к базе данных.
- Обеспечение безопасности, аутентификации, требований к ролям и т. д.

В FastAPI класс `` `Depends` `` используется для объявления и использования зависимостей. Используя `` `Depends` ``, вы можете указать требования к зависимостям для маршрута или обработчика запросов. FastAPI автоматически разрешает и предоставляет необходимые зависимости во время обработки запроса.

## Зависимости маршрутов и области их применения

FastAPI позволяет вам определять зависимости для конкретного маршрута с помощью класса `` `Depends` ``. Вы можете указать различные области зависимостей, чтобы управлять сроком службы экземпляров зависимостей.

Теоретический пример для демонстрации возможности. Предположим, у нас есть приложение FastAPI, которое использует поддельную базу данных для хранения и извлечения пользовательской информации. Мы будем использовать внедрение зависимостей, чтобы внедрить зависимость базы данных в функции маршрута. 

```python
from fastapi import FastAPI, Depends

app = FastAPI()

# фейковая БД для хранения пользовательских данных
fake_database = {
    1: {"id": 1, "name": "John Doe"},
    2: {"id": 2, "name": "Jane Smith"},
}

# Функция зависимости для получения экземпляра базы
def get_database():
    return fake_database

# Функция маршрутизации с внедрением зависимостей (dependency injection) 
@app.get("/users/{user_id}")
def get_user(user_id: int, database: dict = Depends(get_database)):
    if user_id in database:
        return database[user_id]
    else:
        return {"message": "User not found"}

# Другая функция маршрутизации с тем же внедрением зависимостей
@app.get("/users/")
def get_all_users(database: dict = Depends(get_database)):
    return list(database.values())
```

В этом примере мы определяем поддельную базу данных `` `fake_database` `` для хранения пользовательской информации. Мы также создаем функцию зависимости `` `get_database` ``, которая возвращает экземпляр базы данных (`` `fake_database` ``).

В обеих функциях маршрутизации `` `get_user` `` и `` `get_all_users` `` мы используем `` `Depends(get_database)` ``, чтобы внедрить `` `fake_database` `` в функции в качестве зависимости. Функция `` `Depends` `` сообщает FastAPI вызвать `` `get_database()` `` и передать возвращаемое значение в качестве аргумента функции каждого роута.

Когда мы отправляем запрос GET в `` `/users/{user_id}` `` или `` `/users/` ``, FastAPI автоматически вводит (добавляет) `` `fake_database` `` в соответствующие функции маршрута, позволяя нам получить доступ к пользовательской информации из базы данных в наших обработчиках. И в дополнение - мы соблюли принцип DRY - don't repeat yourself, переиспользовав свою зависимость, что сделало код более читаемым и удобным.

## Middleware

Мидлвэр в FastAPI - это такая прослойка для каждого запроса (ответа). Другими словами это функция, которая работает с каждым запросом до того, как он будет обработан какой-либо конкретной операцией path. А также с каждым ответом, прежде чем возвращать его.

Порядок работы Middleware'а такой:

1. Он принимает каждый запрос , который приходит к вашему приложению.
2. Затем он может что-то сделать с этим запросом или запустить любой необходимый код.
3. Затем он передает запрос на обработку остальной части приложения (некоторой `Path` операции).
4. Затем он принимает ответ, сгенерированный приложением (некоторой операцией пути).
5. Он может что-то сделать с этим ответом или запустить любой необходимый код.
6. Затем он возвращает ответ .

Примеров применения может быть множество. Вот некоторые из них: блэк лист для айпи-адресов, вайт-лист, введение "паузы" для загрузки, проверка "доверенных" заголовков, редирект (например на https/wss) и др.

Например, можно сделать мидлвэр, который делает вид, что сервер долго грузится при частых обращениях с одного и того же айпишника. Пожалуй главная цель такого ПО - снижение нагрузки на сервер. Либо на этом "промежуточном" слое можно делать что-то, что является общим для всех запросов (например, проверка или добавление заголовков), чтобы не прописывать такую логику в каждой функции. 

Middleware создаётся в FastAPI довольно просто - с использованием декоратора `` `@app.middleware("http")` ``.

Вот пример Мидлвэра, который вы можете запустить у себя и увидеть логику его работы:

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    print('Мидлвэр начал работу')
    response = await call_next(request)
    print('Мидлвэр получил обратно управление')
    return response

@app.get("/")
def index():
    print('привет из основного обработчика пути')
    return {"message": "Hello, world!"}
```

Давайте для примера разберём пример из официальной документации:

```python
import time

from fastapi import FastAPI, Request

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

Мы создали Мидлвэр с помощью декоратора. 

Потом определили логику его работы (в качестве аргументов указали функцию, которая принимает сам объект запроса `Request` и функцию `call_next`).

Call_next - это функция, которая передает управление дальше соответствующему обработчику пути (обработчик в примере не указан, но предполагается, что есть какой-то).

Потом засекли текущее время. Сказали, что ответом будет то, что вернёт функция call_next (соответствующий обработчик пути). И сказали, что время обработки - это разница между временем текущим и тем, когда мы передали управление в другой обработчик.

И потом мы добавляем к каждому ответу **кастомный заголовок** - время обработки запроса.

##  Усовершенствованные методы маршрутизации

FastAPI предоставляет различные расширенные методы маршрутизации для настройки поведения конечной точки и обработки сложных шаблонов запросов.

- Настройка путей маршрута: Вы можете **настроить пути маршрута**, используя переменные, регулярные выражения и параметры запроса, для создания динамических и гибких конечных точек.
- Обработка HTTP-методов: FastAPI позволяет вам определять **несколько HTTP-методов** (GET, POST, PUT, DELETE и т.д.) **для одного маршрута**, что позволяет создавать более универсальные API.
- Включение и исключение маршрутов: Вы можете выборочно **включать или не включать маршруты** в приложение, используя include. Это позволяет лучше контролировать открытые конечные точки API.



## Вспомогательные приложения и маршрутизаторы API

FastAPI поддерживает вспомогательные вложенные приложения (суб-приложения) и маршрутизаторы API, которые позволяют вам организовывать свой код в более мелкие, повторно используемые компоненты. Вспомогательные приложения или маршрутизаторы могут быть подключены к основному приложению, что позволяет лучше организовать код и разделить задачи.

Давайте посмотрим на примерах о чем речь. 

### Суб-приложения

Например у вас была первая версия вашего API, но потом вы его сильно поменяли. Но хотите сохранить поддержку предыдущего. В FastAPI это сделать очень просто.

Допустим у вас есть файл `api_v1.py` (или другое суб-приложение):

```
from fastapi import FastAPI

# создаём суб-приложение
api_v1_app = FastAPI()

# определяем роут в суб-приложении
@api_v1_app.get("/sub/")
def read_sub():
    return {"message": "This is a sub-application route."}
```

Потом посмотрим на основной файл вашего FastAPI, допустим `main.py`:

```python
from fastapi import FastAPI
from api_v1 import api_v1_app

# создаём главное FastAPI приложение
app = FastAPI()

# монтируем суб-приложение в основное приложение 
app.mount("/v1", api_v1_app)

# создаём обычный роут в главном приложении
@app.get("/")
def root():
    return {"message": "Hello from main app"}
```

Каждое подобное субприложение FastAPI будет иметь свою документацию, работать независимо от других приложений и будет обрабатывать свои запросы, зависящие от пути. В данном случае у нас будет доступен основной роут [http://localhost:8000/](http://localhost:8000/subapp/sub/) и роут суб-приложения [http://localhost:8000/v1/sub/](http://localhost:8000/subapp/sub/). Как видим, для доступа к роутам суб-приложений используется префикс (у нас /v1/).

### Маршрутизаторы API

Когда маршрутов становится слишком много, то ими становится неудобно управлять. Маршруты могут дублироваться или перекрывать друг друга.

FastAPI имеет собственную систему API-маршрутизации. API-роуты (APIRouters) можно рассматривать как мини-приложения FastAPI, которые являются зависимой **частью** более крупного приложения (без основного приложения они не могут существовать).

Давайте посмотрим как FastAPI может помочь.

Например есть 3 файла:

Файл 1 - `electronics.py`:

```python
from fastapi import APIRouter

electronicsroute = APIRouter()

@electronicsroute.get('/info')
def electronics():
    return {"detail": "This electronics info is from the electronics APIRouter",
            "name": "Electronics XYZ",
            "brand": "ABC Electronics"}
```

Файл 2 - `gadgets.py`:

```python
from fastapi import APIRouter

gadgetsroute = APIRouter()

@gadgetsroute.get('/info')
def gadgets():
    return {"detail": "This gadgets info is from the gadgets APIRouter",
            "name": "Cool Gadget",
            "manufacturer": "Gadget Co."}
```

Как видите, в обоих файлах есть маршрут `/info`.

Чтобы их было возможно обрабатывать, давайте соединим их в третьем `main.py` файле:

```python
from fastapi import FastAPI
from electronics import electronicsroute
from gadgets import gadgetsroute


app = FastAPI()
app.include_router(electronicsroute, prefix="/electronics")
app.include_router(gadgetsroute, prefix="/gadgets")

@app.get('/')
def index():
    return "Welcome to the Electronics Store"
```

Вы могли заметить, что мы создавали не инстанс приложения FastAPI, как в случае с суб-приложениями, а использовали класс `APIRouter`.

В файле `main.py` мы включили оба роутера и установили префикс для каждого.

Теперь есть возможность обратиться как к основным роутам главного приложения ([http://localhost:8000/](http://localhost:8000/)), так и к каждому из роутов `/info`, используя соответствующий префикс: [http://localhost:8000/electronics/info](http://localhost:8000/electronics/info) и [http://localhost:8000/gadgets/info](http://localhost:8000/gadgets/info).

Таким образом, может быть несколько API-роутов для обработки параметров, в зависимости от того, какой тип операции нужно выполнить **для разных групп** эндпоинтов.

## Вложенные объекты для тела запроса

FastAPI предоставляет более широкие возможности при проверке данных запроса при помощи Pydantic моделей.

Рассмотрим пример:

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

Тут мы сначала объявили модель `` `Image` ``, и далее в объекте `` `Item` `` её вложили. После этого передали эту модель в соответствующую функцию, обрабатывающую PUT-запрос. Соответственно FastAPI будет ожидать такой входящий JSON:

```json
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
```

Таким образом FastAPI позволяет настраивать валидируемые схемы данных любым удобным для нас способом, что повышает общую гибкость приложения.