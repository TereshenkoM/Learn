
* **Pydantic** предоставляет различные классы для валидации различных типов полей (например: **EmailStr** - для валидации почты, **PositiveInt** - для валидации положительных чисел)

	Пример:
```python
	from pydantic import BaseModel, EmailStr, PositiveInt
	
	
	class UserCreate(BaseModel):
		name: str
		email: EmailStr
	
		age: PositiveIn
		is_subscribed: bool = False
	```

<hr>


* Обычно в pydantic имена атрибутов класса должны совпадать с тем, что передаётся к нему на вход. Однако для поля можно задать псевдоним.
  **Пример:** (рабочий)

  ```python
	# models/base_model.py
    from pydantic import BaseModel, PositiveFloat, PositiveInt


	class Product(BaseModel):
		id: PositiveInt = Field(alias='product_id')
		name: str
		category: str
		price: PositiveFloat


```

  ```python
	# models/base_model.py
	from fastapi import FastAPI
	
	from models.base_models import Product
	
	  
	  
	
	app = FastAPI()
	
	sample_product_1 = {
	
		"product_id": 123,
		
		"name": "Smartphone",
		
		"category": "Electronics",
		
		"price": 599.99
	
	}
	
	
	  
	
	sample_products = [sample_product_1]
	
	  
	  
	
	@app.get('/product/{product_id}')
	async def get_product(product_id: int) -> Product | str:
		for product in sample_products:
			if product['product_id'] == product_id:
				return product
		return 'Product Does Not Exist'

```

	Поля отличаются, однако данный код будет работать, так как мы указали псевдоним (alias) для поля **id** в классе **Product** 

<hr>
