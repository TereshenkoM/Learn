**Примечание:** Для тестирования каждого эндпоинта можно перейти на localhos/docs и тестировать всё напрямую там. (Swagger UI)
Там же находится очень удобная документация к каждому из эндпоинтов.

<hr>
## 'Hello World!' на FastAPI

```python
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get('/')
async deff root():
	return {"message": "Hello World!"}
```

Для запуска:
```shell
uvicorn main:app --reload
```
**Где:**
* uvicorn - ASGI сервер;
* main - название файла (main.py);
* app - объект FastAPI, созданный внутри файла;
* --reload - флаг, позволяющий перезапускающий сервер после внесённых на нём изменений.

**Примечание:**

	 Работает на localhost:8000 (по дефолту)

<hr>
<hr>

## Пример с возвращаемым HTML фалом

```html
<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Document</title>

</head>

<body>
	ШЛЩПФЫВ
</body>

</html>
```

```python
from fastapi import FastAPI
from fastapi.responses import FileResponse

  
app = FastAPI()

@app.get('/')
async def root():
	return FileResponse('index.html')
```

<hr>

## Использование path-параметров и query-параметров

###  query-параметры (параметры запроса)
**Пример:** Создадим эндпоинт, который будет принимать POST-запрос с двумя параметрами запроса (num1 и num2), который будет возвращать их сумму 

```python
from fastapi import FastAPI

app = FastApi()

@app.post('/calculate')
async def calculate(num1:int, num2:int) -> int:
	return num1 + num2
```

**Примечание:**
	В декораторе после объекта FastAPI (в данном случае app) указывается HTTP- метод для данного эндпоинта
	

### path-параметры (параметры пути)

**Пример:** Создадим эндпоинт, в котором необходимо указать id предмета (скажем товара).

```python
from fastapi import FastAPI

app = FastAPI()

@app.get('/shop/{item_id}')
async def shop(item_id: int):
	return {'item_id': item_id}
```

<hr>




### path + query
```python
@app.get("/users/{user_id}") 
def read_user(user_id: int, is_admin: bool = False): 
	return {
			"user_id": user_id, 
			"is_admin": is_admin
		}
```
## Структура проекта
Типичный проект FastAPI организован структурированным образом, чтобы сохранить кодовую базу чистой и управляемой. Вот **рекомендуемая** структура проекта:

```
project_name/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── models/
│   │   └── __init__.py
│   └── routes/
│       └── __init__.py
└── requirements.txt
```
- Каталог "app" (приложение) содержит основной модуль приложения и вложенные пакеты для моделей и маршрутов.  
- Тот самый `` `main.py` `` файл будет служить точкой входа в наше приложение FastAPI.  
- Каталог "models" используется для определения моделей Pydantic для обработки проверки данных запросов и ответов.  
- Каталог "routes" (маршруты) будет содержать маршруты API (конечные точки), которые определяют поведение приложения.
## Pydantic-модели для аннотации типов
Pydantic - Python библиотека для выполнения валидации данных. 
По сути представляет из себя класс с прописанными атрибутами, для каждого из которых указывается тип данных. Затем вы создаете экземпляр этого класса с некоторыми значениями, и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

**Примечание:**
В структуре проекта (описанной выше) все классы Pydantic хранятся в файле models.py

**Пример:**
```python
from datetime import datetime
from typing import List, Union

from pydantic import BaseModel

# Модель данных
class User(BaseModel):
	id: int
	name: str = 'John Doe' # После равно указывается значение по умолчанию
	signup_ts: Union[datetime, None] = None
	friends: List[int] = []

# Имитируем входящий JSON
external_data = { 
	"id": "123",
	"signup_ts": "2017-06-01 12:22",
	"friends": [1, "2", b"3"], } 
# имитируем распаковку входящих данных в коде приложения 
user = User(**external_data) print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3] 
print(user.id) # > 123
```

**Примечание:**
С **FastAPI** вы объявляете параметры с аннотациями типов и получаете:

- **Поддержку редактора**.
- **Проверки типов**.

...и FastAPI использует тот же механизм для:

1. Определения требований: из параметров пути запроса, параметров запроса, заголовков, зависимостей и т.д.
2. Преобразования данных: от запроса к нужному типу.
3. Валидации данных: исходя из каждого запроса:
4. Генерации автоматических ошибок, возвращаемых клиенту, когда данные не являются корректными.
5. Документирования API с использованием OpenAPI: который затем используется пользовательскими интерфейсами автоматической интерактивной документации.

Более реальный пример:

```python
# models/base_models.py
from pydantic import BaseModel


class User(BaseModel):
	username: str
	message: str
```

```python
# main.py
from fastapi import FastAPI
from models.base_models import User


@app.post('/')
async def root(user: User) -> str:
	return user.username
```

Пример валидного (корректного) POST-запроса в формате JSON:
```json
{
  "username": "Vasya",
  "message": "I am BATMAN"
}
```

Принцип раннего выхода.Примеры невалидного запроса, которые выдадут автоматическую ошибку от сервера о не корректности полученных данных:
```json
{
  1: 12345
}

{
    "username": "john_doe",
    "message": false
}

{
    "username": "vasilisa"
}
```

**А зачем вообще проверять входные данные?**

Когда мы ожидаем, что придут определённые данные в определённом формате, мы можем столкнуться с неверным поведением в дальнейшем. Простейший пример, в нашей БД есть поле, в котором хранится стоимость заказа. И если с фронтенда придёт не число, а например False, то логика всей программы поломается.