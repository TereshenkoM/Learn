
Интеграционное тестирование в FastAPI включает в себя тестирование взаимодействий **между различными частями** вашего приложения. В отличие от модульных тестов, которые фокусируются на отдельных блоках кода, интеграционные тесты гарантируют, что интегрированные компоненты работают вместе должным образом. Интеграционные тесты помогают выявить проблемы, которые могут возникнуть при взаимодействии нескольких компонентов, такие как проблемы с зависимостями, подключениями к базе данных или интеграцией API.

## Использование TestClient для интеграционных тестов

FastAPI предоставляет класс `` `TestClient` `` из модуля `` `fastapi.testclient` ``, который является ценным инструментом для запуска интеграционных тестов. `"TestClient"` позволяет вам выполнять реальные HTTP-запросы к вашему приложению FastAPI во время тестирования, имитируя реальные сценарии.

Что также немаловажно, `TestClient` позволяет тестировать приложение FastAPI без его запуска, имитируя реальные запросы (без запуска uvicorn'а).

Для асинхронных тестов можно использовать `AsyncClient` из модуля `httpx`.

## Подготовка тестовой среды
Перед запуском интеграционных тестов с помощью `` `TestClient` `` крайне важно настроить тестовую среду, которая очень похожа на производственную, _**но с контролируемыми данными**_. Это может включать в себя создание тестовой базы данных, заполнение ее тестовыми данными и настройку любых необходимых зависимостей.




## Тестирование конечных точек и маршрутов
Интеграционные тесты с **"TestClient"** позволяют вам тестировать **конечные точки API** вашего приложения и маршруты точно так же, как это сделал бы реальный пользователь или внешняя служба. Отправляя HTTP-запросы и получая ответы, вы можете убедиться, что ваш API ведет себя корректно в различных условиях.

Вот пример того, как вы можете выполнить интеграционное тестирование 
с помощью `` `TestClient` ``.

Предположим, у вас есть приложение FastAPI со следующим кодом:

```python
# main.py
from fastapi import FastAPI, HTTPException, Request, Response
from pydantic import BaseModel


app = FastAPI()

# псевдо-бд
fake_users_db = [
    {
        "user_id": 1,
        "username": "user123",
        "password": "secretpassword",
        "email": "user@example.com"
    }
]

# имитируем хранилище сессий
sessions = {}


# модельки
class UserCredentials(BaseModel):
    username: str
    password: str

class UserData(BaseModel):
    user_id: int
    username: str
    email: str


# роуты
@app.post("/login/") # проверяем наличие юзера и возвращаем куки
def login(user_creds: UserCredentials, response: Response):
    for user in fake_users_db:
        if user["username"] == user_creds.username and 
        user["password"] == user_creds.password:
            response.set_cookie(key="session_cookie", value="my_random_cookie")
            sessions[user_creds.username] = "my_random_cookie" 
            # это чисто для демонстрации, если 5 юзеров зайдут, то всем не нужно одинаковые куки ставить
            return {"message": "Login successful"}
    else:
        raise HTTPException(status_code=401, detail="Invalid credentials")


@app.get("/protected_data/", response_model=UserData) # возвращаем данные по кукам, если они валидны
def protected_data(request: Request):
    for username, cookie in sessions.items():
        if request.cookies.get("session_cookie") and cookie == request.cookies.get("session_cookie"):
            user = get_user_by_username(username)
            return UserData(**user)
    raise HTTPException(status_code=401, detail="Bad cookie")


def get_user_by_username(username: str): # вспомогательная функция по извлечению юзера из БД
    for user in fake_users_db:
        if user.get("username") == username:
            return user
    else:
        raise HTTPException(status_code=404, detail="User not found")
```

Тогда интеграционный тест мог бы быть таким:

```python
# test_app.py
from fastapi.testclient import TestClient
from main import app # тут замените импорт на правильное расположение файла


client = TestClient(app)

def test_login_and_access_data():
    # тестируем точку логина, направляя учетные данные и получая куки
    login_data = {
        "username": "user123",
        "password": "secretpassword"
    }
    response = client.post("/login/", json=login_data)
    assert response.status_code == 200
    assert "set-cookie" in response.headers

    # извлекаем куки из ответа
    cookies = response.cookies
    cookie_value = cookies["session_cookie"]

    # проверяем доступ к получению информации через полученные куки
    headers = {
        "Cookie": f"session_cookie= {cookie_value}"
    }
    response = client.get("/protected_data/", headers=headers)
    assert response.status_code == 200
    data = response.json()
    assert "user_id" in data
    assert "username" in data
    assert "email" in data
   
```

Мы, конечно, можем быть более тщательными, проверять разное поведение юзеров (в т.ч. неблагонадежное). Тут мы не проверяем подмену данных, крайние значения и прочее. Но главное понять **идею** - что мы можем имитировать действия пользователя (что он послал, что ему пришло, какой ответ дала база данных, записались ли значения, и прочее и прочее). То есть отличие интеграционного теста от модульного в том, что при интеграционном тестировании мы проверяем, как приложение работает в совокупности.

## Тестирование аутентификации и авторизации
Интеграционные тесты также полезны для тестирования механизмов аутентификации и авторизации в вашем приложении FastAPI. Вы можете смоделировать сценарии, в которых пользователи или службы имеют разные роли и разрешения, чтобы обеспечить надлежащий контроль доступа.

## Целостность данных и тестирование базы данных
Для приложений с интеграцией баз данных интеграционные тесты могут проверять целостность данных и тестировать различные операции CRUD. Вы можете создавать тестовые данные, выполнять операции с базой данных и проверять правильность извлечения и обновления данных.

## Тестирование непрерывной интеграции (CI)
Интеграционные тесты часто включаются в процесс непрерывной интеграции (CI). Тестирование CI включает в себя запуск автоматических тестов **всякий раз, когда изменения передаются в репозиторий кода**. Такая практика помогает выявлять проблемы на ранней стадии и гарантирует, что изменения не нарушат существующие функциональные возможности.

## Управление тестовыми базами данных
Для поддержания изоляции и контроля во время интеграционных тестов обычно используется отдельная тестовая база данных. Вы можете настроить свое приложение так, чтобы оно использовало тестовую базу данных во время тестирования, и сбрасывать ее перед каждым тестом, чтобы обеспечить чистый лист для каждого тестового примера.