
1. **Модульный код с внедрением зависимостей:** Внедрение зависимостей в приложениях FastAPI позволяет создавать модульный, поддерживаемый и тестируемый код.
2. **Последовательная проверка данных:** Всегда проверяйте и очищайте входящие данные, чтобы обеспечить целостность данных и предотвратить уязвимости в системе безопасности.
3. **Структурированное ведение журнала и обработка ошибок:** Внедрите структурированное ведение журнала и корректно обрабатывайте ошибки, чтобы облегчить отладку и мониторинг.
4. **Тестирование и разработка на основе тестов (TDD):** Используйте модульное тестирование, интеграционное тестирование и TDD для раннего выявления ошибок и обеспечения надежности кода.
5. **Эффективное взаимодействие с базой данных:** Оптимизируйте взаимодействие с базой данных, чтобы свести к минимуму запросы к базе данных и снизить накладные расходы.
6. **Возможности WebSockets в режиме реального времени:** Используйте поддержку WebSocket от FastAPI для приложений и функций реального времени.
7. **Непрерывная интеграция и непрерывное развертывание (CI/CD):** Настройте конвейеры CI/CD для автоматизации процессов тестирования и развертывания, обеспечивая надежные и быстрые обновления.
8. **Мониторинг и нагрузочное тестирование:** Следите за показателями производительности вашего развернутого приложения FastAPI и проводите нагрузочное тестирование для оценки масштабируемости и отзывчивости.

## Дополнительно про практики аутентификации

Как вы могли понять из содержания курса, с нашей стороны к процессу аутентификации очень аккуратное и бережное отношение. 

Тех, кто читал даже комментарии в курсе, мог заинтересовать **альтернативный подход** к передаче JWT-токенов в куках. И действительно, хочется, чтобы у учащихся было более осознанное понимание почему в курсе именно так преподносится.

Так вот. В приложении FastAPI может быть несколько способов аутентификации (например при помощи cookies и JWT) - и то, и то (одновременно внедрить куки для браузера, JWT для чистого API). Точнее мы можем так сделать сами (возможности есть, реализация на нас). 

Например мы можем сделать, что при проверке аутентификации каждый метод запускается один за другим. И выигрывает первый метод, возвращающий пользователя (информацию о том, кто пытается войти). Если ни один из методов не возвращает пользователя, вызываем HTTPException. Это вполне реальный **вариант** реализации системы аутентификации.

Или наоборот, мы можем выдать два неких токена, которые бы дополняли друг друга. И только если оба токена валидны, то пропускаем, иначе - не доверяем и просим пройти повторную процедуру логина.

**Таким образом, система аутентификации может быть построена как только на токенах JWT, так могут быть скомбинированы различные подходы для перекрытия минусов каждого из них для взаимодополнения и достижения максимального уровня безопасности. Дальше опишем только часть про альтернативы в системе JWT-токенов.**

> _Кстати, рекомендуем в коде выделить процесс аутентификации в отдельную группу роутов (с общим тегом, например "Auth"), либо в отдельное суб-приложение, так как это довольно удобно (посмотрите пример структуры проекта в предыдущем шаге)._ 

### Транспорт + Стратегия = Серверная часть аутентификации по JWT

Серверная часть аутентификации по JWT-токену состоит из двух частей:

### Транспорт

Он управляет тем, как токен будет передаваться по запросу.

**Вариант 1 - предъявитель (это проходили в курсе):**

Токен будет отправлен через `Authorization: Bearer` заголовок.

**За и против**

✅ Легко читается и устанавливается в каждом запросе.

❌ Необходимо хранить вручную где-то в клиенте.

➡️ Используйте его, если хотите реализовать мобильное приложение или чистый REST API.

**Вариант 2 - куки (не описывалось в курсе):**

Токен будет отправлен через файл `cookie`.

**За и против**

✅ Автоматически сохраняется и безопасно отправляется веб-браузерами при каждом запросе.

✅ Автоматически удаляется веб-браузерами по истечении срока действия, в том числе можно самим "сжечь" токен раньше времени его сгорания, обновив поля `expires` и `max_age` (или `delete_cookie`).

❌ Нуждается в защите CSRF для максимальной безопасности.

❌ Труднее работать вне браузера, например, в мобильном приложении или на сервере.

➡️ Используйте его, если хотите реализовать веб-интерфейс.

**Вывод-обоснование подхода: в курсе мы концентрировались именно на создании чистого API, плюс сейчас нельзя исключать того, что ваш API в будущем станет популярным, и вы выпустите мобильное приложение, популярность которых с годами растёт по отношению к классическому (браузерному) вэбу, то есть мы делаем "закладку" на будущее. Дополнительно классические куки можно использовать параллельно с JWT, что также с нашей стороны указывает на возможность выбора иного способа транспорта токена JWT (куки в куках + JWT в заголовке "Authorization", а не JWT в куках).**

**При этом у второго способа JWT в куках также имеются свои плюсы (флаги передачи httpOnly и пр.), поэтому выбирайте исходя из своих потребностей, многие используют и второй способ (с куками), поэтому в информация в курсе - не аксиома.** 

### Стратегия

Оно управляет тем, как генерируется и защищается токен. В настоящее время наиболее распространены три метода:

**Автономный JWT**

Токен является автономным веб-маркером JSON. Выпустили, передали клиенту и у себя не храним. Это представлено в курсе и соответствует REST. 

**За и против**

✅ Автономный: его не нужно хранить в базе данных. Соответственно не нужны ресурсы (память) с нашей стороны. 

❌ Не может быть аннулирован на стороне сервера: он действителен до истечения срока его действия.

➡️ Используйте его, если хотите быстро приступить к работе.

Именно то, что это самый простой метод с небольшим недостатком, и явилось причиной того, что мы про него и рассказывали (другие способы сложнее). Также при необходимости недостаток отсутствия возможности отзыва токена можно компенсировать введением дополнительных мер безопасности.

**База данных**

Токен хранится в таблице (или коллекции) в вашей базе данных.

**За и против**

✅ Безопасный и производительный.

✅ Токены могут быть признаны недействительными на стороне сервера путем их удаления из базы данных.

✅ Широкие возможности настройки: добавьте свои собственные поля, создайте API для получения активных сеансов ваших пользователей и т.д.

❌ Конфигурация намного сложнее.

❌ Также каждый логин занимает больше времени (обратиться в БД, получить результат, выполнить логику) и можно "перетянуть на себя" время на обработку полезных подключений к БД.

➡️ Используйте его, если хотите максимальной гибкости в управлении вашими токенами, и если нужна долговременность хранения токенов. 

**Redis**

Токен хранится в хранилище ключей Redis.

**За и против**

✅ Безопасный и производительный.

✅ Токены можно сделать недействительными на стороне сервера, удалив их из Redis.

❌ Требуется сервер Redis.

➡️ Используйте его, если хотите получить максимальную производительность и иметь возможность аннулировать токены.

**Если объем кэша позволяет, то мы бы рекомендовали именно этот способ, так как у него лучший баланс в простоте настройки, удобстве и гибкости хранения сессий (минус - если взломают сервер и украдут токены незаметно для нас).**

**Либо в целом не хранить токены, но грамотно выбрать время сгорания (чтобы не слишком часто запрашивать логин/пароль, но и не сильно быть подверженым тому, что где-то кто-то ворует по пути доставки или у пользователей выданные JWT). Стоит помнить, что потом мы открываем доступ предъявителю, которым может быть злоумышленник. Везде есть и плюсы, и минусы в общем.**

