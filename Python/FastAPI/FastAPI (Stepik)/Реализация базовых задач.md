

## Реализация аутентификации через форму с помощью JWT

```python
from fastapi import FastAPI, HTTPException, Depends, status

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm # для реквест-формы нам нужно установить доп. библиотеку командой pip install python-multipart

from pydantic import BaseModel

import jwt

from typing import Optional, Annotated

from datetime import timedelta, datetime, timezone

'''тут работаем с библиотекой PyJWT,

но в реальной жизни вы скорее всего предпочтете 'python-jose', которая чуть шире PyJWT и рекомендуется самими FastAPI

'''

  

app = FastAPI()

  

# Секретный ключ для подписи и верификации токенов JWT

SECRET_KEY = "mysecretkey" # тут мы в реальной практике используем что-нибудь вроде команды Bash (Linux) 'openssl rand -hex 32', и храним очень защищенно

ALGORITHM = "HS256"

ACCESS_TOKEN_EXPIRE_MINUTES = 15

  

# Пример информации из БД

USERS_DATA = {

"admin": {"username": "admin", "password": "adminpass", "role": "admin"},

"user": {"username": "user", "password": "userpass", "role": "user"},

} # в реальной БД мы храним только ХЭШИ паролей (можете прочитать про библиотеку, к примеру, 'passlib') + соль (известная только нам добавка к паролю)

  

# OAuth2PasswordBearer для авторизации по токену

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

  
  

# Модель User для аутентификации (если делали задание по JWT, то тут добавляем только роль)

class User(BaseModel):
	username: str
	password: str	
	role: Optional[str] = None

  
  

# Функция для создания JWT токена

def create_jwt_token(data: dict, expire_time: timedelta):
	expire = datetime.now(timezone.utc) + expire_time
	data.update({'exp':expire})

	return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

  
  

# Функция получения User'а по токену - это скорее всего была самая сложная часть в предыдущем задании
def get_user_from_token(token: str = Depends(oauth2_scheme)):
	try:
		payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) #             Декодируем токен
	
	return payload.get("sub") # тут мы идем в полезную нагрузку JWT-токена и возвращаем утверждение о юзере (subject); обычно там еще можно взять "iss" - issuer/эмитент, или "exp" - expiration time - время 'сгорания' и другое, что мы сами туда кладем
	
	except jwt.ExpiredSignatureError:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Token has expired",
			headers={"WWW-Authenticate": "Bearer"},
		)
	
	except jwt.InvalidTokenError:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Invalid token",
			headers={"WWW-Authenticate": "Bearer"},
		)

  
  

# Функция для получения пользовательских данных на основе имени пользователя
def get_user(username: str):
	if username in USERS_DATA:
		user_data = USERS_DATA[username]
		
		return User(**user_data)
	return None

  
  

# Роут для получения JWT-токена (так работает логин)
@app.post("/token/")
def login(user_data: Annotated[OAuth2PasswordRequestForm, Depends()]): # тут логинимся через форму
	user_data_from_db = get_user(user_data.username)
	if user_data_from_db is None or user_data.password != user_data_from_db.password:
	raise HTTPException(
		status_code=status.HTTP_401_UNAUTHORIZED,
		detail="Invalid credentials",
		headers={"WWW-Authenticate": "Bearer"},
	)

	return {"access_token": create_jwt_token({"sub": user_data.username}, timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))} # тут мы добавляем полезную нагрузку в токен, и говорим, что "sub" содержит значение username

  
  

# Защищенный роут для админов, когда токен уже получен
@app.get("/admin/")
def get_admin_info(current_user: str = Depends(get_user_from_token)):
	user_data = get_user(current_user)
	if user_data.role != "admin":
	
		raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")

	return {"message": "Welcome Admin!"}

  
  

# Защищенный роут для обычных пользователей, когда токен уже получен

@app.get("/user/"
def get_user_info(current_user: str = Depends(get_user_from_token)):
	user_data = get_user(current_user)
	if user_data.role != "user":
		raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized")
		
	return {"message": "Hello User!"}
```


## Добавление ORM SqlAlchemy
```python
# db.py
from sqlalchemy import create_engine #

from sqlalchemy.orm import DeclarativeBase, sessionmaker

from sqlalchemy import Column, String, Integer

  

SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"
# Определение движка
engine = create_engine(
SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False} # Для возможности использования больше 1-го потока
# (в sqlite по умолчанию есть возможность только для одного)
)

  

#Для создания моделей необходима базовая модель, от которой потом наследуются остальные модели.
#Для создания базовой модели можно использовать различные способы, но самый короткий - создания класса модели
# с помощью функции declarative_base():
class Base(DeclarativeBase): pass

# То есть в данном случае определяется класс Base - базовая модель.
# Затем уже можно определить конкретные модели, данные которых будут храниться в БД.

# Например:
class Person(Base):
	__tablename__ = 'people' # Имя таблицы , с которой будет сопоставляться текущая модель. То есть данные класса Person будут храниться в таблице "people".
	
	id = Column(Integer, primary_key=True, index=True, autoincrement=True)
	
	name = Column(String)
	
	age = Column(Integer, )

  

# необходимо создать сессию базы данных, которая представляет объект sqlalchemy.orm.Session.
# Через этот объект идет вся работа с БД. Но для этого вначале надо создать класс-построитель
# Session с помощью функции-фабрики sessionmaker()
SessionLocal = sessionmaker(autoflush=False, bind=engine)
db = SessionLocal()

# Для создания базы данных и таблиц по метаданным моделей применяется метод Base.metadata.create_all().

# Его ключевой параметр - bind принимает класс, который используется для подключения к базе данных.
# В качестве такого класса применяется созданный ранее движок SQLAlchemy.
# Если база данных и все необходимые таблицы уже имеются, то метод не создает заново таблицы.


```


```python
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from db import *

  

app = FastAPI()
Base.metadata.create_all(bind=engine) # Создаём таблицы

def get_db():
	db = SessionLocal()
	try:
		yield db
	finally:
		db.close()


@app.get('/')
def root(id: int, db: Session = Depends(get_db)):
	person = db.query(Person).filter(Person.id==id).first()
	return {
		'id':person.id,
		'name': person.name,
		'age': person.age,
	}

  

@app.post('/')
def root(name:str, age:int, db: Session = Depends(get_db)):
	new_person = Person(name=name, age=age)
	db.add(new_person)
	db.commit()

	return {
		'id':new_person.id,
		'name': new_person.name,
		'age': new_person.age,
	}
```