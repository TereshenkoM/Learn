В приложениях FastAPI внешние зависимости, такие как _базы данных, внешние API-интерфейсы или сторонние сервисы_, играют решающую роль в предоставлении дополнительной функциональности. Однако при написании модульных тестов мы хотим **изолировать тестируемый код** от этих внешних зависимостей. **Имитация (подделка, мокинг)** внешних зависимостей позволяет нам заменять реальные реализации контролируемыми заменителями, гарантируя, что наши тесты фокусируются исключительно на конкретной тестируемой единице кода.

## Потребность в мокинге

Модульные тесты должны быть быстрыми, надежными и повторяемыми. Без мокинга модульные тесты могут _замедлиться из-за времени, затрачиваемого на взаимодействие_ с реальными базами данных или API. Более того, опора на реальные реализации может привести к несогласованным результатам тестирования из-за _внешних факторов_, таких как доступность сети или изменения данных.

## Использование `unittest.mock` для мокинга
Встроенная в Python библиотека `unittest.mock` предоставляет мощные инструменты для мокинга над объектами и функциями. С помощью `` `unittest.mock` `` мы можем создавать **макетные объекты**, которые имитируют поведение реальных объектов или функций, что делает их подходящей заменой внешних зависимостей в модульных тестах.
Встроенная в Python библиотека `unittest.mock` предоставляет мощные инструменты для мокинга над объектами и функциями. С помощью `` `unittest.mock` `` мы можем создавать **макетные объекты**, которые имитируют поведение реальных объектов или функций, что делает их подходящей заменой внешних зависимостей в модульных тестах.



## Замена внешних зависимостей 
В FastAPI внешние зависимости часто внедряются в конечные точки или службы с помощью внедрения зависимостей. Заменяя эти зависимости фиктивными объектами во время модульных тестов, мы можем контролировать данные и поведение, которые они предоставляют, что позволяет нам более эффективно тестировать различные сценарии.

Допустим, у нас есть часть кода, которая что-то делает с внешним API:

```python
# external_api.py

import requests

def fetch_data_from_api():
    response = requests.get("https://api.example.com/data")
    if response.status_code == 200:
        return response.json()
    else:
        return None

def process_data(data):
    # какая-то логика обработки данных
    new_data = {}
    for key, value in data.items():
        new_data[key.upper()] = value.upper()
    return new_data
```

И потом мы эти данные как-то обрабатываем в основном приложении:

```python
# app.py

from external_api import fetch_data_from_api, process_data

def get_and_process_data():
    data = fetch_data_from_api()
    if data:
        return process_data(data)
    else:
        return None
```

Давайте напишем юнит-тест для `get_and_process_data` функции, используя `unittest.mock`:

```python
# test_app.py

import unittest
from unittest.mock import patch, MagicMock
from app import get_and_process_data

class TestApp(unittest.TestCase):

    @patch("app.fetch_data_from_api")
    @patch("app.process_data")
    def test_get_and_process_data(
	    self, mock_process_data: MagicMock, mock_fetch_data: MagicMock):
        # Mock функции fetch_data_from_api для возврата "sample response" 
        mock_response = {"key": "value"}
        mock_fetch_data.return_value = mock_response

        # Mock функции process_data 
        mock_processed_data = {"KEY": "VALUE"}
        mock_process_data.return_value = mock_processed_data

        # вызываем тестируемую функцию
        result = get_and_process_data()

        # Assertions
        mock_fetch_data.assert_called_once()  
        # убеждаемся, что fetch_data_from_api был вызван
        
        mock_process_data.assert_called_once_with(mock_response)  
        # убеждаемся, что process_data была вызвана с "mocked response" 
    
        self.assertEqual(result, mock_processed_data)  
        # убеждаемся, что функция вернула ожидаемые обработанные данные
```

В приведенном выше тесте мы использовали декоратор `` `patch` `` для имитации функций `` `fetch_data_from_api` `` и `` `process_data` ``. Мы также создали фиктивные возвращаемые значения для обеих функций, используя `` `return_value` ``. При такой настройке фактические функции `` `fetch_data_from_api` `` и `` `process_data` `` заменяются фиктивными объектами во время выполнения теста. Затем мы можем утверждать, что эти поддельные функции были вызваны правильно и что функция `` `get_and_process_data` `` ведет себя так, как ожидалось. Используя `` `unittest.mock` ``, мы можем изолировать наши модульные тесты от внешних зависимостей, делая их более надежными и быстрыми.

## Лучшие практики для мокинга

Хотя мокинг является мощным инструментом для модульного тестирования, его следует использовать разумно. _**Чрезмерное использование**_ макетов или написание тестов, тесно связанных с деталями реализации, может привести к хрупким тестам, которые легко ломаются при изменении кода. Поэтому важно следовать лучшим практикам и разрабатывать тестируемый код для достижения надежных и поддерживаемых модульных тестов.

## Исправление внешних функций

Одним из распространенных вариантов использования **mocking** в FastAPI является исправление _внешних функций_, которые взаимодействуют с базами данных или API. Исправляя эти функции, мы можем контролировать их возвращаемые значения или моделировать различные ответы, обеспечивая всесторонний охват тестированием.

## Проверка вызовов функций

В дополнение к замене внешних зависимостей, мы также можем проверить, что определенные функции или методы **вызываются** во время модульных тестов. Это полезно для обеспечения того, чтобы определенные действия или запросы выполнялись должным образом в тестируемом коде.

Библиотека `` `unittest.mock` `` предоставляет `` `assert_called_once` ``, `` `assert_called_with` `` и другие методы утверждения, которые позволяют вам проверить, была ли вызвана функция или метод с определенными аргументами.

Давайте модифицируем предыдущий код для демонстрации, **объединив** для читаемости `external_api.py` и `app.py`:

```python
# main.py

from fastapi import FastAPI, Depends
import requests

app = FastAPI()

# Внешний API URL (для демонстрации процесса обратимся сами к себе, но тут должен быть реальный)
EXTERNAL_API_URL = "https://catfact.ninja/fact"


# функция для получения данных из внешнего API
def fetch_data_from_api():
    response = requests.get(EXTERNAL_API_URL)
    if response.status_code == 200:
        return response.json()
    else:
        return None


# функция для обработки данных
def process_data(data):
    # как-то логика обработки данных
    new_data = {}
    for key, value in data.items():
        new_data[key.upper()] = value.upper()
    return new_data


# роут, который извлекает и обрабатывает данные от внешнего API
@app.get("/data/")
async def get_and_process_data():
    data: dict = fetch_data_from_api()
    if data:
        return process_data(data)
    else:
        return {"error": "Failed to fetch data from the external API"}
```

Теперь давайте напишем модульный тест, чтобы убедиться, что функции `` `fetch_data_from_api` `` и `` `process_data` `` вызываются во время выполнения конечной точки `` `/data/` ``:

```python
# test_main.py

import unittest
from fastapi.testclient import TestClient
from main import app, fetch_data_from_api, process_data
from unittest.mock import patch

client = TestClient(app)


class TestMain(unittest.TestCase):

    @patch("main.fetch_data_from_api")
    @patch("main.process_data")
    def test_get_and_process_data(self, mock_process_data, mock_fetch_data):
        # Имитируем функцию fetch_data_from_api, чтобы вернуть пример ответа 
        mock_response = {"key": "value"}
        mock_fetch_data.return_value = mock_response

        # имитируем функцию process_data
        mock_processed_data = {"KEY": "VALUE"}
        mock_process_data.return_value = mock_processed_data

        # отправляем запрос на конечную точку /data/ 
        response = client.get("/data/")

        # наши assertions
        mock_fetch_data.assert_called_once()  
        # Убеждаемся, что fetch_data_from_api был вызван один раз
        mock_process_data.assert_called_once_with(mock_response)  
        # убеждаемся, что process_data был вызван с "mocked response" 
        self.assertEqual(response.status_code, 200)  
        # проверяем что status code равен 200
        self.assertEqual(response.json(), mock_processed_data)  
        # проверяем, что данные ответа соответствуют
         # имитируемым обработанным   данным
```

В тесте мы используем декоратор `` `@patch` ``, чтобы заменить функции `` `fetch_data_from_api` `` и `` `process_data` `` фиктивными объектами. Затем мы используем метод `` `assert_called_once` ``, чтобы убедиться, что каждая функция вызывается ровно один раз во время выполнения конечной точки `` `/data/` ``.

Метод `` `assert_called_once_with` `` используется для проверки того, что функция `` `process_data` `` вызывается с ожидаемым аргументом `` `mock_response` ``.

Используя эти методы утверждения (assertions), мы можем подтвердить, что желаемые функции вызываются с ожидаемыми аргументами, гарантируя, что код ведет себя так, как задумано во время модульных тестов.

