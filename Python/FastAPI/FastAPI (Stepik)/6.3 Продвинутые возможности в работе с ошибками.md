
## Объединение возможностей

Комбинируя пользовательские **классы** **исключений** с пользовательскими **моделями реагирования** на ошибки, вы можете точно контролировать содержимое ответов об ошибках для различных типов исключений. Такой подход гарантирует, что сообщения об ошибках будут точными и непротиворечивыми.

## Интернационализация (i18n) для сообщений об ошибках

В FastAPI можно добавить **интернационализацию (i18n)**, позволяющую доставлять сообщения об ошибках на нескольких языках в зависимости от языкового стандарта пользователя, что является хорошей практикой во взаимодействии с пользователями.

Пример: библиотека
`fastapi_localization`.




## Коды ответов на запросы и ошибки, метаданные
Пользовательские ответы об ошибках должны включать соответствующие коды состояния HTTP, указывающие на характер ошибки. Кроме того, вы можете включать метаданные в ответы об ошибках, такие как например временные метки, чтобы помочь в устранении неполадок и анализе ошибок.

Кратко о значениях кодов:

- 1XX – статус-коды информационного типа. Они редко используются разработчиками напрямую. Ответы с этими кодами не могут иметь тела.
- 2XX – статус-коды, сообщающие об успешной обработке запроса. Они используются чаще всего.
- 3XX – статус-коды, сообщающие о перенаправлениях. Ответы с этими кодами статуса могут иметь или не иметь тело, за исключением ответов со статусом 304, "Not Modified", у которых не должно быть тела.
- 4XX – статус-коды, сообщающие о клиентской ошибке. Это ещё одна наиболее часто используемая категория.
- 5XX – статус-коды, сообщающие о серверной ошибке. Они почти никогда не используются разработчиками напрямую. Когда что-то идет не так в какой-то части кода вашего приложения или на сервере, он автоматически вернёт один из 5XX кодов.

Продвинутый пример. Представьте, что вы хотите вернуть стандартный HTTP статус код "OK" `200`.

Но если данных ранее не существовало, то вернуть HTTP статус код "CREATED" `201`.

При этом вам все ещё необходимо иметь возможность фильтровать и конвертировать данные, которые вы возвращаете при помощи `response_model`.

Для этого вы можете использовать `Response` параметр:

```python
from fastapi import FastAPI, Response, status
app = FastAPI()

tasks = {"foo": "Listen to the Bar Fighters"}


@app.put("/get-or-create-task/{task_id}", status_code=200)
def get_or_create_task(task_id: str, response: Response):
    if task_id not in tasks:
        tasks[task_id] = "This didn't exist before"
        response.status_code = status.HTTP_201_CREATED
    return tasks[task_id]
```

И потом вы можете вернуть любой объект, который вам нужно (словарь, `database model`, и тд.). При этом ваша `response_model` будет иметь возможность фильтровать и конвертировать данные как обычно.

## Добавление кастомных заголовках при расширении информации об ошибках

Вы можете добавить кастомные (пользовательские) заголовки в вашем FastAPI приложении. Это может потребоваться, например, для некоторых типов обеспечения безопасности. 

Этого можно добиться, например, так:

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}


@app.get("/items-header/{item_id}")
async def read_item_header(item_id: str):
    if item_id not in items:
        raise HTTPException(
            status_code=404,
            detail="Item not found",
            headers={"X-Error": "There goes my error"},
        )
    return {"item": items[item_id]}
```

В данном примере мы расширили класс `HTTPException`, добавив заголовок `"X-Error"`.

## Переопределение исключений проверки (валидации) запроса

Когда запрос содержит **недопустимые данные**, Fast API автоматически выдает ошибку проверки запроса.

И он также включает в себя **обработчик исключений** по умолчанию для него.

Чтобы переопределить его, импортируйте `RequestValidationError` и используйте с помощью `@app.exception_handler(RequestValidationError)` для оформления обработчика исключений.

Обработчик исключений получит Request и само исключение. Таким образом можно переопределить (расширить) не только класс `HTTPException`.

```python
from fastapi import FastAPI, HTTPException
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, exc):
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return PlainTextResponse(str(exc), status_code=400)


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}
```

## Повторно используйте обработчики исключений FastAPI

Можно использовать исключение вместе с теми же обработчиками исключений по умолчанию из Fast API, вы можете импортировать и повторно использовать обработчики исключений по умолчанию из fastapi.exception_handlers:

```python
from fastapi import FastAPI, HTTPException
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()


@app.exception_handler(StarletteHTTPException)
async def custom_http_exception_handler(request, exc):
    print(f"OMG! An HTTP error!: {repr(exc)}")
    return await http_exception_handler(request, exc)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    print(f"OMG! The client sent invalid data!: {exc}")
    return await request_validation_exception_handler(request, exc)


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}
```