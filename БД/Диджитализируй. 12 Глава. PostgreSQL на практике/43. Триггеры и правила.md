В postgres есть два механизма, которые позволяют автоматически изменять или проверять данные при внесении изменений в таблицу:
* Триггеры - код, который автоматически выполняется при определённых событиях в таблице. Могут быть использованы для логгирования изменений в таблице, для валидации данных (сложная логика которая проверит корректность изменений). Позволяют обновлять связанные таблицы (автоматическое обновление аналитики по продажам при новой продаже)

Пример. Будем логгировать операции в таблице client
```postgresql
drop table if exists client, client_log;

create table client(
    client_id bigint generated always as identity primary key,
    first_name varchar(200) not null,
    last_name varchar(200),
    middle_name varchar(200)
);

create table client_log (
    client_log_id bigint generated always as identity primary key,
    client_id int,
    action text,
    change_time timestamp default now(),
    new_first_name varchar(200),
    new_last_name varchar(200),
    new_middle_name varchar(200),
    old_first_name varchar(200),
    old_last_name varchar(200), old_middle_name varchar(200)
);

create or replace function log_client_changes()
returns trigger as $$
begin
    insert into client_log (client_id, action, change_time, 
                            new_first_name, new_last_name, new_middle_name, 
                            old_first_name, old_last_name, old_middle_name)
    values (coalesce(new.client_id, old.client_id), tg_op, now(),
            new.first_name, new.last_name, new.middle_name,
            old.first_name, old.last_name, old.middle_name);
    
    return new;
end;
$$ language plpgsql;

create trigger client_changes_trigger
after insert or update or delete
on client
for each row
execute function log_client_changes();
```

Здесь создаются таблицы `client` и `client_log`. Создаётся функция `log_client_changes`, которая возвращает триггер и выполняет нужную нам операцию, в нашем случае вставки данных в таблицу лога. И затем создаётся сам триггер `client_insert_trigger`, который будет автоматически запускаться при каждом `insert` в таблицу `client` (и каждом `update`).

Проверим
```postgresql
insert into client (first_name, last_name, middle_name) values
('Пётр', 'Петрович', 'Петров');

table client;
 client_id | first_name | last_name | middle_name
-----------+------------+-----------+-------------
         1 | Пётр | Петрович | Петров
(1 строка)

\x

table client_log;
-[ RECORD 1 ]---+---------------------------
client_log_id | 1
client_id | 1
action | INSERT
change_time | 2025-02-23 01:21:40.917117
new_first_name | Пётр
new_last_name | Петрович
new_middle_name | Петров
old_first_name |
old_last_name |
old_middle_name |

update client set last_name='Мусечкин' where client_id=1;

table client_log;

...
-[ RECORD 2 ]---+---------------------------
client_log_id | 2
client_id | 1
action | UPDATE
change_time | 2025-02-23 01:22:18.161066
new_first_name | Пётр
new_last_name | Мусечкин
new_middle_name | Петров
old_first_name | Пётр
old_last_name | Петрович
old_middle_name | Петров

delete from client where client_id =1;

table client_log;
...
-[ RECORD 3 ]---+---------------------------
client_log_id | 3
client_id | 1
action | DELETE
change_time | 2025-02-23 01:22:44.027695
new_first_name |
new_last_name |
new_middle_name |
old_first_name | Пётр
old_last_name | Мусечкин
old_middle_name | Петров
```

Можно делать не только это, конечно. Можно сделать, например, валидацию данных. Например, сделать так, чтобы email нельзя было менять после вставки:

```postgresql
drop table if exists client, client_log cascade;

create table client(
    client_id bigint generated always as identity primary key,
    name varchar(200) not null,
    email varchar(320) not null
);

create or replace function prevent_email_update()
returns trigger as $$
begin
    if old.email is distinct from new.email then
        raise exception 'изменение email запрещено';
    end if;
    return new;
end;
$$ language plpgsql;

create trigger prevent_email_change
before update on client
for each row
execute function prevent_email_update();
```

Попробуем вставить данные и затем изменить `email`:
```postgresql
insert into client (name, email) values ('Alexey', 'hi@to.digital');

update client set email='course@to.digital' where client_id=1;
ERROR: изменение email запрещено
КОНТЕКСТ: PL/pgSQL function prevent_email_update() line 4 at RAISE

\x

table client;

 client_id | name | email
-----------+--------+---------------
         1 | Alexey | hi@to.digital
```


* Правила - это механизм, который позволяет перезаписать SQL-запрос перед его выполнением. В отличие от триггеров, правила **не вызывают функцию**, а заменяют или модифицируют запрос.
Например
Можно реализовать мягкое удаление — когда при выполнении `DELETE` строка не будет удаляться, а будет только помечаться удалённой с помощью `UPDATE`:

```postgresql
drop table if exists client;

create table client(
    client_id bigint generated always as identity primary key,
    name varchar(200) not null,
    is_deleted boolean default false not null
);

create rule soft_delete as
on delete to client
do instead
    update client set is_deleted = true where client_id = old.client_id;

insert into client (name) values ('Пётр');

table client;

delete from client where client_id=1;

table client;
-- is_deleted=true
```

С помощью правил можно вообще запретить обновление данных таблицы и удаление оттуда строк:
```postgresql
drop table if exists client;

create table client(
    client_id bigint generated always as identity primary key,
    name varchar(200) not null
);

insert into client (name) values ('Пётр');

create rule no_update as
on update to client
do instead nothing;

create rule no_delete as
on delete to client
do instead nothing;

update client set name='Василий' where client_id=1;
-- UPDATE 0

table client;
 client_id | name
-----------+------
         1 | Пётр
```