
Механизм блокировок можно использовать явно. Обычно в Postgres он используется неявно в процессе выполнения транзакций.

Механизм блокировок позволяет нам явно захватить и отпустить блокировку. Например: взять и установить блокировку на любые изменения в соседних транзакциях, или заблокировать изменения в конкретных строках таблицы.

Наиболее часто используемая блокировка это select for update. Позволяет получить блокировку на ряде строк и она автоматически отпускается когда транзакция коммититься или отпускается.

Пример: Есть задача бронирования номера в отеле и одновременно поступает две брони на один номер.

```postgresql
drop table if exists booking;

create table booking (
	booking_date date not null,
	room_id bigint not null,
	booked_by bigint, --тут FK на таблицу пользователей
	primary key (booking_date, room_id)
);

insert into booking(booking_date, room_id, booked_by)
values (current_date, 1, 777), (current_date, 2, null);
```

Первая комната занята пользователем с id 777. Вот в двух параллельных транзакциях и бронируют два пользователя c id 888 и 999.

Запустим в параллель две транзакции. 
```postgresql
--first
begin;

select * from booking
where booking_date=current_date and booked_by is null;
-- room_id=2

update booking set booked_by = 888 where room_id=2 and booking_date=current_date;

--second
begin;

select * from booking
where booking_date=current_date and booked_by is null;
-- room_id=2

update booking set booked_by = 999 where room_id=2 and booking_date=current_date;

--first
commit;

--second
commit;
 
table booking;


booked_date   room_id    booked_by
2025-10-06	     1	     777
2025-10-06	     2	     999
```

В итоге сначала мы забронировали номер в первой транзакции (проверили наличие мы одновременно, следовательно везде БД выдала пустой номер с room_id=2), а потом забронировали тот же номер во второй транзакции. При этом БД нигде не упала с ошибкой, обе транзакции проверили доступность номера и при этом в БД сохранилась бронь по факту выполнения обоих транзакций только одного пользователя.

Как этого избежать? Можно использовать более жёсткий уровень REPEATABLE READ:
```postgresql
truncate booking restart identity;
insert into booking(booking_date, room_id, booked_by)
values (current_date, 1, 777),
(current_date, 2, null);


-- first
begin transaction isolation level repeatable read;

select * from booking
where booking_date=current_date and booked_by is null;
-- room_id=2

update booking set booked_by = 888 where room_id=2 and booking_date=current_date;

-- second
begin transaction isolation level repeatable read;

select * from booking
where booking_date=current_date and booked_by is null;
-- room_id=2

update booking set booked_by = 999 where room_id=2 and booking_date=current_date;


-- first
commit;

-- second
-- Получаем ошибку
--SQL Error [40001]: ERROR: could not serialize access due to concurrent update

rollback;

table booking;

booking_date | room_id | booked_by
--------------+---------+-----------
2025-02-18 | 1 | 777
2025-02-18 | 2 | 888
(2 строки)
```

Однако есть одна проблема, они работают медленнее, чем дефолтный уровень изоляции READ COMMITED. Мы можем добиться такого же эффекта на READ COMMITED, если заблокируем строки для изменения. Для этого есть конструкция **select for update**.

```postgresql
truncate booking restart identity;
insert into booking(booking_date, room_id, booked_by)
values (current_date, 1, 777),
    (current_date, 2, null);

-- first
begin;

select * from booking
where booking_date=current_date and booked_by is null for update;
-- берём в блокировку все пустые комнты. Другие транзакци не могут её завхватить
-- room_id=2

update booking set booked_by = 888 where room_id=2 and booking_date=current_date;

-- second
begin;

select * from booking
where booking_date=current_date and booked_by is null for update;
-- зависла — ожидает, пока отпустит блокировку соседняя транзакция

-- first
commit;

-- second
-- ничего не вернула — номер уже недоступен

table booking;
 booking_date | room_id | booked_by
--------------+---------+-----------
 2025-02-18 | 1 | 777
 2025-02-18 | 2 | 888
(2 строки)
```

**Задача select for update одна. Заблокировать строки  и не дать другим транзакциям использовать их.**

Также есть возможность пропускать заблокированные строки при выборке. Для этого есть конструкция для **select for update - SKIP LOCKED**

```postgresql
truncate booking restart identity;
insert into booking(booking_date, room_id, booked_by)
values (current_date, 1, 777),
    (current_date, 2, null),
    (current_date, 3, null);

-- first
begin;

select * from booking
where booking_date=current_date and booked_by is null
limit 1
for update skip locked;
-- room_id=2

update booking set booked_by = 888 where room_id=2 and booking_date=current_date;

-- second
begin;

select * from booking
where booking_date=current_date and booked_by is null
limit 1
for update skip locked;
-- room_id=3

update booking set booked_by = 999 where room_id=3 and booking_date=current_date;
commit;

-- first
commit;

table booking;
 booking_date | room_id | booked_by
--------------+---------+-----------
 2025-02-18 | 1 | 777
 2025-02-18 | 2 | 888
 2025-02-18 | 3 | 999
```

