Полнотекстовой поиск - это поиск по всему тексту, причём как правило не по точному совпадению слова, а игнорируя форму слова. Чтобы Москва и Москвы и Москве воспринимались как одно слово и находились при поиске.

Как это делается?

Все слова преобразуются в лексемы (стандартизированные версии слова) и они индексируются.

```postgresql
select to_tsvector('russian', 'Пример текста для полнотекствого поиска')
-----------------
'поиск':5 'полнотекств':4 'пример':1 'текст':2
```

В результате мы получили лексемы. На первом месте стоит лексема "пример", на втором месте "текст", третье слово "для" пропущено как незначительное для поиска, на четвёртом месте "полнотекстов", на пятом "поиск".

Тот текст, который мы ищем, надо преобразовать в `tsquery`, т.е. в запрос:
```postgresql
select to_tsquery('russian', 'полнотекстовая')
------
to_tsquery
'полнотекстов'
```

И этот `tsquery` можно искать в `tsvector`:
```postgresql
SELECT to_tsvector('russian', 'Пример текста для полнотекстового поиска') @@ to_tsquery('russian', 'полнотекстовая');
----------
t
```

На выходе `TRUE` — значит, в строке найдена наша подстрока. Обратите внимание — в целом подстрока «полнотекстовая» не входит в таком виде в строку «Пример текста для полнотекстового поиска». Однако благодаря стеммингу, то есть стандартизации слов, всё находится.

В реализации на таблице есть два подхода - использовать функциональный GIN-индекс или добавить столбец в таблицу, который будет хранить tsvector - данные, и триггер, который будет гарантировать синхронизацию `tsvector` с реальным текстом, ну или просто `generated always` логику.

На практике для ускорения поиска и возможности ранжирования результатов поиска лучше хранить `tsvector` в самой таблице.
Пример
```postgresql
drop table if exists article;

create table article (
article_id bigint generated always as identity primary key,
title text not null,
content text not null,
tsv_content tsvector generated always as (to_tsvector('russian', content)) stored
);

-- 2. Создание GIN-индекса для быстрого поиска
create index idx_article_fts on article using gin(tsv_content);

-- 3. Вставка тестовых данных
insert into article (title, content) values
('Как использовать PostgreSQL', 'Этот материал расскажет вам про основы PostgreSQL и его возможности.'),
('Полнотекстовый поиск', 'В PostgreSQL есть мощные инструменты для полнотекстового поиска.'),
('Работа с индексами', 'Индексы помогают ускорять поиск данных в базе.');

-- 4. Пример полнотекстового поиска
select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'инструментом');
----------------------------
2 | Полнотекстовый поиск | В PostgreSQL есть мощные инструменты для полнотекстового поиска.
```

Причём если мы обновим данные в таблице, то векторы тоже пересчитаются. Обновлять колонку `tsv_content` вручную незачем:
```postgresql
update article set content='В PostgreSQL можно хранить даже бананы, жёлтые и зелёные' where article_id=2;

select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'инструментом');
-- nothing

select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан');
-- нашлось!
```

При этом можно искать и по нескольким словам.
```postgresql
select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан & желтый');
-- нашлось

select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан & жёлтый');
-- с ё, тоже нашлось

select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан & ЖЁЛТЫЙ');
-- тоже нашлось

select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан & красный');
-- no results
```

Если нужна логика и для двух слов
```postgresql
select article_id, title, content
from article
where tsv_content @@ to_tsquery('russian', 'банан | красный');
-- нашлось!
```

Если нужно расширить поиск ещё и по заголовку статьи, то можно включить и заголовок, и контент статьи в вектор
```postgresql
alter table article
drop column tsv_content,
add column tsv_content tsvector generated always as (
	setweight(to_tsvector('russian', title), 'a') ||
	setweight(to_tsvector('russian', content), 'b')
) stored;
```

Здесь важно обратить внимание на setweught - мы устанавливаем веса, для заголовка вес больший, чем для контента. При поиске слово в заголовке статьи будет считаться более релевантным, чем в контенте. И конечно результаты можно ранжировать
```postgresql
select article_id, title, content, ts_rank(tsv_content, to_tsquery('russian', 'поиск'))
from article
where tsv_content @@ to_tsquery('russian', 'поиск')
order by ts_rank(tsv_content, to_tsquery('russian', 'поиск')) desc;
----------
article_id	title	content	ts_rank
3	| Работа с индексами |	Индексы помогают ускорять поиск данных в базе.	| 0.06079271
```


**Примечание**

Полнотекстовой поиск работает нелохо на объёмах около десятков миллионов строк. Также можно посмотреть на другие системы, вроде ElasticSearch или Sphinx.