Индекс может использоваться тогда, когда он достаёт малую часть большой таблицы (селективность). Если же нам необходимо выбирать несколько полей, то мы можем навесить несколько индексов или один индекс на несколько колонок.

Какую стратегию выбрать? Если у нас есть условно один запрос, в котором мы всегда достаём одни поля, то лучше навесить один индекс на несколько колонок. Если же у нас много разных запрос то по одной, то по другой колонке, то лучше навесить разные индексы на разные колонки.

**Важно**
Здесь мы говорим о индексе на нескольких колонок. Порядок колонок в таком индексе очень важен. Например, мы создаём индекс по трём колонкам `(a,b,c)`.

1. Индекс будет использоваться при выборке по **первой колонке** (`a`);
2. Индекс будет использоваться при выборке по **первой и второй колонкам** (`a`, `b`);
3. Индекс будет использоваться при выборке по **первой, второй и третьей колонкам** (`a`, `b`, `c`);
4. Индекс **не** будет использоваться при выборке **по первой и третьей колонкам**, если в условии пропущена вторая (`b`);
5. Индекс **не** будет использоваться при выборке **только по третьей колонке**.

Иными словами, составной индекс эффективно работает только для фильтрации, начинающейся с его первых колонок без пропусков.

Пример:
Создадим таблицу и вставим рандомные данные
```postgresql
drop table if exists entity;

create table entity (
	entity_id bigint generated always as identity primary key,
	name varchar(50),
	address varchar(100)
);

insert into entity(name, address)
select 
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 41)::int + 10))
from generate_series(1, 10000000);
```

Создадим индекс по двум колонкам
```postgresql
create index idx_entity_name_address on entity(name, address);
```

И посмотрим explain analyze для разных запросов

По первой колонке индекс работает (Index Scan).
```postgresql
explain analyze
select * from entity where name = 'aaa';
______________________

Index Scan using idx_entity_name_address on entity  (cost=0.56..8.58 rows=1 width=67) (actual time=0.028..0.028 rows=0 loops=1)
  Index Cond: ((name)::text = 'aaa'::text)
Planning Time: 0.183 ms
Execution Time: 0.043 ms
```

По обоим колонкам индекс тоже работает
```postgresql
explain analyze
select * from entity where name = 'aaa' and address = 'bbb';
________________

Index Scan using idx_entity_name_address on entity  (cost=0.56..8.58 rows=1 width=67) (actual time=0.022..0.022 rows=0 loops=1)
  Index Cond: (((name)::text = 'aaa'::text) AND ((address)::text = 'bbb'::text))
Planning Time: 0.056 ms
Execution Time: 0.033 ms
```

А вот по последней колонке уже не работает
```postgresql
explain analyze
select * from entity where address = 'bbb';
_________________
Gather  (cost=1000.00..348742.77 rows=1 width=67) (actual time=339.797..344.467 rows=0 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Parallel Seq Scan on entity  (cost=0.00..347742.67 rows=1 width=67) (actual time=330.743..330.743 rows=0 loops=3)
        Filter: ((address)::text = 'bbb'::text)
        Rows Removed by Filter: 6666667
Planning Time: 0.053 ms
JIT:
  Functions: 6
  Options: Inlining false, Optimization false, Expressions true, Deforming true
  Timing: Generation 0.544 ms, Inlining 0.000 ms, Optimization 0.460 ms, Emission 5.694 ms, Total 6.698 ms
Execution Time: 344.681 ms
```


**Почему так?**
Потому что **B-tree индекс** построен по принципу **лексикографического порядка**:
* Сначала сортировка по name
* Внутри каждого name - сортировка по age