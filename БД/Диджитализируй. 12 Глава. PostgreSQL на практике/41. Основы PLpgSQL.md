Иногда декларативности (когда мы говорим что именно нужно, но детали реализации мы при этом не указываем) мало и для этого есть язык программирования Pl/pgSQL (процедурный язык программирования).

На этом ЯП мы можем писать разные управляющие конструкции и более сложную логику по обработке данных в Postgresql. Стоит сказать, что чаще всего такая логика пишется в слое самого приложения, но иногда это вполне уместно. Например, мы можем написать триггеры, которые будут срабатывать при изменении данных в какой-то таблице. Но не стоит злоупотреблять и писать сложную бизнес логику в postgresql.

Пример простой програмки с выводом Hello World
```postgresql
DO
postgres=# DO $$
BEGIN
    RAISE NOTICE 'Hello world!';
END $$;
-- вывод
NOTICE:  Hello world!
DO
```

Сама программа находится после внутри ограничителя, который здесь представлен в виде двойного символа доллара. На самом деле это просто ограничитель строки, чтобы внутри в ней не экранировать кавычки.

То есть строку в SQL можно определить так:
```postgresql
select 'hello';
```

или так:
```postgresql
select $$hello$$;
```

Разница этих подходов в том, что в первом случае, если внутри строки нам нужна кавычка, её надо экранировать, а во втором случае её экранировать не надо:
```postgresql
select $$hello nigga's$$;
select 'hello nigga''s';
```

До блока begin может быть использован блок declare, в котором мы объявляем переменные.

```postgresql
DO $$
DECLARE
  message text := 'Hello, World!';
  a int := 1;
  b bigint := 2;
BEGIN
  RAISE NOTICE '%', message;
  RAISE NOTICE '% + % = %', a, b, a + b;
END $$;
------ вывод
Hello world!
1 + 2 = 3
```

Здесь объявлены три переменные `message` с текстом, `a` и `b` с числами. И в программе сначала выводится значение переменной `message`, текст выводится в виде шаблона, то есть знак процента заменяется на значение переменной. И затем выводится шаблон, где первый символ процента заменяется значением переменной `a`, второй значением переменной `b`, а третий значением суммы `a` и `b`.

В PL/pgSQL есть ветвление логики с `if`:
```postgresql
DO $$
DECLARE
  today_day INT := EXTRACT(DAY FROM CURRENT_DATE); -- День месяца
  today_weekday INT := EXTRACT(DOW FROM CURRENT_DATE); -- День недели (0 - воскресенье, 6 - суббота)
BEGIN
  IF today_weekday IN (0, 6) THEN
    RAISE NOTICE 'Сегодня выходной (%-й день месяца, %-й день недели). Можно отдыхать!', today_day, today_weekday;
  ELSIF today_day % 2 = 0 THEN
    RAISE NOTICE 'Сегодня будний день и четное число (%-й день месяца). Работай продуктивно!', today_day;
  ELSE
    RAISE NOTICE 'Сегодня будний день и нечетное число (%-й день месяца). Осторожнее с решениями!', today_day;
  END IF;
END $$;
```

Есть циклы
```postgresql
DO $$
DECLARE
  day_counter INT := 1;
  days_in_month INT := EXTRACT(DAY FROM DATE_TRUNC('MONTH', CURRENT_DATE) + INTERVAL '1 MONTH' - INTERVAL '1 DAY');
  day_of_month DATE;
  weekday INT;
  weekday_name TEXT;
BEGIN
  RAISE NOTICE 'Календарь текущего месяца (% дней):', EXTRACT(DAY FROM DATE_TRUNC('MONTH', CURRENT_DATE) + INTERVAL '1 MONTH' - INTERVAL '1 DAY');

  LOOP
    -- Определяем дату
    day_of_month := DATE_TRUNC('MONTH', CURRENT_DATE) + (day_counter - 1) * INTERVAL '1 DAY';
    
    -- Определяем день недели (0 - воскресенье, 1 - понедельник, ..., 6 - суббота)
    weekday := EXTRACT(DOW FROM day_of_month);

    -- Определяем название дня недели
    CASE weekday
      WHEN 0 THEN weekday_name := 'Воскресенье';
      WHEN 1 THEN weekday_name := 'Понедельник';
      WHEN 2 THEN weekday_name := 'Вторник';
      WHEN 3 THEN weekday_name := 'Среда';
      WHEN 4 THEN weekday_name := 'Четверг';
      WHEN 5 THEN weekday_name := 'Пятница';
      WHEN 6 THEN weekday_name := 'Суббота';
    END CASE;

    -- Выводим результат
    IF weekday IN (0, 6) THEN
      RAISE NOTICE '% (% число) [ВЫХОДНОЙ]', weekday_name, day_counter;
    ELSE
      RAISE NOTICE '% (% число) ', weekday_name, day_counter;
    END IF;

    -- Увеличиваем счетчик
    day_counter := day_counter + 1;

    -- Условие выхода из цикла
    EXIT WHEN day_counter > days_in_month;
  END LOOP;
END $$;
```