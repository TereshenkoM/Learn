Задача СУБД, помимо прочих, выполнять запросы быстро. Странно, но факт, что в постановке такой задачи нет упоминания индексов вообще.

Существуют случаи, когда индекс есть, но его использовать не эффективно. Это случаи когда селективность запроса низкая.

* Низкая селективность - достаётся большая часть таблицы. В таком случае индекс полезен и может быть использован (если он есть).
* Высокая селективность - достаётся маленькая часть таблицы.В таком случае индекс бессмыслен(если он есть)

Например, в таблице с 10 миллионами записей достаётся 1 запись - это высокая селективность. В таблице с 10 миллионами записей достаётся 1 миллион записей - низкая селективность.

**Важно всегда понимать и думать о селективности индекса при построении запросов.**

**Пример**
Создадим таблицу
```postgresql
drop table if exists client;

create table client (
    client_id bigint generated always as identity primary key,
    first_name varchar(50) not null,
    last_name varchar(50) not null,
    sex char(1) not null check (sex in ('m', 'f'))
);

insert into client (first_name, last_name, sex)
select
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  case when random() < 0.5 then 'm' else 'f' end
from generate_series(1, 10000000);
```

Добавим индекс на колонку с полом
```postgresql
create index client_index_sex_ids on client(sex);
```

Будет ли он использоваться
```postgresql
explain analyze select * from client where sex='f';
------------------------------

Seq Scan on client  (cost=0.00..246163.00 rows=5028333 width=66) (actual time=1.618..651.233 rows=5001126 loops=1)
  Filter: (sex = 'f'::bpchar)
  Rows Removed by Filter: 4998874
Planning Time: 0.195 ms
JIT:
  Functions: 2
  Options: Inlining false, Optimization false, Expressions true, Deforming true
  Timing: Generation 0.161 ms, Inlining 0.000 ms, Optimization 0.151 ms, Emission 1.456 ms, Total 1.768 ms
Execution Time: 766.699 ms
```

Однако интересное, что если мы будем использовать не существующий пол, то индекс будет работать!

```postgresql
explain analyze select * from client where sex='r';
_____________________________
Index Scan using client_index_sex_ids on client  (cost=0.43..8.45 rows=1 width=66) (actual time=0.044..0.044 rows=0 loops=1)
  Index Cond: (sex = 'r'::bpchar)
Planning Time: 0.061 ms
Execution Time: 0.056 ms
```

Почему? Потому что статистика постгреса знает, что таких записей (sex=r) мало или вообще отсутствует и следовательно селективность такого запроса может быть очень высокой и это легче всего проверить именно по индексу


**И ещё раз! Индексы не бесплатные! Их нужно поддерживать!**

**При удалении, вставке, добавлении данных индексы нужно перестраивать. Также нужно заниматься ребалансировкой дерева в b-tree индексе, что требует ресурсов.**

**Вывод. Индексы стоит создавать только тогда, когда это необходимо и просто так их создавать не стоит.**