А что если мы читаем и изменяем данные в двух разных транзакциях?

Например

Откроем две транзакции
```postgresql
-- first psql
begin;

-- second psql
begin;
```

Теперь в первой транзакции изменим одну из строк таблицы. Увидим, что во второй транзакции данные не изменились
```postgresql
-- first
update account set balance=balance+1 where account_id=1;

-- second
table account;
-- видит старые данные
```

Операции друг друга не блокируют.

Как так? Почему разные транзакции видят разные данные, хотя по сути по работает с одним и тем же набором данных.

Это всё благодаря **MVCC - Multiversion concurrency control - многоверсионное управление конкурентным доступом **. Т.е. строки таблицы хранятся в БД в нескольких версиях и разные транзакции могут видеть разные версии одной и той же строки.

**Технически реализовано так,** что postgresql хранит для каждой строчки поля xmin и xmax - в них хранятся номер транзакций.  xmin хранит номер транзакции, которая создала эту версию строки, а в xmax хранится номер транзакции, которая изменила или удалила эту версию строки (если она актуальная, то xmax = 0).


xmin и xmax для первой транзакции из примера выше (txid_current - идентификатор текущей транзакции)
```postgresql
-- first
select account_id, balance, xmin, xmax from account;
 account_id | balance | xmin | xmax │
------------+---------+------+------ │
          2 | 2000 | 874 | 0 │
          1 | 1001 | 876 | 0 │
(2 строки)                          

select txid_current();
 txid_current │
-------------- │
          876 │
(1 строка)
```

Для второй транзакции
```postgresql
-- second
select txid_current();
 txid_current
--------------
          877
(1 строка)

select account_id, balance, xmin, xmax from account;
 accoДлunt_id | balance | xmin | xmax
------------+---------+------+------
          1 | 1000 | 874 | 876
          2 | 2000 | 874 | 0
(2 строки)
```

То есть во втором случае postgres видит, что запись с account_id=1 сейчас меняется, но она ещё не закомитилась.

**Теперь если закомитить изменения, то вторая транзакция будет их видеть.**
При этом важно, что не актуальные версии строк будут храниться до тех пор, пока не запустить команду **vacuum**. Её можно запустить вручную или автоматически она будет применена когда postgresql посчитает нужным.

Для того чтобы посмотреть эти данные можно воспользоваться расширением pg_dirtyread

Там можно увидеть, что строки с `xmax = 0` – действующие. Строки с `xmax ≠ 0` — удаленные, но еще не очищенные `VACUUM`'ом.

