
В прямом понимании не является частью масштабирования, но может быть его частью. Партицинирование - процесс разбиение таблицы на несколько таблиц (партиций).

Например, в базе данных мы храним бухгалтерские проводки. Если мы храним все данные в одной таблице, то когда мы будет делать запрос с методом доступа Seq Scan старые данные тоже будут сканироваться, чего может быть и не хочется на самом деле. Чаще всего данные нужны на текущий год.

Чтобы решить проблемы мы можем положить старые данные в другие таблицы на других дисках, а актуальные данные хранить в исходной (до партиционирования) таблице на быстром диске.

Партиции могут строиться по диапазону (например по годам), или по списку (например данные по этой странице в одной таблице, по другой стране в другой таблице), или по хешу (чтобы данные примерно равномерно размазались по таблицам).


Пример
```postgresql
drop table if exists transaction;
create table transaction (
    transaction_id bigint generated always as identity,
    transaction_date date not null,
    account_number varchar(50) not null,
    amount numeric(12, 2) not null,
    primary key (transaction_id, transaction_date)
) partition by range (transaction_date);
```

**Важно**
**Колонка, которую мы используем для партиции должна входить в первичный ключ.**


Здесь данные будут разделяться по `transaction_date`. Обратите внимание — если у таблицы есть первичный ключ, то колонка, по которой создаётся партиция, должна входить в первичный ключ. В нашем случае первичный ключ это идентификатор транзакции и дата транзакции. Иначе мы не сможем сделать партиции по дате транзакции. Создаём партиции по годам

```postgresql
create table transaction_2023 partition of transaction
for values from ('2023-01-01') to ('2024-01-01');

  
create table transaction_2024 partition of transaction
for values from ('2024-01-01') to ('2025-01-01');

create table transaction_2025 partition of transaction
for values from ('2025-01-01') to ('2026-01-01');
```

Ну и чтобы не создавать новую партицию каждый год мы можем руками, мы можем добавить запасную дефолтную партицию
```postgresql
create table transaction_future partition of transaction default;
```

Вставим данные и проверим содержимое партиций
```postgresql
insert into transaction (transaction_date, account_number, amount)
values
	('2024-07-20', '50101', 2500.75),
	('2025-03-15', '60101', 500.00);

table transaction;
 transaction_id | transaction_date | account_number | amount
----------------+------------------+----------------+---------
              1 | 2024-07-20 | 50101 | 2500.75
              2 | 2025-03-15 | 60101 | 500.00
```

Как видим всё есть в общей таблице transaction. Проверим другие таблицы
```postgresql
table transaction_2025;
 transaction_id | transaction_date | account_number | amount 
----------------+------------------+----------------+--------
              2 | 2025-03-15       | 60101          | 500.00


table transaction_2024;
 transaction_id | transaction_date | account_number | amount  
----------------+------------------+----------------+---------
              1 | 2024-07-20       | 50101          | 2500.75
```

И это всё работает автоматически.

Также мы можем сделать индекс по полю, по которому мы партиционируем и (как следствие) чаще выбираем
```postgresql
create index on transaction(transaction_date);
```
