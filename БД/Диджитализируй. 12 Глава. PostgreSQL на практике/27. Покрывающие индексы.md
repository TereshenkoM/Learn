Покрывающие индексы позволяют СУБД использовать метод доступа к данным Index Only Scan, то есть сканирование только индекса. Для этого можно использовать при создании индекса слово include, чтобы добавить ещё какие-то колонки в индекс. Эти колонки не будут участвовать в поиске, то есть в поиске будут участвовать только колонки, которые обычным образом добавлены в индекс, а колонки в блоке include просто могут доставаться сразу из индекса, а не из файлов самой таблицы.

Пример

Создадим базу и наполним её данными
```postgresql
drop table if exists client;

create table client (
    client_id bigint generated always as identity primary key,
    first_name varchar(50) not null,
    last_name varchar(50) not null,
    sex char(1) not null check (sex in ('m', 'f'))
);

insert into client (first_name, last_name, sex)
select
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  case when random() < 0.5 then 'm' else 'f' end
from generate_series(1, 10000000);
```

Соберём актуальную статистику
```postgresql
vacuum analyze;
```

Возьмём какой-то last_name
```postgresql
select last_name
from client
limit 1;
__________
8e06f6cac733bf0fe286751a07ba70d2f1a8203f9
```

Создадим по last_name индекс
```postgresql
create index client_last_name_idx on client(last_name);
```

И выполним explain analyze
```postgresql
explain analyze
select last_name
from client
where last_name='8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'
----------------------------
Index Only Scan using client_last_name_idx on client  (cost=0.56..4.58 rows=1 width=28) (actual time=0.038..0.039 rows=1 loops=1)
  Index Cond: (last_name = '8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'::text)
  Heap Fetches: 0
Planning Time: 0.151 ms
Execution Time: 0.051 ms
```

Здесь мы виден Index Only Scan, то есть обращение идёт только по индексу и в таблицу мы не идём. Это быстро.

Добавим ещё поле в выборку
```postgresql
explain analyze
select last_name, first_name
from client
where last_name='8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'
---------------------------
Index Scan using client_last_name_idx on client  (cost=0.56..8.58 rows=1 width=56) (actual time=0.019..0.019 rows=1 loops=1)
  Index Cond: ((last_name)::text = '8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'::text)
Planning Time: 0.097 ms
Execution Time: 0.030 ms
```

Теперь тут уже Index Scan. Здесь уже несколько медленней, так как мы уже вынуждено обращаемся к таблице.
Чтобы это использовалось тоже быстро, то мы можем добавить покрывающий индекс. То есть в индекс включить колонку, которую мы можем выбирать, но не можем по ней искать.

```postgresql
create index client_last_name_idx on client(last_name) include (first_name);
```

Таким образом данные мы достаём легче и видим Index Only Scan
```postgresql
explain analyze
select last_name, first_name
from client
where last_name='8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'
--------
Index Only Scan using client_last_name_idx on client  (cost=0.56..4.58 rows=1 width=56) (actual time=0.051..0.060 rows=1 loops=1)
  Index Cond: (last_name = '8e06f6cac733bf0fe286751a07ba70d2f1a8203f9'::text)
  Heap Fetches: 0
Planning Time: 0.201 ms
Execution Time: 0.081 ms
```


**Важно**
Если какое-то поле не используется для поиска и сортировки, не надо включать его в составной индекс, но можно включать в покрывающий. Все колонки, которые в составном индексе, влияют на планировщик, сортировку данных в индексе и тд, это лишняя работа, которую не надо выполнять, если она не является необходимой. Необходимой она является только если нужен поиск и/или сортировка по полям.