В одном из прошлых уроков мы уже делали функцию для генерации UUID V7

```postgresql
CREATE OR REPLACE FUNCTION
  uuid_generate_v7()
RETURNS
  uuid
LANGUAGE
  plpgsql
PARALLEL SAFE
AS $$
  DECLARE
    -- The current UNIX timestamp in milliseconds
    unix_time_ms CONSTANT bytea NOT NULL DEFAULT substring(int8send((extract(epoch FROM clock_timestamp()) * 1000)::bigint) from 3);

    -- The buffer used to create the UUID, starting with the UNIX timestamp and followed by random bytes
    buffer bytea NOT NULL DEFAULT unix_time_ms || gen_random_bytes(10);
  BEGIN
    -- Set most significant 4 bits of 7th byte to 7 (for UUID v7), keeping the last 4 bits unchanged
    buffer = set_byte(buffer, 6, (b'0111' || get_byte(buffer, 6)::bit(4))::bit(8)::int);

    -- Set most significant 2 bits of 9th byte to 2 (the UUID variant specified in RFC 4122), keeping the last 6 bits unchanged
    buffer = set_byte(buffer, 8, (b'10' || get_byte(buffer, 8)::bit(6))::bit(8)::int);

    RETURN encode(buffer, 'hex');
  END
$$
;
```
Мы видим тут `create or replace function` — создать или заменить функцию. Далее её имя, `uuid_generate_v7`. Функция не принимает на вход аргументов и возвращает тип данных `uuid`. Язык, на котором написана функция — PL/pgSQL. `Parallel safe` означает, что эта функция безопасна при выполнении в параллельных запросах. И затем идёт тело функции. В конце мы видим возвращаемое значение `RETURN`. А внутри самой функции реализована генерация UUID v7.

Попробуем для примера реализовать функцию для сложения двух чисел
```postgresql
CREATE OR REPLACE FUNCTION sum_two_numbers(a integer, b integer)
RETURNS integer AS $$
DECLARE
    result integer;
BEGIN
    result := a + b;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

Название функции `sum_two_numbers` и она принимает на вход два параметра — `a` и `b` типа `integer`. Возвращает функция тоже тип данных `integer`. Язык, на котором написана функция, тут указан в конце — это снова PL/pgSQL. И тело функции размещено между парными знаками доллара. Функция определяет в блоке `declare` переменную с именем `result` и типом `integer`. В неё сохраняется значение суммы двух переданных в функцию параметров и затем этот результат возвращается.

Вот так можно вызвать функцию
```postgresql
select sum_two_numbers(10, 22);
 
 sum_two_numbers
-----------------
              32
```

Функции могут вызываться в SQL-запросах, например, в `SELECT` или `INSERT`, а процедуры могут вызываться только с помощью слова `CALL`.

Вот, например, функция, которая проверяет положительное или отрицательное ей передано число:
```postgresql
CREATE FUNCTION check_number(n integer) RETURNS text AS $$
BEGIN
    IF n > 0 THEN
        RETURN 'Positive';
    ELSIF n < 0 THEN
        RETURN 'Negative';
    ELSE
        RETURN 'Zero';
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Протестируем функцию
select check_number(1);
 check_number
--------------
 Positive
```

Вот функция для суммирования чисел
```postgresql
CREATE FUNCTION sum_numbers(n integer) RETURNS integer AS $$
DECLARE
    total integer := 0;
    i integer;
BEGIN
    FOR i IN 1..n LOOP
        total := total + i;
    END LOOP;
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- Протестируем функцию
select sum_numbers(10);
 sum_numbers
-------------
	  55
```

Есть обработка ошибок
```postgresql
CREATE FUNCTION divide_numbers(a numeric, b numeric) RETURNS numeric AS $$
DECLARE
    result numeric;
BEGIN
    BEGIN
        result := a / b;
    EXCEPTION
        WHEN division_by_zero THEN
            RAISE NOTICE 'Ошибка: деление на ноль!';
            RETURN NULL;
    END;
    RETURN result;
END;
$$ LANGUAGE plpgsql;

select divide_numbers(10, 5);
select divide_numbers(10, 0);
```

Ещё внутри нашего PL/pgSQL кода можно полноценно использовать SQL.
```postgresql
drop table if exists client;
create table client(
    client_id bigint generated always as identity primary key,
    first_name varchar(200) not null,
    last_name varchar(200),
    middle_name varchar(200)
);

insert into client (first_name, last_name, middle_name) values
    ('Алексей', null, null),
    ('Сергей', null, 'Анатольевич'),
    ('Иван', 'Мусечкин', 'Васильевич');

create or replace function get_fio(
    first_name text,
    last_name text, 
    middle_name text)
returns text as $$
declare
    fio text := first_name;
begin
    if middle_name is not null and last_name is not null then
        fio := fio || ' ' || middle_name || ' ' || last_name;
    elseif middle_name is null and last_name is not null then
        fio := fio || ' ' || last_name;
    elseif middle_name is not null and last_name is null then
        fio := fio || ' ' || middle_name;
    end if;
    return fio;
end;
$$ language plpgsql;

select get_fio(first_name, last_name, middle_name) from client;
      get_fio
--------------------
 Алексей
 Сергей Анатольевич
 Иван Мусечкин
(3 строки)
```

Выше были описаны только функции. Но также plpgsql поддерживает и процедуры, они предназначены для выполнения действий и не возвращают значения.

```postgresql
create or replace procedure insert_client(fio text) as $$
declare
    name_parts text[];
    first_name text := null;
    last_name text := null;
    middle_name text := null;
begin
    name_parts := string_to_array(fio, ' ');
    
    if array_length(name_parts, 1) = 1 then
        first_name := name_parts[1];
    elsif array_length(name_parts, 1) = 2 then
        first_name := name_parts[1];
        last_name := name_parts[2];
    elsif array_length(name_parts, 1) = 3 then
        first_name := name_parts[1];
        last_name := name_parts[3];
        middle_name := name_parts[2];
    end if;
    
    insert into client (first_name, last_name, middle_name)
    values (first_name, last_name, middle_name);
end;
$$ language plpgsql;

truncate client;

call insert_client('Иннокентий');
call insert_client('Василий Хмурый');
call insert_client('Пётр Иванович Хитрый');

table client;
 client_id | first_name | last_name | middle_name
-----------+------------+-----------+-------------
         4 | Иннокентий | |
         5 | Василий | Хмурый |
         6 | Пётр | Иванович | Хитрый
(3 строки)
```