
Представление - по сути предсохранённый запрос. По сути мы сохраняем какой-то select и сохраняем в представление с каким-то именем. Далее можем выполнить этот запрос по имени представления. 


### Обычные view
Например

Есть таблица
```sql
drop table if exists employee;

create table employee (
	employee_id int primary key,
	name varchar(255) not null,
	department_id varchar(50) not null
);

insert into employee values
	(1, 'Алексей', 'IT'),
	
	(2, 'Пётр', 'HR'),
	
	(3, 'Андрей', 'HR'),
	
	(4, 'Иван', 'штатный киллер');
```

Вьюшка
```sql
create view hr_specialist as
select *
from employee
where department_id = 'HR';

select *
from hr_specialist;
```

Во вьюшке hr_specialist будут только hr.

Это очень удобно. Например в будущем мы хотим переработать структуру, но при этом данные, получаемые о hr остаются такие же. В таком случае нам например не нужно изменять логику и запросы в Python коде, ибо название такое же и поля те же.

**Однако на практике многие относятся ко вьюшкам, как к таблицам.**
**ЭТО НЕ ТАК, ЭТО НЕ ПРАВИЛЬНО.**
**VIEW - это запрос.**

Если мы пишем сложный запрос, то мы можем прийти к многократному выполнению view. То есть общий запрос будет не эффективен.

Пример
```sql
explain (analyze, buffers)
select 
    h1.employee_id as id1,
    h1.name as name1,
    h2.employee_id as id2,
    h2.name as name2
from 
    hr_specialist h1
join 
    hr_specialist h2
on 
    h1.employee_id <> h2.employee_id;
```

Результат анализа
```
Nested Loop  (cost=0.00..23.01 rows=1 width=1040) (actual time=0.013..0.017 rows=2 loops=1)
  Join Filter: (employee.employee_id <> employee_1.employee_id)
  Rows Removed by Join Filter: 2
  Buffers: shared hit=3
  ->  Seq Scan on employee  (cost=0.00..11.50 rows=1 width=520) (actual time=0.009..0.009 rows=2 loops=1)
        Filter: ((department_id)::text = 'HR'::text)
        Rows Removed by Filter: 2
        Buffers: shared hit=1
  ->  Seq Scan on employee employee_1  (cost=0.00..11.50 rows=1 width=520) (actual time=0.001..0.002 rows=2 loops=2)
        Filter: ((department_id)::text = 'HR'::text)
        Rows Removed by Filter: 2
        Buffers: shared hit=2
Planning:
  Buffers: shared hit=2
Planning Time: 0.165 ms
Execution Time: 0.034 ms
```

Здесь мы видим, что таблица employee у нас отсканировалась 2 раза. Это явно не очень хорошо. А если под вью будет более сложный вопрос? Он будет исполняться два раза. ПЛОХО.

Можно сделать вывод, что обычные view - редкость. Можно использовать например для безопасности (давай доступ ко view, а не к таблице).

### Материализованные view

В отличии от обычных вьюшек материализованные вьюшки, они уже являются сохранённым результатом выполнения запроса. По сути это уже почти таблица, почти т.к. нет возможности менять значения полей, нет возможности создать первичный ключ и т.д.

**Материализованная вьюшка - сохранённый запрос + сохранённые результаты**

Пример создания материализованной вьюшки
```postgresql
create materialized view hr_specialist as
select employee_id, name
from employee
where department_id='HR';

select *
from hr_specialist;
```

Тут уже explain analyze для того же запроса

```
Nested Loop  (cost=0.00..317.15 rows=19460 width=1040) (actual time=0.045..0.053 rows=2 loops=1)
  Join Filter: (h1.employee_id <> h2.employee_id)
  Rows Removed by Join Filter: 2
  Buffers: shared hit=2
  ->  Seq Scan on hr_specialist h1  (cost=0.00..11.40 rows=140 width=520) (actual time=0.014..0.015 rows=2 loops=1)
        Buffers: shared hit=1
  ->  Materialize  (cost=0.00..12.10 rows=140 width=520) (actual time=0.003..0.005 rows=2 loops=2)
        Buffers: shared hit=1
        ->  Seq Scan on hr_specialist h2  (cost=0.00..11.40 rows=140 width=520) (actual time=0.002..0.003 rows=2 loops=1)
              Buffers: shared hit=1
Planning Time: 0.191 ms
Execution Time: 0.087 ms
```

Тут снова 2 запроса. Но, тут мы уже читаем данные из диска. Следовательно запрос выполняется только 1 раз.


Если мы хотим в материализованной вьюшке требуется обновить данные (перезаписать), то нужно сделать
```postgresql
refresh materialized view concurrently hr_specialist;
```

При этом во время такого обновления доступ будет заблокирован. Если мы хотим обращаться к материализованному представлению при обновлении, то нужно сделать это конкурентно. Будет она при этом обновляться дольше.

```postgresql
refresh materialized view concurrently hr_specialist;
```

**Примечание**

При обновлении можно получить ошибку
```postgresql
ERROR: cannot refresh materialized view "public.hr_specialist" concurrently
  Hint: Create a unique index with no WHERE clause on one or more columns of the materialized view.
```

Она говорит о том, что нужно создать уникальный индекс на этой вьюшке
Например
```postgresql
create unique index hr_specialist_pk on hr_specialist(employee_id);
```

Теперь можно обновлять вьюшку.


**Материализованные вьюшки уже имеют больше применений.  Например для кеша.**

Например - расчёт аналитики за прошлый день. Мы можем запустить в полночь запрос и взять полученные данные из материализованной вьюшки.