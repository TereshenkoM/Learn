Индексы можно строить по всей таблице, а можно только по её части. При создании индекса можно добавить WHERE и указать условие, которому должны соответствовать все строки, попадающие в индекс. То есть индекс строится не на всех строках таблицы, а только на их подмножестве.

Пример
Создадим базу и заполним данные
```postgresql
drop table if exists client;

create table client (
    client_id bigint generated always as identity primary key,
    name varchar(50) not null,
    phone varchar(12)
);

insert into client (name, phone)
select 
  substring(md5(random()::text) || md5(random()::text)
            from 1 for (floor(random() * 46)::int + 5)),
  case 
    when random() < 0.01
      then to_char((floor(random() * 9000000000 + 1000000000))::bigint, 'fm9999999999')
    else null 
  end
from generate_series(1, 10000000);
```

Выполним создание полного индекса и соберём статистику по таблице
```postgresql
create index client_phone_idx on client(phone);
vacuum analyze client;
```

Такой индекс (по всем строкам) весит 68 Мб.
Возьмём какой-то  номер телефона
```postgresql
select phone from client where phone is not null limit 1;
--1000380645
```

И проведём explain analyze в запросе с использованием индекса
```postgresql
explain analyze select * from client where phone='1000380645';
________________________
Index Scan using client_phone_idx on client  (cost=0.43..8.45 rows=1 width=47) (actual time=0.049..0.050 rows=1 loops=1)
  Index Cond: ((phone)::text = '1000380645'::text)
Planning Time: 0.115 ms
Execution Time: 0.062 ms
```

Теперь попробуем удалить этот индекс и создать частичный индекс только по тем колонкам, где есть номер телефона
```postgresql
create index client_phone_idx on client(phone) where phone is not null;
```

Такой индекс уже весит 3Мб.
Проверим используется ли этот индекс.
```postgresql
explain analyze select * from client where phone='1000380645';
_______________
Index Scan using client_phone_idx on client  (cost=0.42..8.44 rows=1 width=47) (actual time=0.017..0.017 rows=1 loops=1)
  Index Cond: ((phone)::text = '1000380645'::text)
Planning Time: 0.144 ms
Execution Time: 0.027 ms
```

Такие индексы проще и легче. Они не будут перестраиваться в случае изменения строк не попадающих в подмножество (те, у которых нет номера телефона, а таких 99%).Также он может быть легче закеширован в кеше (так как он меньше). При этом нет смысла накидывать индекс на пустые значения (низкая селективность).

**Важно**
Фильтрация может быть только по тем полям, по которым создаётся индекс.