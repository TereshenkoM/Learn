Возможна аномалия неповторяемое чтение - когда один и тот же запрос в начале транзакции возвращает одни значения, а потом другие. Для того, чтобы такой аномалии не возникало и используется уровень изоляции Repeatable Read

Например
```sql
-- приведём данные к начальному виду
truncate account restart identity;
insert into account(balance) values (1000), (2000);
table account;  

-- first
begin;
select balance from account where account_id=1;

-- 1000
-- second — without begin and commit
update account set balance=balance+1 where account_id=1;
```


Теперь в первой транзакции данные изменятся
```sql
-- first
select balance from account where account_id=1;
-- 1001
```

То есть сначала мы увидели 1000, а далее 1001 - аномалия неповторяемого чтения.

Для решения и используется этот уровень изоляции
```sql
-- first
-- этот уровень ставим для той транзакции,
-- в которой мы хотим не иметь аномалии неповторяющегося чтения
begin transaction isolation level repeatable read;
select balance from account where account_id=1;
-- 1000

--second
update account set balance=balance+1 where account_id=1;

-- first
select balance from account where account_id=1;
-- 1000
```

Может всегда стоит использовать уровень изоляции REPEATABLE READ? Ведь он более строгий и лишён проблем READ COMMITED.

Кажется логично, но **чем более строгий уровень у транзакции, тем медленей она работает.**

Также на этом уровне возможно ошибки сериализации. На уровне READ COMMITED и READ UNCOMMITED мы лишены этих проблем. Также наш код должен смотреть за тем, как проходит сериализация и возможно её повторить.

Пример ошибки сериализации
```postgresql
-- first
begin transaction isolation level repeatable read;
update account set balance=balance+1 where account_id=1;

-- second
begin transaction isolation level repeatable read;
update account set balance=balance+2 where account_id=1;
```

Вторая транзакция зависает в ожидании, когда первая транзакция отпустит блокировку. Закоммитим первую транзакцию
```postgresql
commit;
```

Вторая сразу падает с ошибкой (даже не нужно комитить): «ERROR: could not serialize access due to concurrent update». И эту транзакцию надо заново создавать в коде приложения, то есть код должен отслеживать эту ситуацию и сам пересоздавать транзакцию.

Почему так произошло? Вторая транзакция основывалась на устаревших данных (`balance = 1000`), но первая транзакция уже изменила их. PostgreSQL не может гарантировать корректность выполнения в таком случае и поэтому просто принудительно отменяет вторую транзакцию.