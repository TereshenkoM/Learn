Самый жёсткий уровень изоляции. Фактически делает транзакции практически последовательными.
Практически не используется, так как он самый медленный.
Однако он может защищать от тех аномалий, от которых не может защитить даже repeatable read.

Есть такая аномалия - искажение записей, когда две транзакции одновременно читает две строки и на основании полученных данных вносят изменения в строки приводя к несогласованному состоянию БД. При этом итоговое состояние может быть таким, какое невозможно получить при последовательном выполнении транзакций.

Например: есть требование, что хотя бы один аккаунт имеет не нулевой баланс (не нулевой баланс определяет бизнес-логика).
```postgresql
-- приведём данные к начальному виду
truncate account restart identity;
insert into account(balance) values (1000), (1000);
table account;

-- first
begin transaction isolation level repeatable read;
-- Проверяем, что есть хотя бы один аккаунт с положительным балансом
-- Аналогично, проверяем условие на момент начала транзакции
select * from account where balance > 0;
-- Результат: две записи (account_id 1 и 2), оба с balance = 1000

-- Решаем обновить аккаунт 1, устанавливая баланс в 0
update account set balance = 0 where account_id = 1;
-- Транзакция A пока не коммитит изменения

-- second
begin transaction isolation level repeatable read;
-- Аналогично, проверяем условие на момент начала транзакции
select * from account where balance > 0;
-- Результат: две записи (account_id 1 и 2), оба с balance = 1000

-- Обновляем другой аккаунт: account_id = 2, устанавливая balance в 0
update account set balance = 0 where account_id = 2;
commit;

-- first
commit;

table account;
-- все аккаунты с нулевым балансом. Инвариант нарушен!
```

Уровень SERIALIZABLE позволяет этой аномалии избежать:
```postgresql
-- приведём данные к начальному виду
truncate account restart identity;
insert into account(balance) values (1000), (1000);
table account;

-- first
begin transaction isolation level serializable;
-- Проверяем, что есть хотя бы один аккаунт с положительным балансом
-- Аналогично, проверяем условие на момент начала транзакции
select * from account where balance > 0;
-- Результат: две записи (account_id 1 и 2), оба с balance = 1000

-- Решаем обновить аккаунт 1, устанавливая баланс в 0
update account set balance = 0 where account_id = 1;
-- Транзакция A пока не коммитит изменения

-- second
begin transaction isolation level serializable;
-- Аналогично, проверяем условие на момент начала транзакции
select * from account where balance > 0;
-- Результат: две записи (account_id 1 и 2), оба с balance = 1000

-- Обновляем другой аккаунт: account_id = 2, устанавливая balance в 0
update account set balance = 0 where account_id = 2;
commit;

-- first
commit;
-- ошибка сериализации!

table account;
-- есть аккаунт с ненулевым балансом, инвариант выполняется!
```

Этот уровень приводит к большому количеству проверок и он работает небыстро, что в многопользовательской большой системе может быть проблемой.