UUID - тип данных 16 байт, который генерируется каким-то алгоритмом. Единственная задача - быть уникальным. Вероятность получить колизию мала, 128 бит дают 10^80 вариантов.

Сейчас стоит использовать 7 версию uuid (uuid v7). Они используют временную метку  и благодаря этому начальные байты увеличиваются последовательно.

Например:
- 01952e42-62bf-74c0-a622-3ed083f494ea
- 01952e42-7480-7362-a189-3d50865dffb5
- 01952e42-843d-7598-a2fd-1320619a16e1
- 01952e42-90f8-7e91-9c0d-f979371d285e

Начальные байты растут последовательно и это позволяет нормально эти ключи хранить в B-Tree без постоянной перебалансировки дерева. Потому что в UUID v4, например, вот несколько сгенерированных последовательно значений:

- a2fe96e3-aeca-4a96-a47f-ddd6218545f0
- 3488ddf9-5a5b-4240-b649-064af5a880eb
- 39c76a72-1373-4296-afde-666d818f6699
- b9db613c-2e42-49de-a0c3-f032a7179ae9

В них нет никакой закономерности и каждая вставка может приводить к необходимости перебалансировки B-Tree индекса, чего бы не хотелось. Мы помним, что индекс B-Tree это сбалансированное дерево, его глубина всегда одинакова для всех веток и это надо поддерживать. Когда значения вставляются где попало, это не очень удобно. А для UUID v7 значения вставляются не где попало, а последовательно, всегда в конец значений, что удобно.

Как хранить UUID? Можно увидеть, как они хранятся в виде текста.
```postgresql
select pg_column_size('01952e42-62bf-74c0-a622-3ed083f494ea');
-- 37 bytes

select pg_column_size('01952e4262bf74c0a6223ed083f494ea');
-- 33 bytes
```

Стоит хранить это всегда в типе UUID
```postgresql
select pg_column_size('01952e42-62bf-74c0-a622-3ed083f494ea'::UUID);
-- 16 bytes

select pg_column_size('01952e4262bf74c0a6223ed083f494ea'::UUID);
-- 16 bytes
```

Как сгенирировать UUID? Алгоритм генерации сейчас есть в любом современном языке программирования, однако можно это сделать и на языке, встроенном в Postgres языке программирования PL/PGSQL (о нём далее), но используется это редко.

```postgresql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE FUNCTION
  uuid_generate_v7()
RETURNS
  uuid
LANGUAGE
  plpgsql
PARALLEL SAFE
AS $$
  DECLARE
    -- The current UNIX timestamp in milliseconds
    unix_time_ms CONSTANT bytea NOT NULL DEFAULT substring(int8send((extract(epoch FROM clock_timestamp()) * 1000)::bigint) from 3);

    -- The buffer used to create the UUID, starting with the UNIX timestamp and followed by random bytes
    buffer bytea NOT NULL DEFAULT unix_time_ms || gen_random_bytes(10);
  BEGIN
    -- Set most significant 4 bits of 7th byte to 7 (for UUID v7), keeping the last 4 bits unchanged
    buffer = set_byte(buffer, 6, (b'0111' || get_byte(buffer, 6)::bit(4))::bit(8)::int);

    -- Set most significant 2 bits of 9th byte to 2 (the UUID variant specified in RFC 4122), keeping the last 6 bits unchanged
    buffer = set_byte(buffer, 8, (b'10' || get_byte(buffer, 8)::bit(6))::bit(8)::int);

    RETURN encode(buffer, 'hex');
  END
$$
;
```

Её использование
```postgresql
select uuid_generate_v7();

select pg_column_size(uuid_generate_v7());
 pg_column_size
----------------
             16


drop table if exists client;
create table client (
    client_id uuid primary key default uuid_generate_v7(),
    name text not null
);

insert into client (name) values ('Алексей');

table client;
              client_id | name
--------------------------------------+---------
 01952e5f-bd33-7ff8-8952-169bc8d0ad07 | Алексей
```